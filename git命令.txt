https://www.cnblogs.com/weilantiankong/p/6144443.html
https://www.cnblogs.com/pyer/p/4752770.html

git config --global user.name 
git config --global user.email 

1. 查看远程分支

$ git branch -a
我在mxnet根目录下运行以上命令：

~/mxnet$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/nnvm
  remotes/origin/piiswrong-patch-1
  remotes/origin/v0.9rc1

可以看到，我们现在在master分支下

2. 查看本地分支

~/mxnet$ git branch
* master

3. 切换分支

git checkout -b dev//基于本地创建分支
git checkout -b dev origin/dev //基于远程分支创建本地分支
相当于 
创建分支： git branch dev
切换分支： git checkout dev 
是基于当前HEAD的

删除本地分支
git branch -D dev

删除远程分支
git push origin:branch-name

＃已经切换到v0.9rc1分支了
$ git branch
  master
* v0.9rc1

＃切换回master分支
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

1. 回滚变更
- 还没add，暂存区→工作区
    单个文件 ： git checkout + 文件名
    整个目录 ：git checkout .(这个点要加上的)
- add之后
    git reset HEAD . 
- 撤销commit
    //git reset Cmixed commit_id //此为默认方式，不带任何参数的git reset，
      即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息
    //git reset Csoft commit_id//回退到某个版本，只回退了commit的信息，不会恢复到index file一级。
      如果还要提交，直接commit即可
    git reset --hard commit_id //彻底回退到某个版本，本地的源码也会变为上一个版本的内容
    git push origin HEAD --force

当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用
1 git rm file_path
2 git commit -m 'delete somefile'4
3 git push
当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用
git rm -rf --cached file_path
git commit -m 'delete remote somefile'
git push

2. git add 命令添加所有改动内容
如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。注意 -A 选项后面还有一个句点。 
git add -A .表示添加所有内容， 
git add . 表示添加新文件和编辑过的文件不包括删除的文件; 
git add -u .表示添加编辑或者删除的文件，不包括新添加的文件。

3. 查看变更点
git diff  //工作区与暂存区比较
git diff HEAD  //工作区与提交区比较
git diff Ccached  //暂存区和提交区比较

git status //查看暂存区变更，只能查看未传送提交的次数
git cherry -v  //只能查看未传送提交的描述/说明
git log master ^origin/master则可以查看未传送提交的详细信息

用HEAD表示当前版本,上一个版本就是HEAD^，上上一个版本就是HEAD^^, 往上100个版本写成HEAD~100。
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

4. 修改commit的内容
修改还未push的注释：
git commit --amend
进入修改页面修改注释信息，修改后:wq保存退出。
刚刚push到远端还没有人其他人下载或改动的：
再使用git push --force-with-lease origin master
如果其他人已经下载或改动：
git fetch origin
git reset --hard origin/master

5. 修改前一次提交的方法
方法一：用Camend选项
#修改需要修改的地方。
git add .
git commit Camend
注：这种方式可以比较方便的保持原有的Change-Id，推荐使用。
方法二：先reset，再修改
这是可以完全控制上一次提交内容的方法。但在与Gerrit配合使用时，需特别注意保持同一个commit的多次提交的Change-Id是不变的。
否则，就需要Abondon之前的Change，产生一些垃圾不说，操作得不对，会使得简单的事情复杂化，甚至无法合并。
git reset HEAD^
#重新修改
git add .
git commit -m “MSG”
特别注意：为了保持提交到Gerrit的Change不变，需要复制对应的Change-Id到commit msg的最后，可以到Gerrit上对应的Change去复制，参见图1。
方法三：只是修改作者
如果email不对，会无法提交到Gerrit，所以这个命令也可能用到。
git commit Camend Cauthor=<user-email>
注：如果该email地址从未有过成功的提交，这个修改会不成功。在别的分支做一次成功提交之后，就可以修改了。

6. 查看commit提交的log
- 想看最近谁有提交，以及提交的描述： git log
- 仅仅想看最后一次的提交：git log -n 1
- 想看到最近一次提交所有更改过的文件：git log -n 1 --stat
- 想看到最近一次提交所有更改的细节：git log -n 1 -p

7. stash命令
- 添加改动到stash（工作区此时重置为HEAD内容）。在原分支 git stash save -a "message"  //在项目里加入了代码新文件的开发来说，-a选项才会将新加入的代码文件同时放入暂存区。
   git stash  
   git stash [save "message"] [-k|--no-keep-index] [--patch]  //[]内容可选，-k和--no-keep-index指定保存进度后是否重置暂存区，--patch 会显示工作区和HEAD的差异
- git stash pop  //恢复的是最近的一次改动
  git stash list  //恢复以前的改动，先获取列表
  git stash pop [--index] stash@{id} 恢复工作进度 //执行后删除id, --index 参数(可选)：不仅恢复工作区，还恢复暂存区
  git stash apply stash@{id} //执行后保留id
- git stash drop stash@{id}  //删除，如没有id就是删除最新的
- git stash branch branch_name stash@{id} 基于进度创建分支
- git  stash clear   //清除所有的
git push origin stash@{0}:refs/heads/stash0


8.  简单对比git pull和git pull --rebase的使用
使用下面的关系区别这两个操作：
git pull = git fetch + git merge
git pull --rebase = git fetch + git rebase

git pull Crebase 理解
这个命令做了以下内容：
a.把你 commit 到本地仓库的内容，取出来放到暂存区(stash)（这时你的工作区是干净的）
b.然后从远端拉取代码到本地，由于工作区是干净的，所以不会有冲突
c.从暂存区把你之前提交的内容取出来，跟拉下来的代码合并
所以 rebase 在拉代码前要确保你本地工作区是干净的，如果你本地修改的内容没完全 commit 或者 stash，就会 rebase 失败。You have unstaged changes.Please commit or stash them.
步骤如下：
  -  git fetch
  -  git rebase
  -  解决冲突
  -  git add 冲突文件
  -  git rebase Ccontinue
  -  git push
其中，3、4、5点，如果没遇到冲突就不用进行，直接push上去。
当遇到冲突时，git会提示patch failed，并要我们解决问题了再执行git rebase --continue
git rebase patch failed
rebase meets conflict
解决冲突后，通过git status可以看到rebase in progress，也就是说现在还是在rebase的过程中：
rebase in progress
然后我们把解决后的冲突文件add进来，并执行git rebase --continue继续patch（也可以执行Cskip跳过这个patch，或Cabort放弃rebase），可以看到分支是清晰的一条直线：
conflict solved
最后push，完成。

- 用merge确实只需要解决一遍冲突，比较简单粗暴
- 用rebase有时候会需要多次fix冲突（原因在于本地分支已经提交了非常多的commit，而且很久都没有和上游合并过）
我个人推荐大家开发的时候，尽量及时rebase上游分支（我习惯是每周merge一次），有冲突提前就fix掉，即使我们自己的分支开发了很久（哪怕是几个月），也不会积累太多的conflict，最后合并进主分支的时候特别轻松， 非常反对从master check出新分支，自己闷头开发几个月，结果最后merge进主分支的时候，一大堆冲突，自己还嗷嗷叫的行为 

fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。
因为在这个过程中没有创建commit
squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，
于是使用--squash进行合并，此时文件已经同合并后一样了，但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。
--no-ff指的是强行关闭fast-forward方式。git merge --no-ff -m "merge with no-ff" dev
因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。