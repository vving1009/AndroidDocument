Android 70道面试题汇总不再愁面试


本文为开发者奉献了70道经典Android面试题加答案--重要知识点几乎都涉及到了，你还等啥，赶紧收藏吧!!

　　1. 下列哪些语句关于内存回收的说明是正确的? (b) 

     A、 程序员必须创建一个线程来释放内存

　　B、 内存回收程序负责释放无用内存

　　C、 内存回收程序允许程序员直接释放内存

　　D、 内存回收程序可以在指定的时间释放内存对象

　　2. 下面异常是属于Runtime Exception 的是(abcd)(多选) 

     A、ArithmeticException

　　B、IllegalArgumentException

　　C、NullPointerException

　　D、BufferUnderflowException

　　3. Math.round(11.5)等于多少(). Math.round(-11.5)等于多少(c) 

     A、11 ,-11 B、11 ,-12 C、12 ,-11 D、12 ,-12

　　4. 下列程序段的输出结果是：(b )


  void complicatedexpression_r(){
　　 int x=20, y=30;
　　 boolean b;
　　 b=x>50&&y>60||x>50&&y<-60||x<-50&&y>60||x<-50&&y<-60;
　　 System.out.println(b);
　}
　　A、true B、false C、1 D、011.activity
　　5. 对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行(d) A、onPause() B、onCreate() C、 onResume() D、onStart()

　　6. Intent传递数据时，下列的数据类型哪些可以被传递(abcd)(多选) A、Serializable B、charsequence C、Parcelable D、Bundle

　　7. android 中下列属于Intent的作用的是(c) 

     A、实现应用程序间的数据共享

　　B、是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失

　　C、可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带

　　D、处理一个应用程序整体性的工作

　　8. 下列属于SAX解析xml文件的优点的是(b) 

     A、将整个文档树在内存中，便于操作，支持删除，修改，重新排列等多种功能

　　B、不用事先调入整个文档，占用资源少

　　C、整个文档调入内存，浪费时间和空间

　　D、不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会

　　消失

　　9. 下面的对自定style的方式正确的是


A、 <resources>
       <style name="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
                     </style>
</resources>
     B、 <style name="myStyle">
                            <itemname="android:layout_width">fill_parent</item>
   </style>
     C、 <resources>
                            <itemname="android:layout_width">fill_parent</item>
  </resources>
     D、 <resources>
                            <stylename="android:layout_width">fill_parent</style>
  </resources>


　　10. 在android中使用Menu时可能需要重写的方法有(ac)。(多选) 

     A、onCreateOptionsMenu()

　　B、onCreateMenu()

　　C、onOptionsItemSelected()

　　D、onItemSelected()

　　11. 在SQL Server Management Studio 中运行下列T-SQL语句，其输出值(c)。 SELECT @@IDENTITY

　　A、 可能为0.1

　　B、 可能为3

　　C、 不可能为-100

　　D、 肯定为0

　　12. 在SQL Server 2005中运行如下T-SQL语句，假定SALES表中有多行数据，执行查询之 后的结果是(d)。 

     BEGIN TRANSACTION A

　　Update SALES Set qty=30 WHERE qty<30

　　BEGIN TRANSACTION B

　　Update SALES Set qty=40 WHEREqty<40

　　Update SALES Set qty=50 WHEREqty<50

　　Update SALES Set qty=60 WHEREqty<60

　　COMMIT　TRANSACTION B

　　COMMIT TRANSACTION A

　　A、SALES表中qty列最小值大于等于30

　　B、SALES表中qty列最小值大于等于40

　　C、SALES表中qty列的数据全部为50

　　D、SALES表中qty列最小值大于等于60

　　13. 在android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库版本进行管理的方法可以是(ab) 

    A、getWriteableDatabase()

　　B、getReadableDatabase()

　　C、getDatabase()

　　D、getAbleDatabase()

　　14. android 关于service生命周期的onCreate()和onStart()说法正确的是(ad)(多选题) 

    A、当第一次启动的时候先后调用onCreate()和onStart()方法

　　B、当第一次启动的时候只会调用onCreate()方法

　　C、如果service已经启动，将先后调用onCreate()和onStart()方法

　　D、如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法

　　15. 下面是属于GLSurFaceView特性的是(abc)(多选) 

    A、管理一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图view上。

　　B、管理一个EGL display，它能让opengl把内容渲染到上述的surface上。

　　C、让渲染器在独立的线程里运作，和UI线程分离。

　　D、可以直接从内存或者DMA等硬件接口取得图像数据

　　16. 下面在AndroidManifest.xml文件中注册BroadcastReceiver方式正确的


A、<receiver android:name="NewBroad">
                     <intent-filter>
                            <action  
                   android:name="android.provider.action.NewBroad"/>
                <action>
                     </intent-filter>
              </receiver>
     B、<receiver android:name="NewBroad">
                     <intent-filter>
                   android:name="android.provider.action.NewBroad"/>
                     </intent-filter>
              </receiver>
     C、<receiver android:name="NewBroad">
                     <action  
                  android:name="android.provider.action.NewBroad"/>
             <action>
              </receiver>
     D、<intent-filter>
         <receiver android:name="NewBroad">
                           <action>
                   android:name="android.provider.action.NewBroad"/>
                  <action>
                     </receiver>
</intent-filter>

　　17. 关于ContenValues类说法正确的是(a) 

    A、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的

　　名是String类型，而值都是基本类型

　　B、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的

　　名是任意类型，而值都是基本类型

　　C、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的

　　名，可以为空，而值都是String类型

　　D、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中

　　的名是String类型，而值也是String类型

　　18. 我们都知道Hanlder是线程与Activity通信的桥梁,如果线程处理不当，你的机器就会变得越慢，那么线程销毁的方法是(a) 

    A、onDestroy()

　　B、onClear()

　　C、onFinish()

　　D、onStop()

　　19. 下面退出Activity错误的方法是(c) 

    A、finish()

　　B、抛异常强制退出

　　C、System.exit()

　　D、onStop()

　　20. 下面属于android的动画分类的有(ab)(多项) 

    A、Tween B、Frame C、Draw D、Animation

　　21. 下面关于Android dvm的进程和Linux的进程,应用程序的进程说法正确的是(d) 

    A、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM都是在Linux中的一个进程,所以说可以认为是同一个概念.

　　B、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux中的一个进程,所以说不是一个概念.

　　C、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux中的一个进程,所以说不是一个概念.

　　D、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的 Dalvik虚拟机实例.而每一个DVM都是在Linux中的一个进程,所以说可以认为是同一个概念.

　　22. Android项目工程下面的assets目录的作用是什么b

    A、放置应用到的图片资源。

　　B、主要放置多媒体等数据文件

　　C、放置字符串，颜色，数组等常量数据

　　D、放置一些与UI相应的布局文件，都是xml文件

　　23. 关于res/raw目录说法正确的是(a)A、 这里的文件是原封不动的存储到设备上不会转换为二进制的格式

　　B、这里的文件是原封不动的存储到设备上会转换为二进制的格式

　　C、 这里的文件最终以二进制的格式存储到指定的包中

　　D、这里的文件最终不会以二进制的格式存储到指定的包中

　　24. 下列对android NDK的理解正确的是(abcd )

    A、 NDK是一系列工具的集合

　　B、 NDK 提供了一份稳定、功能有限的 API 头文件声明。

　　C、 使 “Java+C” 的开发方式终于转正，成为官方支持的开发方式

　　D、 NDK 将是 Android 平台支持 C 开发的开端

　　二.文件存储方式

　　三.SQLite数据库方式

　　四.内容提供器(Content provider)方式


　　二、Android面试填空题

　　25. android中常用的四个布局是framlayout，linenarlayout，relativelayout和tablelayout。

    26. android 的四大组件是activiey，service，broadcast和contentprovide。27. java.io包中的objectinputstream和objectoutputstream类主要用于对对象(Object)的读写。

    28. android 中service的实现方法是：startservice和bindservice。

    29. activity一般会重载7个方法用来维护其生命周期，除了onCreate(),onStart(),onDestory() 外还有onrestart,onresume,onpause,onstop。

    30. android的数据存储的方式sharedpreference,文件,SQlite,contentprovider,网络。

    31. 当启动一个Activity并且新的Activity执行完后需要返回到启动它的Activity来执行 的回调函数是startActivityResult()。

    32. 请使用命令行的方式创建一个名字为myAvd,sdk版本为2.2,sd卡是在d盘的根目录下,名字为scard.img， 并指定屏幕大小HVGA.____________________________________。

    33. 程序运行的结果是：_____good and gbc__________。 

    public classExample{
　　String str=new String("good");
　　char[]ch={'a','b','c'};
　　public static void main(String args[]){
　　Example ex=new Example();
　　ex.change(ex.str,ex.ch);
　　System.out.print(ex.str+" and ");
　　Sytem.out.print(ex.ch);
　　}
　　public void change(String str,char ch[]){
　　str="test ok";
　　ch[0]='g';
　　}
　　}

　　34. 在android中，请简述jni的调用过程。(8分)

    1)安装和下载Cygwin，下载 Android NDK

　　2)在ndk项目中JNI接口的设计

　　3)使用C/C++实现本地方法

　　4)JNI生成动态链接库.so文件

　　5)将动态链接库复制到java工程，在java工程中调用，运行java工程即可

　　35. 简述Android应用程序结构是哪些?(7分)Android应用程序结构是：

　　Linux Kernel(Linux内核)、Libraries(系统运行库或者是c/c++核心库)、Application

　　Framework(开发框架包)、Applications (核心应用程序)

　　36. 请继承SQLiteOpenHelper实现：(10分) 

    1).创建一个版本为1的“diaryOpenHelper.db”的数据库，

　　2).同时创建一个 “diary” 表(包含一个_id主键并自增长，topic字符型100

　　长度， content字符型1000长度)

　　3).在数据库版本变化时请删除diary表，并重新创建出diary表。

　　

publicclass DBHelper extends SQLiteOpenHelper{
　　public final static String DATABASENAME ="diaryOpenHelper.db";
　　public final static int DATABASEVERSION =1;
　　//创建数据库
　　public DBHelper(Context context,Stringname,CursorFactory factory,int version)
　　{
　　super(context, name, factory,version);
　　}
　　//创建表等机构性文件
　　public void onCreate(SQLiteDatabase db)
　　{
　　String sql ="create tablediary"+
　　"("+
　　"_idinteger primary key autoincrement,"+
　　"topicvarchar(100),"+
　　"contentvarchar(1000)"+
　　")";
　　db.execSQL(sql);
　　}
　　//若数据库版本有更新，则调用此方法
　　public void onUpgrade(SQLiteDatabasedb,int oldVersion,int newVersion)
　　{
　　String sql = "drop table ifexists diary";
　　db.execSQL(sql);
　　this.onCreate(db);
　　}
　　}

　　37. 页面上现有ProgressBar控件progressBar，请用书写线程以10秒的的时间完成其进度显示工作。(10分)答案

　　

publicclass ProgressBarStu extends Activity {
　　private ProgressBar progressBar = null;
　　protected void onCreate(BundlesavedInstanceState) {
　　super.onCreate(savedInstanceState);
　　setContentView(R.layout.progressbar);
　　//从这到下是关键
　　progressBar = (ProgressBar)findViewById(R.id.progressBar);
　　Thread thread = new Thread(newRunnable() {
　　@Override
　　public void run() {
　　int progressBarMax =progressBar.getMax();
　　try {
　　while(progressBarMax!=progressBar.getProgress())
　　{
　　intstepProgress = progressBarMax/10;
　　intcurrentprogress = progressBar.getProgress();
　　progressBar.setProgress(currentprogress+stepProgress);
　　Thread.sleep(1000);
　　}
　　} catch(InterruptedException e) {
　　// TODO Auto-generatedcatch block
　　e.printStackTrace();
　　}
　　}
　　});
　　thread.start();
　　//关键结束
　　}
　　}

　　38. 请描述下Activity的生命周期。 必调用的三个方法：onCreate() --> onStart() --> onResume()，用AAA表示

　　(1)父Activity启动子Activity，子Actvity退出，父Activity调用顺序如下

　　AAA --> onFreeze() --> onPause() --> onStop() --> onRestart()--> onStart(),onResume() …

　　(2)用户点击Home，Actvity调用顺序如下

　　AAA --> onFreeze() --> onPause() --> onStop() -- Maybe -->onDestroy() C Maybe

　　(3)调用finish()， Activity调用顺序如下

　　AAA --> onPause() --> onStop() --> onDestroy()

　　(4)在Activity上显示dialog，Activity调用顺序如下

　　AAA

　　(5)在父Activity上显示透明的或非全屏的activity，Activity调用顺序如下

　　AAA --> onFreeze() --> onPause()

　　(6)设备进入睡眠状态，Activity调用顺序如下

　　AAA --> onFreeze() --> onPause()

　　39. 如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态? onSaveInstanceState()

　　当你的程序中某一个Activity A在运行时，主动或被动地运行另一个新的Activity B，这个时候A会执行onSaveInstanceState()。B完成以后又会来找A，这个时候就有两种情况：一是A被回收，二是A没有被回收，被回收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上了参数savedInstanceState;而没被收回的就直接执行onResume()，跳过onCreate()了。

　　40. 如何将一个Activity设置成窗口的样式。 在AndroidManifest.xml 中定义Activity的地方一句话android:theme="@android:style/Theme.Dialog"或android:theme="@android:style/Theme.Translucent"就变成半透明的

　　41. 如何退出Activity?如何安全退出已调用多个Activity的Application?对于单一Activity的应用来说，退出很简单，直接finish()即可。

　　当然，也可以用killProcess()和System.exit()这样的方法。

　　但是，对于多Activity的应用来说，在打开多个Activity后，如果想在最后打开的Activity直接退出，上边的方法都是没有用的，因为上边的方法都是结束一个Activity而已。

　　当然，网上也有人说可以。

　　就好像有人问，在应用里如何捕获Home键，有人就会说用keyCode比较KEYCODE_HOME即可，而事实上如果不修改framework，根本不可能做到这一点一样。

　　所以，最好还是自己亲自试一下。

　　那么，有没有办法直接退出整个应用呢?

　　在2.1之前，可以使用ActivityManager的restartPackage方法。

　　它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。

　　注意不要被它的名字迷惑。

　　可是，在2.2，这个方法失效了。

　　在2.2添加了一个新的方法，killBackgroundProcesses()，需要权限android.permission.KILL_BACKGROUND_PROCESSES。

　　可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。

　　另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。

　　它需要权限android.permission.FORCE_STOP_PACKAGES。

　　并且需要添加android:sharedUserId="android.uid.system"属性

　　同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。

　　因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。

　　而Android.mk是用于在Android源码下编译程序用的。

　　从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。

　　现提供几个方法，供参考：

　　1、抛异常强制退出：

　　该方法通过抛异常，使程序ForceClose。

　　验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。

　　2、记录打开的Activity：

　　每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。

　　3、发送特定广播：

　　在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。

　　4、递归退出

　　在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。

　　除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。

　　但是这样做同样不完美。

　　你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。

　　但至少，我们的目的达到了，而且没有影响用户使用。

　　为了编程方便，最好定义一个Activity基类，处理这些共通问题。

　　42. 请介绍下Android中常用的五种布局。FrameLayout(框架布局)，LinearLayout (线性布局)，AbsoluteLayout(绝对布局)，RelativeLayout(相对布局)，TableLayout(表格布局)

　　43. 请介绍下Android的数据存储方式。一.SharedPreferences方式


　　五. 网络存储方式

　　44. 请介绍下ContentProvider是如何实现数据共享的。创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Contentprovider中，前提是有相同数据类型并且有写入Content provider的权限。

　　45. 如何启用Service，如何停用Service。Android中的service类似于windows中的service，service一般没有用户操作界面，它运行于系统中不容易被用户发觉，

　　可以使用它开发如监控之类的程序。

　　一。步骤

　　第一步：继承Service类

　　public class SMSService extends Service { }

　　第二步：在AndroidManifest.xml文件中的节点里对服务进行配置:

　　二。Context.startService()和Context.bindService

　　服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可

　　以启动Service，但是它们的使用场合有所不同。

　　1.使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。

　　使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。

　　2.采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，

　　接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并

　　不会导致多次创建服务，但会导致多次调用onStart()方法。

　　采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用

　　onDestroy()方法。

　　3.采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，

　　接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，

　　。接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会

　　导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务

　　解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()-->onDestroy()方法。

　　三。Service的生命周期

　　1.Service常用生命周期回调方法如下：

　　onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，

　　服务也只被创建一次。 onDestroy()该方法在服务被终止时调用。

　　2. Context.startService()启动Service有关的生命周期方法

　　onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。

　　多次调用startService()方法尽管不会多次创建服务，但onStart()方法会被多次调用。

　　3. Context.bindService()启动Service有关的生命周期方法

　　onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，

　　当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。

　　onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用。

　　备注：

　　1. 采用startService()启动服务

　　Intent intent =new Intent(DemoActivity.this, DemoService.class);
　　startService(intent);

　　2.Context.bindService()启动

　　Intent intent =new Intent(DemoActivity.this, DemoService.class);
　　bindService(intent, conn, Context.BIND_AUTO_CREATE);
　　//unbindService(conn);//解除绑定

　　46. 注册广播有几种方式，这些方式有何优缺点?请谈谈Android引入广播机制的用意。 Android广播机制(两种注册方法)

　　在android下，要想接受广播信息，那么这个广播接收器就得我们自己来实现了，我们可以继承BroadcastReceiver，就可以有一个广播接受器了。有个接受器还不够，我们还得重写BroadcastReceiver里面的onReceiver方法，当来广播的时候我们要干什么，这就要我们自己来实现，不过我们可以搞一个信息防火墙。具体的代码：

　　public class SmsBroadCastReceiverextends BroadcastReceiver
　　{
　　@Override
　　public void onReceive(Context context, Intent intent)
　　{
　　Bundle bundle = intent.getExtras();
　　Object[] object = (Object[])bundle.get("pdus");
　　SmsMessage sms[]=new SmsMessage[object.length];
　　for(int i=0;i
　　{
　　sms[0] =SmsMessage.createFromPdu((byte[])object);
　　Toast.makeText(context, "来自"+sms.getDisplayOriginatingAddress()+"的消息是："+sms.getDisplayMessageBody(),Toast.LENGTH_SHORT).show();
　　}
　　//终止广播，在这里我们可以稍微处理，根据用户输入的号码可以实现短信防火墙。
　　abortBroadcast();
　　}
　　}

　　当实现了广播接收器，还要设置广播接收器接收广播信息的类型，这里是信息：android.provider.Telephony.SMS_RECEIVED

　　我们就可以把广播接收器注册到系统里面，可以让系统知道我们有个广播接收器。这里有两种，一种是代码动态注册：

　　//生成广播处理
　　smsBroadCastReceiver = newSmsBroadCastReceiver();
　　//实例化过滤器并设置要过滤的广播
　　IntentFilter intentFilter = newIntentFilter("android.provider.Telephony.SMS_RECEIVED");
　　//注册广播
　　BroadCastReceiverActivity.this.registerReceiver(smsBroadCastReceiver,intentFilter);

　　一种是在AndroidManifest.xml中配置广播

　　package="spl.broadCastReceiver"

　　android:versionCode="1"

　　android:versionName="1.0">

　　android:label="@string/app_name">

　　两种注册类型的区别是：

　　1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。

　　2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。

　　47. 请解释下在单线程模型中Message、Handler、MessageQueue、Looper之间的关系。Handler简介：

　　一个Handler允许你发送和处理Message和Runable对象，这些对象和一个线程的MessageQueue相关联。每一个线程实例和一个单独的线程以及该线程的MessageQueue相关联。当你创建一个新的Handler时，它就和创建它的线程绑定在一起了。这里，线程我们也可以理解为线程的MessageQueue。从这一点上来看，Handler把Message和Runable对象传递给MessageQueue，而且在这些对象离开MessageQueue时，Handler负责执行他们。

　　Handler有两个主要的用途：(1)确定在将来的某个时间点执行一个或者一些Message和Runnable对象。(2)在其他线程(不是Handler绑定线程)中排入一些要执行的动作。

　　Scheduling Message，即(1)，可以通过以下方法完成：

　　post(Runnable):Runnable在handler绑定的线程上执行，也就是说不创建新线程。

　　postAtTime(Runnable,long):

　　postDelayed(Runnable,long):

　　sendEmptyMessage(int):

　　sendMessage(Message):

　　sendMessageAtTime(Message,long):

　　sendMessageDelayed(Message,long):

　　post这个动作让你把Runnable对象排入MessageQueue,MessageQueue受到这些消息的时候执行他们，当然以一定的排序。sendMessage这个动作允许你把Message对象排成队列，这些Message对象包含一些信息，Handler的hanlerMessage(Message)会处理这些Message.当然，handlerMessage(Message)必须由Handler的子类来重写。这是编程人员需要作的事。

　　当posting或者sending到一个Hanler时，你可以有三种行为：当MessageQueue准备好就处理，定义一个延迟时间，定义一个精确的时间去处理。后两者允许你实现timeout,tick,和基于时间的行为。

　　当你的应用创建一个新的进程时，主线程(也就是UI线程)自带一个MessageQueue，这个MessageQueue管理顶层的应用对象(像activities,broadcast receivers等)和主线程创建的窗体。你可以创建自己的线程，并通过一个Handler和主线程进行通信。这和之前一样，通过post和sendmessage来完成，差别在于在哪一个线程中执行这么方法。在恰当的时候，给定的Runnable和Message将在Handler的MessageQueue中被Scheduled。

　　Message简介：

　　Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象提供额外的两个int域和一个Object域，这可以让你在大多数情况下不用作分配的动作。

　　尽管Message的构造函数是public的，但是获取Message实例的最好方法是调用Message.obtain(),或者Handler.obtainMessage()方法，这些方法会从回收对象池中获取一个。

　　MessageQueue简介：

　　这是一个包含message列表的底层类。Looper负责分发这些message。Messages并不是直接加到一个MessageQueue中，而是通过MessageQueue.IdleHandler关联到Looper。

　　你可以通过Looper.myQueue()从当前线程中获取MessageQueue。

　　Looper简介：

　　Looper类被用来执行一个线程中的message循环。默认情况，没有一个消息循环关联到线程。在线程中调用prepare()创建一个Looper，然后用loop()来处理messages，直到循环终止。

　　大多数和message loop的交互是通过Handler。

　　下面是一个典型的带有Looper的线程实现。

　　

class LooperThread extends Thread {
　　public Handler mHandler;
　　public void run() {
　　Looper.prepare();
　　mHandler = new Handler() {
　　public voidhandleMessage(Message msg) {
　　// process incomingmessages here
　　}
　　};
　　Looper.loop();
　　}
　　}

　　48. AIDL的全称是什么?如何工作?能处理哪些类型的数据?AIDL的英文全称是Android Interface Define Language

　　当A进程要去调用B进程中的service时，并实现通信，我们通常都是通过AIDL来操作的

　　A工程：

　　首先我们在net.blogjava.mobile.aidlservice包中创建一个RemoteService.aidl文件，在里面我们自定义一个接口，含有方法get。ADT插件会在gen目录下自动生成一个RemoteService.java文件，该类中含有一个名为RemoteService.stub的内部类，该内部类中含有aidl文件接口的get方法。

　　说明一：aidl文件的位置不固定，可以任意

　　然后定义自己的MyService类，在MyService类中自定义一个内部类去继承RemoteService.stub这个内部类，实现get方法。在onBind方法中返回这个内部类的对象，系统会自动将这个对象封装成IBinder对象，传递给他的调用者。

　　其次需要在AndroidManifest.xml文件中配置MyService类，代码如下：

　　为什么要指定调用AIDL服务的ID,就是要告诉外界MyService这个类能够被别的进程访问，只要别的进程知道这个ID，正是有了这个ID,B工程才能找到A工程实现通信。

　　说明：AIDL并不需要权限

　　B工程：

　　首先我们要将A工程中生成的RemoteService.java文件拷贝到B工程中，在bindService方法中绑定aidl服务

　　绑定AIDL服务就是将RemoteService的ID作为intent的action参数。

　　说明：如果我们单独将RemoteService.aidl文件放在一个包里，那个在我们将gen目录下的该包拷贝到B工程中。如果我们将RemoteService.aidl文件和我们的其他类存放在一起，那么我们在B工程中就要建立相应的包，以保证RmoteService.java文件的报名正确，我们不能修改RemoteService.java文件

　　bindService(newInten("net.blogjava.mobile.aidlservice.RemoteService"),serviceConnection, Context.BIND_AUTO_CREATE);

　　ServiceConnection的onServiceConnected(ComponentName name, IBinderservice)方法中的service参数就是A工程中MyService类中继承了RemoteService.stub类的内部类的对象。

　　49. 请解释下Android程序运行时权限与文件系统权限的区别。运行时权限Dalvik( android授权)

　　文件系统 linux 内核授权

　　50. 系统上安装了多种浏览器，能否指定某浏览器访问指定页面?请说明原由。通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性

　　51. 你如何评价Android系统?优缺点。答：Android平台手机 5大优势：

　　一、开放性

　　在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。

　　二、挣脱运营商的束缚

　　在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样?互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。

　　三、丰富的硬件选择

　　这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢?

　　四、不受任何限制的开发商

　　Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。

　　五、无缝结合的Google应用

　　如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。

　　再说Android的5大不足：

　　一、安全和隐私

　　由于手机与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。

　　二、首先开卖Android手机的不是最大运营商

　　众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了!

　　三、运营商仍然能够影响到Android手机

　　在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。

　　四、同类机型用户减少

　　在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。

　　五、过分依赖开发商缺少标准配置

　　在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。

　　52. 什么是ANR 如何避免它?

　　答：ANR：Application NotResponding，五秒

　　在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：

　　对输入事件(如按键、触摸屏事件)的响应超过5秒

　　意向接受器(intentReceiver)超过10秒钟仍未执行完毕

　　Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intentbroadcast)。

　　因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和 onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束 -- 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。

　　53. 什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?

　　答：一般像空指针啊，可以看起logcat，然后对应到程序中 来解决错误

　　54. Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决?

　　55. 简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver

　　答：一个activity呈现了一个用户可以操作的可视化用户界面

　　一个service不包含可见的用户界面，而是在后台无限地运行

　　可以连接到一个正在运行的服务中，连接后，可以通过服务中暴露出来的借口与其进行通信

　　一个broadcast receiver是一个接收广播消息并作出回应的component，broadcastreceiver没有界面

　　intent:content provider在接收到ContentResolver的请求时被激活。

　　activity, service和broadcast receiver是被称为intents的异步消息激活的。

　　一个intent是一个Intent对象，它保存了消息的内容。对于activity和service来说，它指定了请求的操作名称和待操作数据的URI

　　Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。

　　它是通过将Intent对象和目标的intent filter相比较来完成这一工作的。一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。

　　56. 　IntentService有何优点?

　　答：IntentService 的好处

　　* Acitivity的进程，当处理Intent的时候，会产生一个对应的Service

　　* Android的进程处理器现在会尽可能的不kill掉你

　　* 非常容易使用

　　57. 横竖屏切换时候activity的生命周期?

　　1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次

　　2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次

　　3、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法

　　如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?

　　解答：可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中

　　58. 如何将打开res aw目录中的数据库文件?

　　解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。

　　59. Android引入广播机制的用意?

　　答：a:从MVC的角度考虑(应用程序内)

　　其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。

　　b：程序间互通消息(例如在自己的应用程序内监听系统来电)

　　c：效率上(参考UDP的广播协议在局域网的方便性)

　　d：设计模式上(反转控制的一种应用，类似监听者模式)

　　60. Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念

　　DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。

　　61. sim卡的EF 文件有何作用

　　sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的

　　62. 嵌入式操作系统内存管理有哪几种， 各有何特性

　　页式，段式，段页，用到了MMU,虚拟空间等技术

　　63. 什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?

　　嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。

　　64. 一条最长的短信息约占多少byte?

　　中文70(包括标点)，英文160，160个字节。

　　65. android中的动画有哪几类，它们的特点和区别是什么?

　　两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。

　　66. handler机制的原理

　　andriod提供了Handler 和 Looper 来满足线程间的通信。Handler先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。

　　1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的MessageQueue(消息队列)。

　　2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到MessageQueue里;或者接收Looper从Message Queue取出)所送来的消息。

　　3) Message Queue(消息队列):用来存放线程放入的消息。

　　4)线程：UIthread 通常就是main thread，而Android启动程序时会替它建立一个MessageQueue。

　　67. 说说mvc模式的原理，它在android中的运用

　　MVC(Model_view_contraller)”模型_视图_控制器”。 MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Contro

　　68. DDMS和TraceView的区别? DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。

　　69. java中如何引用本地语言 可以用JNI(java nativeinterface java 本地接口)接口。

　　70. 谈谈Android的IPC(进程间通信)机制 IPC是内部进程通信的简称， 是共享"命名管道"的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。

　　71. NDK是什么NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。

　　NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so  

=============================================================================


  Android面试题目及其答案    .


2015-09-04 22:04 2043人阅读 评论(0) 收藏 举报 
.  

 分类： 

android 开发学习（273）   


 .

From http://blog.csdn.NET/wwj_748/article/details/8868640


1、Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念

 

　　DVM指dalivk的虚拟机。每一个android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在linux中的一个进程，所以说可以认为是同一个概念。

 

2、sim卡的EF文件有何作用

 

　　sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的

 

3、嵌入式操作系统内存管理有哪几种，各有何特性

 

　　页式，段式，段页，用到了MMU,虚拟空间等技术

 

4、 什么是嵌入式实时操作系统,Android 操作系统属于实时操作系统吗?

 

　　嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。

 

5、一条最长的短信息约占多少byte?

 

　　中文70(包括标点)，英文160，160个字节。

 

6、android中的动画有哪几类，它们的特点和区别是什么?

 

　　两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。

 

7、handler机制的原理

 

　　andriod提供了 Handler 和Looper 来满足线程间的通信。Handler先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。

 

　　1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的MessageQueue(消息队列)。

 

　　2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从MessageQueue取出)所送来的消息。

 

　　3) Message Queue(消息队列):用来存放线程放入的消息。

 

　　4)线程：UI thread 通常就是mainthread，而Android启动程序时会替它建立一个MessageQueue。

 

8、说说mvc模式的原理，它在android中的运用

 

　MVC(Model_view_controller)”模型_视图_控制器”。MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Contro

 

9、Activity的生命周期

 

　　和其他手机平台 的应用 程序 一样，Android的应用程序 的生命周期是被统一掌控 的，也 就是说我们写的应用程序命运掌握在别人(系统)的手里，我们不能改变它，只能学习 并 适应它。

　　简单地说一下为什么是这样：我们手机在运行 一个应用程序的时候，有可能打进来电话 发进来短信 ，或者没有电了，这时候程序都会被中断，优先去服务电话的基本功能 ，另 外系统也不允许你占用太多资源 ，至少要保证电话功能吧,所以资源不足的时候也就有可 能被干掉。

 

　　言归正传，Activity的基本生命周期如下代码 所示：

 

　　Java代码

 

　　1. public

 

　　2. class MyActivity extends Activity {

 

　　3. protected

 

　　4. void onCreate(Bundle savedInstanceState);

 

　　5.

 

　　6. protected

 

　　7. void onStart();

 

　　8.

 

　　9. protected

 

　　10. void onResume();

 

　　11.

 

　　12. protected

 

　　13. void onPause();

 

　　14.

 

　　15. protected

 

　　16. void onStop();

 

　　17.

 

　　18. protected

 

　　19. void onDestroy();

 

　　20. }

 

　　21.

 

　　22.　　public 　class MyActivity extends Activity {

 

　　protected 　　void onCreate(BundlesavedInstanceState);

 

　　protected 　　void onStart();

 

　　protected 　　void onResume();

 

　　protected 　　void onPause();

 

　　protected 　　void onStop();

 

　protected 　　void onDestroy();

 

　　}

 

　

　　你自己写的Activity会按需要 重载这些方法，onCreate是免不了的，在一个Activity正常启动的过程中，他们被调用的顺序是onCreate -> onStart -> onResume, 在Activity被干掉的时候顺序是onPause-> onStop -> onDestroy ，这样就是一个完整的生命周期，但是有人问了 ，程序正运行着呢来电话了，这个程序咋办?中止了呗，如果中止的时候新出的一个Activity是全屏的那么：onPause->onStop，恢复的时候onStart->onResume，如果打断 这个应用程序的是一个Theme为Translucent或者Dialog的Activity那么只是onPause,恢复 的时候onResume。

 

　　详细介绍一下这几个方法中系统在做什么以及我们应该做什么：

 

　　onCreate: 在这里创建界面 ，做一些数据 的初始化工作

 

　　onStart: 到这一步变成用户可见不可交互 的

 

　　onResume: 变成和用户可交互 的，(在activity 栈系统通过栈的方式管理这些个

 

　　Activity的最上面，运行完弹出栈，则回到上一个Activity)

 

　　onPause: 到这一步是可见但不可交互 的，系统会停止动画 等消耗CPU 的事情 　　从上文的描述已经知道，应该在这里保存你的一些数据,因为这个时候 　你的程序的优先级降低，有可能被系统收回。在这里保存的数据，应该在 　onResume里读出来，注意：这个方法里做的事情时间要短，因为下一 个activity不会等到这个方法完成才启动

 

　　onstop: 变得不可见 ，被下一个activity覆盖了

 

　　onDestroy: 这是activity被干掉前最后一个被调用方法了，可能是外面类调用finish方 　法或者是系统为了节省空间将它暂时性的干掉，可以用isFinishing()来判断它，如果你有一个ProgressDialog在线程中转动，请在onDestroy里 把他cancel掉，不然等线程结束的时候，调用Dialog的cancel方法会抛 异常的。

 

　　onPause，onstop， onDestroy，三种状态 下activity都有可能被系统干掉

 

　为了保证程序的正确性，你要在onPause()里写上持久层操作的代码，将用户编辑的内容都保存到存储介质上(一般都是数据库 )。实际工作中因为生命周期的变化而带来的问题也很多，比如你的应用程序起了新的线程在跑，这时候中断了，你还要去维护那个线程，是暂停还是杀掉还是数据回滚，是吧?因为Activity可能被杀掉，所以线程中使用的变量和一些界面元素就千万要注意了，一般我都是采用Android的消息机制[Handler,Message]来处理多线程和界面交互的问题。这个我后面会讲一些，最近因为这些东西头已经很大了，等我理清思绪再跟大家分享。ller改变了View，View会 从潜在的Model中获取数据来刷新自己。

 

10、让Activity变成一个窗口：Activity属性设定

 

　　讲点轻松的吧,可能有人希望做出来的应用程序是一个漂浮在手机主界面的东西，那么很 简单你只需要设置 一下Activity的主题就可以了在AndroidManifest.xml中定义Activity的地方一句话：

 

　　Xml代码

 

　　1. android:theme="@android:style/Theme.Dialog"

 

　　2.

 

　　3. android:theme="@android:style/Theme.Dialog"

 

　　android :theme="@android:style/Theme.Dialog"

 

　　android:theme="@android:style/Theme.Dialog"

 

　　这就使你的应用程序变成对话框的形式弹出来了，或者

 

　　Xml代码

 

　　1.android:theme="@android:style/Theme.Translucent"

 

　　2.

 

　　3. android:theme="@android:style/Theme.Translucent"

 

　　android:theme="@android:style/Theme.Translucent"

 

　　android:theme="@android:style/Theme.Translucent"

 

　　就变成半透明的，[友情提示-.-]类似的这种activity的属性可以在android.R.styleable类的AndroidManifestActivity方法中看到，AndroidManifest.xml中所有元素的属性的介绍都可以参考这个类android.R.styleable

 

　　上面说的是属性名称，具体有什么值是在android.R.style中 可以看到，比如这个"@android:style/Theme.Dialog"就对应于android.R.style.Theme_Dialog,('_'换成'.'< --注意：这个是文章内容不是笑脸)就可以用在描述文件 中了,找找类定义和描述文件中的对应关系就都明白了。

 

11、 你后台的Activity被系统回收怎么办：onSaveInstanceState

 

　　当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B 　这个时候A会执行

 

　　Java代码

 

　　1. public

 

　　2. void onSaveInstanceState(Bundle outState) {

 

　　3. super.onSaveInstanceState(outState);

 

　　4. outState.putLong("id", 1234567890);

 

　　5. }

 

　　public

 

　　void onSaveInstanceState(Bundle outState) {

 

　　super.onSaveInstanceState(outState);

 

　　outState.putLong("id", 1234567890);

 

　　}

 

　　B 完成以后又会来找A, 这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回 收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上参数savedInstanceState，没被收回的就还是onResume就好了。

 

　　savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。

 

　　Java代码

 

　　1. if(savedInstanceState != null){

 

　　2. long id = savedInstanceState.getLong("id");

 

　　3. }

 

　　if(savedInstanceState != null){

 

　　long id = savedInstanceState.getLong("id");

 

　　}

 

　　就像官方的Notepad教程 里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来，程序就完整一些。这也是看你的应用需不需要保存什么，比如你的界面就是读取一个列表，那就不需要特殊记住什么，哦， 没准你需要记住滚动条的位置...

 

12、 调用与被调用：我们的通信使者Intent

 

　　要说Intent了，Intent就是这个这个意图 ，应用程序间Intent进行交流，打个电话啦，来个 电话啦都会发Intent, 这个是Android架构的松耦合的精髓部分，大大提高了组件的复用性，比如你要在你的应用程序中点击按钮，给某人打电话，很简单啊，看下代码先：

 

　　Java代码

 

　　1. Intent intent = new Intent();

 

　　2. intent.setAction(Intent.ACTION_CALL);

 

　　3. intent.setData(Uri.parse("tel:" + number));

 

4.startActivity(intent);

 

　　Intent intent = new Intent();

 

　　intent.setAction(Intent.ACTION_CALL);

 

　　intent.setData(Uri.parse("tel:"+ number));

 

　　startActivity(intent);

 

　　扔出这样一个意图，系统看到了你的意图就唤醒了电话拨号程序，打出来电话。什么读联系人，发短信啊，邮件啊，统统只需要扔出intent就好了，这个部分设计 地确实很好啊。

 

　　那Intent通过什么来告诉系统需要谁来接受他呢?

 

　　通常使用Intent有两种方法，第一种是直接说明需要哪一个类来接收代码如下:

 

　　Java代码

 

　　1. Intent intent = new Intent(this, MyActivity.class);

 

　　2. intent.getExtras().putString("id","1");

 

　　3. tartActivity(intent);

 

　　Intent intent = new Intent(this, MyActivity.class);

 

　　intent.getExtras().putString("id","1");

 

　　tartActivity(intent);

 

　　第一种方式很明显，直接指定了MyActivity为接受者,并且传了一些数据给MyActivity，在MyActivity里可以用getIntent()来的到这个intent和数据。

 

　　第二种就需要先看一下AndroidMenifest中的intentfilter的配置了

 

　　Xml代码

 

　　< intent-filter>

 

　　< action

 

　　android:name="android.intent.action.VIEW"

 

　　/>

 

　　< action

 

　　android:value="android.intent.action.EDIT"

 

　　/>

 

　　< action

 

　　android:value="android.intent.action.PICK"

 

　　/>

 

　　< category

 

　　android:name="android.intent.category.DEFAULT"

 

　　/>

 

　　< data

 

　　android:mimeType="vnd.android.cursor.dir/vnd.google.note"

 

　　/>

 

　　< /intent-filter>

 

　　这里面配置用到了action, data, category这些东西，那么聪明的你一定想到intent里也会有这些东西，然后一匹配不就找到接收者了吗?

 

　　action其实就是一个意图的字符串名称。

 

　　上面这段intent-filter的配置文件说明了这个Activity可以接受不同的Action，当然相应的程序逻辑也不一样咯,提一下那个mimeType,他是在ContentProvider里定义的，你要是自己实现一个ContentProvider就知道了，必须指定

mimeType才能让数据被别人使用。

 

　　不知道原理说明白没，总结一句，就是你调用别的界面不是直接new那个界面，而是通过扔出一个intent，让系统帮你去调用那个界面，这样就多么松藕合啊，而且符合了生命周期被系统管理的原则。

 

　　想知道category都有啥，Android为你预先定制好的action都有啥等等，请亲自访问官方链接Intent

 

　　ps:想知道怎么调用系统应用程序的同学，可以仔细看一下你的logcat，每次运行一个程序的时候是不是有一些信息比如:

 

　　Starting activity: Intent {action=android.intent.action.MAINcategories={android.intent.category.LAUNCHER}flags=0x10200000comp={com.android.camera/com.android.camera.GalleryPicker} }

 

　　再对照一下Intent的一些set方法，就知道怎么调用咯，希望你喜欢：)

 

　

 

 

 

 

 

 

 

　　

 

　　13、什么是ANR 如何避免它?

 

　　答：ANR：Application Not Responding，五秒

 

在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：

 

　　对输入事件(如按键、触摸屏事件)的响应超过5秒

 

　　意向接受器(intentReceiver)超过10秒钟仍未执行完毕

 

　　Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intentbroadcast)。

 

　　因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束-- 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。

 

　　14、什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?

 

　　答：一般像空指针啊，可以看起logcat，然后对应到程序中 来解决错误

 

　　15、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决?

 

　　16、简要解释一下activity、intent 、intentfilter、service、Broadcase、BroadcaseReceiver

 

　　答：一个activity呈现了一个用户可以操作的可视化用户界面

 

　　一个service不包含可见的用户界面，而是在后台无限地运行

 

　　可以连接到一个正在运行的服务中，连接后，可以通过服务中暴露出来的借口与其进行通信

 

　　一个broadcast receiver是一个接收广播消息并作出回应的component，broadcastreceiver没有界面

 

　　intent:content provider在接收到ContentResolver的请求时被激活。

 

　　activity, service和broadcast receiver是被称为intents的异步消息激活的。

 

一个intent是一个Intent对象，它保存了消息的内容。对于activity和service来说，它指定了请求的操作名称和待操作数据的URI

 

　　Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。

 

　　它是通过将Intent对象和目标的intent filter相比较来完成这一工作的。一个component的intentfilter告诉android该component能处理的intent。intentfilter也是在manifest文件中声明的。

 

　　17、IntentService有何优点?

 

　　答：IntentService 的好处

 

　　* Acitivity的进程，当处理Intent的时候，会产生一个对应的Service

 

　　* Android的进程处理器现在会尽可能的不kill掉你

 

　　* 非常容易使用

 

　　18、横竖屏切换时候activity的生命周期?

 

　　1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次

 

　　2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次

 

　　3、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法

 

　　

 

 

 

19. 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?

 

　　解答：可以将dictionary.db文件复制到Eclipse Android工程中的resaw目录中。所有在resaw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到resaw目录中

 

　20. 如何将打开res aw目录中的数据库文件?

 

　　解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得resaw目录中资源的InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。

 

　　21. Android引入广播机制的用意?

 

　　答：a:从MVC的角度考虑(应用程序内)

 

　其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。

 

　　b：程序间互通消息(例如在自己的应用程序内监听系统来电)

 

　　c：效率上(参考UDP的广播协议在局域网的方便性)

 

d：设计模式上(反转控制的一种应用，类似监听者模式)

1. 请描述下Activity的声明周期。

 onCreate->onStart->onRemuse->onPause->onStop->onRestart->onDestroy

 

 

 

2. 如果后台的Activity由于某种原因被系统回收，如何在回收之前保存当前状态。

onSaveInstanceState().

程序中的某一个ActivityA 在运行时，主动或被动的运行另一个新的Activity B，这个时候A会执行onSaveInstanceState()。B完成以后又回来找A，这个时候有两种情况：一是A被回收，二是A没有被回收，被回收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上了参数savedInstanceState；而没被回收的就直接执行onResume()，跳过onCreate()。

 

 

 

3. 如何将一个Activity设置成窗口样式。

在AndroidManifext.xml中Activity定义处添加

android:theme="@android:style/Theme.Dialog"或

android:theme="@android:style/Theme.Translucent"。

 

 

 

 

4. 如何退出Activity？如何安全退出已调用多个Activity的Application？

1.Activity.finish();

也可以用killProcess()和System.exit()这样的方法

2.用ActivityManager的restartPackage方法

 

 

 

5. 请介绍下android大众常用的五种布局。

FrameLayout（框架布局）

只可以有一个控件，并且不能设计这个控件的位置，控件会放在左上角

LinearLayout（线性布局）

一行只能控制一个控件的线性布局，所以当有很多控件需要在一个界面中列出时，可以用LinearLayout布局

AbsoluteLayout（绝对布局）

可以放置多个控件，并且可以自己定义控件的x,y的位置

RelativeLayout（相对布局）

比如要在一行上显示多个控件，这时就要用到相对布局

TableLayout（表格布局）

将子元素的位置分配到行或列中，一个TableLayout由许多的TableRow组成

 

 

6. 请介绍下android的数据存储方式。

SharedPreferences方式

用来存储”key-valuepaires”格式的数据，它是一个轻量级的键值存储机制，只可以存储基本数据类型,可以通过它保存一些上次用户所做的修改操作

文件存储方式

它通过FileInputStream和FileOutputStream对文件进行操作。但是在Android中，文件是一个应用程序私有的，一个应用程序无法读写其他应用程序的文件，如果要共享数据就用Content Providers

SQLite数据库方式

Android提供的一个标准的数据库，支持SQL语句

内容提供器（Contentprovider）方式

是所有应用程序之间数据存储和检索的桥梁，它的作用是使得各个应用程序之间实现数据共享

网络存储方式

通过网络来存储和获取数据

 

 

7。请介绍下ContentProvider是如何实现数据共享的。

 Android提供了ContentProvider，一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProviders是以类似数据库中表的方式将数据暴露，也就是说ContentProvider就像一个“数据库”。那么外界获取其提供的数据，也就应该与从数据库中获取数据的操作基本一样，只不过是采用URI来表示外界需要访问的“数据库”。外部访问通过ContentResolver去访问并操作这些被暴露的数据。

 

 

8。如何启用Service，如何停用Service。

Intent intent = new Intent();

intent.setClass(this,cba.class);

startService(intent);

stopService(intent);

 

 

9。注册广播有几种方式，这些方式有何优缺点？Android引入广播机制的用意。

 2种方式

1.    在androidmainfest.xml中注册  

2.    <receiver>

3.        <intent-filter>

4.           <action android:name = "android.intent.action.PICK"/>

5.        </intent-filter>

6.    </receiver>

7.    缺点：常驻型，占资源比较大

8.   

9.    registerReceiver(receiver,filter);  BroadcastReceiver更新UI一般用这种方法

 

 

10. 请解释下在单线程模型中Message,Handler,Message Queue,Looper之间的关系。

 Message

   Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。

2. Handler

   Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)

方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。

Message Queue

   Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。

    每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。

4. Looper

   Looper是每条线程里的MessageQueue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。

    对于子线程使用Looper，API Doc提供了正确的使用方法：

 

11. AIDL的全程是什么？如何工作？能处理哪些类型的数据？

AIDL的英文全称是Android Interface Define Language

当A进程要去调用B进程中的service时，并实现通信，我们通常都是通过AIDL来操作的

A工程：

首先我们在net.blogjava.mobile.aidlservice包中创建一个RemoteService.aidl文件，在里面我们自定义一个接口，含有方法get。ADT插件会在gen目录下自动生成一个RemoteService.java文件，该类中含有一个名为RemoteService.stub的内部类，该内部类中含有aidl文件接口的get方法。

说明一：aidl文件的位置不固定，可以任意

然后定义自己的MyService类，在MyService类中自定义一个内部类去继承RemoteService.stub这个内部类，实现get方法。在onBind方法中返回这个内部类的对象，系统会自动将这个对象封装成IBinder对象，传递给他的调用者。

其次需要在AndroidManifest.xml文件中配置MyService类，代码如下：

<!-- 注册服务 --> 

<serviceandroid:name=".MyService">

 <intent-filter>

  <!--  指定调用AIDL服务的ID  -->

      <actionandroid:name="net.blogjava.mobile.aidlservice.RemoteService" />

   </intent-filter>

</service>

为什么要指定调用AIDL服务的ID,就是要告诉外界MyService这个类能够被别的进程访问，只要别的进程知道这个ID，正是有了这个ID,B工程才能找到A工程实现通信。

说明：AIDL并不需要权限

B工程：

     首先我们要将A工程中生成的RemoteService.java文件拷贝到B工程中，在bindService方法中绑定aidl服务

     绑定AIDL服务就是将RemoteService的ID作为intent的action参数。

     说明：如果我们单独将RemoteService.aidl文件放在一个包里，那个在我们将gen目录下的该包拷贝到B工程中。如果我们将RemoteService.aidl文件和我们的其他类存放在一起，那么我们在B工程中就要建立相应的包，以保证RmoteService.java文件的报名正确，我们不能修改RemoteService.java文件

          bindService(newInten("net.blogjava.mobile.aidlservice.RemoteService"),serviceConnection, Context.BIND_AUTO_CREATE);

      ServiceConnection的onServiceConnected(ComponentName name, IBinder service)方法中的service参数就是A工程中MyService类中继承了RemoteService.stub类的内部类的对象。

 

 Android采用RPC的方式来实现（remoteprocedure call）远程通信，并且Android通过接口定义语言AIDL来生成两个进程之间互相访问的代码。例如，你在Activity里的代码需要访问Service中的一个方法，那么就可以通过这种方法来实现了。

?      创建一个AIDL文件（参见代码）

?      实现AIDL文件生成的Java接口（参见代码）

?      将你的接口暴露给客户端

?      客户端调用

 

 

12. 请解释下Android程序运行时权限与文件系统权限的区别。

 Android程序运行  是虚拟机Dalvik( android授权)

  文件系统   是 linux 内核 授权

 

 

13. 系统上安装了多种浏览器，能否指定某浏览器访问指定页面？

 webkit

 

 

14. 有一个一维整型数组int[] data保存的是一张宽为width,高为height的图片像素值信息。请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50%。

 

 

15. 你如何评价Android系统？优缺点。

优点：开源特性，得到众多厂商支持。

软件发展很快。

界面UI，系统优化不错。

缺点：版本过多，升级过快。

用户体验不一致。

 

 

16. android中的动画有哪几类，他们的特点和区别是什么？

两种，

一种是Tween动画(补间动画)，

一种是Frame动画(逐帧动画)。

Tween动画：使试图组件移动，放大，缩小以及产生透明度的变化。

Frame动画：传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。

 

 

17. 横竖屏切换时activity的生命周期

不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。

设置Activity的android:configChanges="orientation"时，切横，竖屏时生命周期只会执行一次。

设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用声明周期，只会执行onConfigurationChanged方法。

 

进程与线程

当一个程序开始运行时，它就是一个进程，进程包含运行中的程序和程序所使用的内存和系统资源。而一个进程又是由多个线程组成的。引入线程优点是易于调度，提供开发效率，通过线程可以方便有效的实现并发，进程可创建多个线程来执行同一个程序的不同部分，开销小，创建线程比创建进程要快，所需开销很少。

 

宏就是把一系列常用的操作作为一个整体，保存起来，以后用的时候直接通过一定方式用就是了

先说宏和函数的区别：

1. 宏做的是简单的字符串替换(注意是字符串的替换,不是其他类型参数的替换),而函数的参数的传递,参数是有数据类型的,可以是各种各样的类型.

2. 宏的参数替换是不经计算而直接处理的,而函数调用是将实参的值传递给形参,既然说是值,自然是计算得来的.

3. 宏在编译之前进行,即先用宏体替换宏名,然后再编译的,而函数显然是编译之后,在执行时,才调用的.因此,宏占用的是编译的时间,而函数占用的是执行时的时间.

4. 宏的参数是不占内存空间的,因为只是做字符串的替换,而函数调用时的参数传递则是具体变量之间的信息传递,形参作为函数的局部变量,显然是占用内存的.

5. 函数的调用是需要付出一定的时空开销的,因为系统在调用函数时,要保留现场,然后转入被调用函数去执行,调用完,再返回主调函数,此时再恢复现场,这些操作,显然在宏中是没有的.

定义一个宏替代两个输入数的乘积

怎么写？

#include<stdio.h>

#define MULTIPLY(x,y) ((x)*(y))

int main()

{

 intx,y,z;

 scanf("%d%d",&x,&y);

 z=MULTIPLY(x,y);

 printf("%d",z);

 return 0;

}

 

------------------------------------------------------------------------------------------------------------------------

 

Android 面试题经典

1、 Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念

　　DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。

　　2、sim卡的EF 文件有何作用

　　sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的

　　3、嵌入式操作系统内存管理有哪几种， 各有何特性

　　页式，段式，段页，用到了MMU,虚拟空间等技术

　　4、 什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?

　　嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、军事设备、航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。

　　5、一条最长的短信息约占多少byte?

　　中文70(包括标点)，英文160，160个字节。

　　6、 android中的动画有哪几类，它们的特点和区别是什么?

　　两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。

　　7、handler机制的原理

　　andriod提供了 Handler 和 Looper 来满足线程间的通信。Handler 先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。

　　1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。

　　2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。

　　3) MessageQueue(消息队列):用来存放线程放入的消息。

　　4)线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。

　　8、说说mvc模式的原理，它在android中的运用

android的官方建议应用程序的开发采用mvc模式。何谓mvc？

 

　　mvc是model,view,controller的缩写，mvc包含三个部分：

 

　　l模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。

 

　　l视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。

 

　　l控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相关事件，交给m哦得了处理。

 

　　android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：

 

　　1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如何你对android了解的比较的多了话，就一定可以想到在android中也可以使用JavaScript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。

 

　　2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。

 

　　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。

　　9、Activity的生命周期

　　和其他手机 平台的应用 程序 一样，Android的应用程序 的生命周期是被统一掌控 的，也

　　就是说我们写的应用程序命运掌握在别人(系统)的手里，我们不能改变它，只能学习 并

　　适应它。

　　简单地说一下为什么是这样：我们手机在运行 一个应用程序的时候，有可能打进来电话

　　发进来短信 ，或者没有电了，这时候程序都会被中断，优先去服务电话的基本功能，另

　　外系统也不允许你占用太多资源 ，至少要保证电话功能吧,所以资源不足的时候也就有可

　　能被干掉。

　　言归正传，Activity的基本生命周期如下代码 所示：

　　Java代码

　　public

　　classMyActivity extends Activity {

　　protected

　　voidonCreate(Bundle savedInstanceState);

　　protected

　　voidonStart();

　　protected

　　voidonResume();

　　protected

　　voidonPause();

　　protected

　　voidonStop();

protected

　　voidonDestroy();

　　}

　　public classMyActivity extends Activity { protected void onCreate(BundlesavedInstanceState); protected void onStart(); protected void onResume();protected void onPause(); protected void onStop(); protected void onDestroy();}

　　你自己写的Activity会按需要重载这些方法，onCreate是免不了的，在一个Activity正常启动的过程中，他们被调用的顺序是 onCreate ->onStart -> onResume, 在Activity被干掉的时候顺序是onPause -> onStop -> onDestroy ，这样就是一个完整的生命周期，但是有人问了，程序正运行着呢来电话了，这个程序咋办?中止了呗，如果中止的时候新出的一个Activity是全屏的那么：onPause->onStop ，恢复的时候onStart->onResume ，如果打断这个应用程序的是一个Theme为Translucent 或者Dialog 的Activity那么只是onPause ,恢复的时候onResume 。

　　详细介绍一下这几个方法中系统在做什么以及我们应该做什么：

　　onCreate: 在这里创建界面 ，做一些数据 的初始化工作

　　onStart: 到这一步变成用户可见不可交互 的

　　onResume: 变成和用户可交互 的，(在activity 栈系统通过栈的方式管理这些个

　　Activity的最上面，运行完弹出栈，则回到上一个Activity)

　　onPause: 到这一步是可见但不可交互 的，系统会停止动画 等消耗CPU 的事情

　　从上文的描述已经知道，应该在这里保存你的一些数据,因为这个时候

　　你的程序的优先级降低，有可能被系统收回。在这里保存的数据，应该在

　　onResume里读出来，注意：这个方法里做的事情时间要短，因为下一

　　个activity不会等到这个方法完成才启动

　　onstop: 变得不可见 ，被下一个activity覆盖了

　　onDestroy: 这是activity被干掉前最后一个被调用方法了，可能是外面类调用finish方

　　法或者是系统为了节省空间将它暂时性的干掉，可以用isFinishing()来判

　　断它，如果你有一个ProgressDialog在线程中转动，请在onDestroy里

　　把他cancel掉，不然等线程结束的时候，调用Dialog的cancel方法会抛

　　异常的。

　　onPause，onstop， onDestroy，三种状态 下 activity都有可能被系统干掉

为了保证程序的正确性，你要在onPause()里写上持久层操作的代码，将用户编辑的内容都保存到存储介质上(一般都是数据库 )。实际工作中因为生命周期的变化而带来的问题也很多，比如你的应用程序起了新的线程在跑，这时候中断了，你还要去维护那个线程，是暂停还是杀掉还是数据回滚，是吧?因为Activity可能被杀掉，所以线程中使用的变量和一些界面元素就千万要注意了，一般都是采用Android的消息机制 [Handler,Message]来处理多线程和界面交互的问题。

　　10、让Activity变成一个窗口：Activity属性设定

　　讲点轻松的吧,可能有人希望做出来的应用程序是一个漂浮在手机主界面的东西，那么很

　　简单你只需要设置 一下Activity的主题就可以了在AndroidManifest.xml 中定义 Activity的

　　地方一句话：

　　Xml代码

　　android:theme=”@android:style/Theme.Dialog”

　　android:theme=”@android:style/Theme.Dialog”

　　这就使你的应用程序变成对话框的形式弹出来了，或者

　　Xml代码

　　android:theme=”@android:style/Theme.Translucent”

　　android:theme=”@android:style/Theme.Translucent”

　　就变成半透明的，[友情提示-.-]类似的这种activity的属性可以在android.R.styleable 类的AndroidManifestActivity 方法中看到，AndroidManifest.xml中所有元素的属性的介绍都可以参考这个类android.R.styleable

　　上面说的是属性名称，具体有什么值是在android.R.style中可以看到，比如这个”@android:style/Theme.Dialog”就对应于android.R.style.Theme_Dialog ,(‘_’换成’.’ < --注意：这个是文章内容不是笑脸)就可以用在描述文件 中了,找找类定义和描述文件中的对应关系就都明白了。

　　11、 你后台的Activity被系统回收怎么办：onSaveInstanceState

当你的程序中某一个ActivityA 在运行时中，主动或被动地运行另一个新的Activity B

　　这个时候A会执行

　　Java代码

　　public

　　voidonSaveInstanceState(Bundle outState) {

　　super.onSaveInstanceState(outState);

　　outState.putLong("id",1234567890);

　　}

　　B 完成以后又会来找A, 这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回

　　收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上参数

　　savedInstanceState，没被收回的就还是onResume就好了。

　　savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。

　　Java代码

　　if(savedInstanceState!= null){

　　long id =savedInstanceState.getLong("id");

　　}

　　就像官方的Notepad教程里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来，程序就完整一些。这也是看你的应用需不需要保存什么，比如你的界面就是读取一个列表，那就不需要特殊记住什么，哦，没准你需要记住滚动条的位置...

　　12、 调用与被调用：我们的通信使者Intent

　　要说Intent了，Intent就是这个这个意图 ，应用程序间Intent进行交流，打个电话啦，来个

　　电话啦都会发Intent,这个是Android架构的松耦合的精髓部分，大大提高了组件的复用性，比如你要在你的应用程序中点击按钮，给某人打电话，很简单啊，看下代码先：

　　Java代码

　 Intentintent = new Intent();

　　intent.setAction(Intent.ACTION_CALL);

　　intent.setData(Uri.parse("tel:"+ number));

　　startActivity(intent);

　　扔出这样一个意图，系统看到了你的意图就唤醒了电话拨号程序，打出来电话。什么读联系人，发短信啊，邮件啊，统统只需要扔出intent就好了，这个部分设计地确实很好啊。

　　那Intent通过什么来告诉系统需要谁来接受他呢?

　　通常使用Intent有两种方法，第一种是直接说明需要哪一个类来接收代码如下:

　　Java代码

　　Intentintent = new Intent(this, MyActivity.class);

　　intent.getExtras().putString("id","1");

　　tartActivity(intent);

　　第一种方式很明显，直接指定了MyActivity为接受者,并且传了一些数据给MyActivity，在MyActivity里可以用getIntent()来的到这个intent和数据。

　　第二种就需要先看一下AndroidMenifest中的intentfilter的配置了

　　Xml代码

　　<intent-filter>

　　< action

　　android:name="android.intent.action.VIEW"

　　/>

　　< action

　　android:value="android.intent.action.EDIT"

　　/>

　　< action

　　android:value="android.intent.action.PICK"

　　/>

　　<category

　　android:name="android.intent.category.DEFAULT"

　　/>

　　< data

　　android:mimeType="vnd.android.cursor.dir/vnd.google.note"

　　/>

　　</intent-filter>

　　这里面配置用到了action,data, category这些东西，那么聪明的你一定想到intent里也会有这些东西，然后一匹配不就找到接收者了吗?

　　action其实就是一个意图的字符串名称。

　　上面这段intent-filter的配置文件说明了这个Activity可以接受不同的Action，当然相应的程序逻辑也不一样咯,提一下那个 mimeType,他是在ContentProvider里定义的，你要是自己实现一个ContentProvider就知道了，必须指定 mimeType才能让数据被别人使用。

　　不知道原理说明白没，总结一句，就是你调用别的界面不是直接new那个界面，而是通过扔出一个intent，让系统帮你去调用那个界面，这样就多么松藕合啊，而且符合了生命周期被系统管理的原则。

　　想知道category都有啥，Android为你预先定制好的action都有啥等等，请亲自访问官方链接Intent

　　ps:想知道怎么调用系统应用程序的同学，可以仔细看一下你的logcat，每次运行一个程序的时候是不是有一些信息比如:

　　Startingactivity: Intent { action=android.intent.action.MAINcategories={android.intent.category.LAUNCHER}flags=0x10200000comp={com.android.camera/com.android.camera.GalleryPicker} }

　　再对照一下Intent的一些set方法，就知道怎么调用咯，希望你喜欢：)

　　13. 如何退出Activity?如何安全退出已调用多个Activity的Application?

对于单一Activity的应用来说，退出很简单，直接finish()即可。

当然，也可以用killProcess()和System.exit()这样的方法。

 

但是，对于多Activity的应用来说，在打开多个Activity后，如果想在最后打开的Activity直接退出，上边的方法都是没有用的，因为上边的方法都是结束一个Activity而已。

当然，网上也有人说可以。

就好像有人问，在应用里如何捕获Home键，有人就会说用keyCode比较KEYCODE_HOME即可，而事实上如果不修改framework，根本不可能做到这一点一样。

所以，最好还是自己亲自试一下。

 

那么，有没有办法直接退出整个应用呢？

在2.1之前，可以使用ActivityManager的restartPackage方法。

它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。

注意不要被它的名字迷惑。

 

可是，在2.2，这个方法失效了。

在2.2添加了一个新的方法，killBackgroundProcesses()，需要权限android.permission.KILL_BACKGROUND_PROCESSES。

可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。

 

另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。

它需要权限android.permission.FORCE_STOP_PACKAGES。

并且需要添加android:sharedUserId=”android.uid.system”属性

同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。

因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。

而Android.mk是用于在Android源码下编译程序用的。

 

从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。

 

现提供几个方法，供参考：

 

1、抛异常强制退出：

该方法通过抛异常，使程序ForceClose。

验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。

 

2、记录打开的Activity：

每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。

 

3、发送特定广播：

在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。

 

4、递归退出

在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。

 

除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。

但是这样做同样不完美。

你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。

但至少，我们的目的达到了，而且没有影响用户使用。

 

为了编程方便，最好定义一个Activity基类，处理这些共通问题。

摘自：http://blog.csdn.net/debug2/archive/2011/02/18/6193644.aspx

　　14. 请介绍下Android中常用的五种布局。

1、 LinearLayout C 线性布局。

orientation C容器内元素的排列方式。vertical: 子元素们垂直排列；horizontal: 子元素们水平排列

gravity C内容的排列形式。常用的有 top, bottom, left,right, center 等

 

2、 AbsoluteLayout C 绝对布局。

layout_x C x 坐标。以左上角为顶点

layout_y C y 坐标。以左上角为顶点

 

3、 TableLayout C 表格式布局

表格布局主要以行列的形式来管理子控件，其中每一行即一个TableRow对象，每个TableRow对象可以添加子控件，并且每加入一个空间即相当于添加了一列

 

4、 RelativeLayout C 相对布局。

layout_centerInParent C 将当前元素放置到其容器内的水平方向和垂直方向的中央位置（类似的属性有：layout_centerHorizontal, layout_alignParentLeft 等）

layout_marginLeft C 设置当前元素相对于其容器的左侧边缘的距离

layout_below C放置当前元素到指定的元素的下面

layout_alignRight C 当前元素与指定的元素右对齐

 

5、 FrameLayout C 层叠布局。以左上角为起点，将 FrameLayout 内的元素一层覆盖一层地显示，在帧布局中，先添加的图片会被后添加的图片覆盖。

摘自：http://javalover00000.javaeye.com/blog/851266

　　15. 请介绍下Android的数据存储方式。

Android提供了5种方式存储数据：

1、使用SharedPreferences存储数据；

2、文件存储数据；

3、SQLite数据库存储数据；

4、使用ContentProvider存储数据；

5、网络存储数据；

Android 中的数据存储都是私有的，其他应用程序都是无法访问的，除非通过ContentResolver获取其他程序共享的数据。

摘自：http://www.moandroid.com/?p=319

　　16. 请介绍下ContentProvider是如何实现数据共享的。

一个程序可以通过实现一个Contentprovider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Contentprovider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。

 

如何通过一套标准及统一的接口获取其他应用程序暴露的数据？Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。

参考：http://www.moandroid.com/?p=319

　　17. 如何启用Service，如何停用Service。

1．第一种是通过调用Context.startService()启动，调用Context.stopService()结束，startService()可以传递参数给Service

 

2．第二种方式是通过调用Context.bindService()启动，调用Context.unbindservice()结束，还可以通过ServiceConnection访问Service。

在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次。

参考：http://www.cnblogs.com/feisky/archive/2010/06/14/1758336.html

　　18. 注册广播有几种方式，这些方式有何优缺点?请谈谈Android引入广播机制的用意。

android中，不同进程之间传递信息要用到广播，可以有两种方式来实现。

第一种方式：在Manifest.xml中注册广播，是一种比较推荐的方法，因为它不需要手动注销广播（如果广播未注销，程序退出时可能会出错）。

具体实现在Manifest的application中添加：

 

<receiverandroid:name=".mEvtReceiver">

   <intent-filter>

   <action android:name="android.intent.action.BOOT_COMPLETED"/>

   </intent-filter>

</receiver>

 

上面两个android:name分别是广播名和广播的动作（这里的动作是表示系统启动完成），如果要自己发送一个广播，在代码中为：

Intent i = newIntent(“android.intent.action.BOOT_COMPLETED”);

sendBroadcast(i);

这样，广播就发出去了，然后是接收。

接收可以新建一个类，继承至BroadcastReceiver，也可以建一个BroadcastReceiver的实例，然后得写onReceive方法，实现如下：

protected BroadcastReceiver mEvtReceiver =new BroadcastReceiver() {

@Override

public void onReceive(Context context,Intent intent) {

String action = intent.getAction();

if(action.equals(“android.intent.action.BOOT_COMPLETED”)) {

//Do something

}

}

};

 

第二种方式，直接在代码中实现，但需要手动注册注销，实现如下：

IntentFilter filter = new IntentFilter();

filter.addAction(“android.intent.action.BOOT_COMPLETED”);

registerReceiver(mEvtReceiver, filter); //这时注册了一个recevier ,名为mEvtReceiver，然后同样用上面的方法以重写onReceiver，

最后在程序的onDestroy中要注销广播，实现如下：

@Override

public void onDestroy() {

super.onDestroy();

unregisterReceiver(mPlayerEvtReceiver);

}

Android系统中的广播是广泛用于应用程序之间通信的一种手段，它类似于事件处理机制，不同的地方就是广播的处理是系统级别的事件处理过程（一般事件处理是控件级别的）。在此过程中仍然是离不开Intent对象，理解广播事件的处理过程，灵活运用广播处理机制，在关键之处往往能实现特别的效果，

在Android 中如果要发送一个广播必须使用sendBroadCast 向系统发送对其感兴趣的广播接收器中。

使用广播必须要有一个intent对象必设置其action动作对象

使用广播必须在配置文件中显式的指明该广播对象

每次接收广播都会重新生成一个接收广播的对象

在BroadCast 中尽量不要处理太多逻辑问题，建议复杂的逻辑交给Activity 或者 Service 去处理

转自：http://www.dengdeng.name/u/deng/archives/2010/92.html

 

http://www.cnblogs.com/TerryBlog/archive/2010/08/16/1801016.html

 

　　19. 请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。

简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理

参见：http://hi.baidu.com/???????/blog/item/4e576b7c58d742360cd7dac9.html

 

http://blog.csdn.Net/xuxinyl/archive/2010/12/25/6097560.aspx

 

　　20. AIDL的全称是什么?如何工作?能处理哪些类型的数据?

AIDL全称Android Interface Definition Language（AndRoid接口描述语言）是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程跨界对象访问的目的.AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.理论上, 参数可以传递基本数据类型和String, 还有就是Bundle的派生类, 不过在Eclipse中,目前的ADT不支持Bundle做为参数,

具体实现步骤如下:

 

1、创建AIDL文件, 在这个文件里面定义接口, 该接口定义了可供客户端访问的方法和属性。

 

2、编译AIDL文件, 用Ant的话, 可能需要手动, 使用Eclipse plugin的话,可以根据adil文件自动生产java文件并编译, 不需要人为介入.

 

3、在Java文件中, 实现AIDL中定义的接口. 编译器会根据AIDL接口, 产生一个JAVA接口。这个接口有一个名为Stub的内部抽象类，它继承扩展了接口并实现了远程调用需要的几个方法。接下来就需要自己去实现自定义的几个接口了.

4、向客户端提供接口ITaskBinder, 如果写的是service，扩展该Service并重载onBind ()方法来返回一个实现上述接口的类的实例。

5、在服务器端回调客户端的函数. 前提是当客户端获取的IBinder接口的时候,要去注册回调函数, 只有这样, 服务器端才知道该调用那些函数

 

AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:

 

1. 不需要import声明的简单Java编程语言类型(int,boolean等)

 

2. String, CharSequence不需要特殊声明

 

3. List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.

 

(另外: 我没尝试Parcelables,在Eclipse+ADT下编译不过, 或许以后会有所支持).

 

实现接口时有几个原则:

 

.抛出的异常不要返回给调用者. 跨进程抛异常处理是不可取的.

 

.IPC调用是同步的。如果你知道一个IPC服务需要超过几毫秒的时间才能完成地话，你应该避免在Activity的主线程中调用。也就是IPC调用会挂起应用程序导致界面失去响应. 这种情况应该考虑单起一个线程来处理.

 

.不能在AIDL接口中声明静态属性。

 

IPC的调用步骤:

 

1. 声明一个接口类型的变量，该接口类型在.aidl文件中定义。

 

2. 实现ServiceConnection。

 

3. 调用ApplicationContext.bindService(),并在ServiceConnection实现中进行传递.

 

4. 在ServiceConnection.onServiceConnected()实现中，你会接收一个IBinder实例(被调用的Service). 调用

 

YourInterfaceName.Stub.asInterface((IBinder)service)将参数转换为YourInterface类型。

 

5. 调用接口中定义的方法。你总要检测到DeadObjectException异常，该异常在连接断开时被抛出。它只会被远程方法抛出。

 

6. 断开连接，调用接口实例中的ApplicationContext.unbindService()

参考：http://buaadallas.blog.51cto.com/399160/372090

　　21. 请解释下Android程序运行时权限与文件系统权限的区别。

apk程序是运行在虚拟机上的,对应的是Android独特的权限机制，只有体现到文件系统上时才使用linux的权限设置。

android系统有的权限是基于签名的。

具体参见：http://blog.csdn.net/Zengyangtech/archive/2010/07/20/5749999.aspx

　　22. 系统上安装了多种浏览器，能否指定某浏览器访问指定页面?请说明原由。

通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性

　　23. 有一个一维整型数组int[]data保存的是一张宽为width，高为height的图片像素值信息。请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50%。

　　24、什么是ANR 如何避免它?

　　答：ANR：Application Not Responding，五秒在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：

　　对输入事件(如按键、触摸屏事件)的响应超过5秒

　　意向接受器(intentReceiver)超过10秒钟仍未执行完毕

　　Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intentbroadcast)。

　　因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和 onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成 (或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束 ― 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。

　　25、什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?

　　答：一般像空指针啊，可以看起logcat，然后对应到程序中 来解决错误

　　26、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决?

　　27、简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver

　　答：一个activity呈现了一个用户可以操作的可视化用户界面

　　一个service不包含可见的用户界面，而是在后台无限地运行

　　可以连接到一个正在运行的服务中，连接后，可以通过服务中暴露出来的借口与其进行通信

　　一个broadcastreceiver是一个接收广播消息并作出回应的component，broadcast receiver没有界面

　　intent:contentprovider在接收到ContentResolver的请求时被激活。

　　activity,service和broadcastreceiver是被称为intents的异步消息激活的。

一个intent是一个Intent对象，它保存了消息的内容。对于activity和service来说，它指定了请求的操作名称和待操作数据的URI

　　Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于 manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。

　　它是通过将Intent对象和目标的intent filter相比较来完成这一工作的。一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。

　　28、IntentService有何优点?

　　答：IntentService的好处

　　* Acitivity的进程，当处理Intent的时候，会产生一个对应的Service

　　* Android的进程处理器现在会尽可能的不kill掉你

　　* 非常容易使用

　　29、横竖屏切换时候activity的生命周期?

　　1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次

　　2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次

　　3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法

　　30. 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?

　　解答：可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中

　　31. 如何将打开res aw目录中的数据库文件?

　　解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。

　　32. Android引入广播机制的用意?

　　答：a:从MVC的角度考虑(应用程序内)

　其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。

　　b：程序间互通消息(例如在自己的应用程序内监听系统来电)

　　c：效率上(参考UDP的广播协议在局域网的方便性)

　　d：设计模式上(反转控制的一种应用，类似监听者模式)

转自：http://www.cnmsdn.com/html/201101/1295431222ID9251.html

33、android 的优势与不足

Android平台手机 5大优势：

一、开放性

在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟

开发性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。

二、挣脱运营商的束缚

 

在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？

互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。

三、丰富的硬件选择

这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？

四、不受任何限制的开发商

Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。

五、无缝结合的Google应用

如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。

再说Android的5大不足：

一、安全和隐私

由于手机与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。

二、首先开卖Android手机的不是最大运营商

众所周知，T-Mobile在23日，于美国纽约发布了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！

三、运营商仍然能够影响到Android手机

在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。

四、同类机型用户减少

在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。

五、过分依赖开发商缺少标准配置

在 使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐播放器，全部依赖第三方开发，缺少了产品的统一性。

34、android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。

XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。

详细情况请参考http://blog.csdn.net/Android_Tutor/archive/2010/09/17/5890835.aspx

 

http://www.linuxidc.com/Linux/2010-11/29768.htm

 

http://littlefermat.blog.163.com/blog/static/59771167200981853037951/

 

35、DDMS和TraceView的区别?

DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器

36、Activity被回收了怎么办？

只有另启用了

37、java中如何引用本地语言

可以用JNI接口

38、谈谈Android的IPC机制

IPC是内部进程通信的简称，是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。

39、NDK是什么

NDK是一些列工具的集合，

NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。

NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so

40 描述一下android的系统架构

android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层

linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。

 

　　libraries和 androidruntime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit，该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。android的runtime负责解释和执行生成的dalvik格式的字节码。

 

　　applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。

 

　　applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。

 

　　上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。

 

　　android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。

 

 

 

 

----------------------------------------------------------------------------------------------------------------

 

 

一些常见的Android面试基础题做下总结，看看你能做出多少道?

 

 

 

1. Intent的几种有关Activity启动的方式有哪些，你了解每个含义吗?

 

 

 

--------------------------------------------------------------------------------

 

 

    这里Android123提示大家，Intent的一些标记有FLAG_ACTIVITY_BROUGHT_TO_FRONT、FLAG_ACTIVITY_CLEAR_TOP、FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET、FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS、FLAG_ACTIVITY_MULTIPLE_TASK和FLAG_ACTIVITY_NEW_TASK 等。每种含义大家看SDK文档和具体跑下这样你的记忆会更深刻些。

 

  2.Activity和Task的启动模式有哪些? 每种含义是什么?

 

 

--------------------------------------------------------------------------------

 

   有关在AndroidManifest.xml中的android:launchMode定义，主要有standard、singleTop、singleTask和singleInstance，同时对于android:taskAffinity这些问题大家也要了解，Android开发网在以前的文章中讲过，不过很多开发者仍然不是很清楚，这些基础问题我们以后仍然会再次总结。

 

   关于Activity的启动模式，参考：http://blog.csdn.net/feng88724/archive/2011/05/11/6412638.aspx

 

  3. 通过Intent传递一些二进制数据的方法有哪些?

 

 

--------------------------------------------------------------------------------

 

  1). 使用Serializable接口实现序列化，这是Java常用的方法。

 

  2). 实现Parcelable接口，这里Android的部分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见的。

 

  4. 能说下Android应用的入口点吗?

 

 

--------------------------------------------------------------------------------

 

  真正的Android入口点是application的main，你可以看下androidmanifest.xml的包含关系就清楚了。 可以没有Activity但是必须有Application

 

5. Android都有哪些XML解析器，都熟练掌握吗?

 

 

--------------------------------------------------------------------------------

 

  这里XmlPull、SAX和DOM相信做过Web开发的都已经滚瓜烂熟了。

 

  6.SQLite支持事务吗? 添加删除如何提高性能?

 

 

--------------------------------------------------------------------------------

 

 SQLite作为轻量级的数据库，比MySQL还小，但支持SQL语句查询，提高性能可以考虑通过原始经过优化的SQL查询语句方式处理。

 

  7.Android Service和Binder、AIDL你都熟练吗?

 

 

--------------------------------------------------------------------------------

 

  作为Android重要的后台服务，这些每个Android开发者都应该掌握，这也算是和Java SE最大的不同了，具体的实例大家可以查看Android音乐播放器的源代码Music.Git中的，这里不再赘述。

 

8. 你用过哪款Android手机，有哪些优点和不足，相对于iPhone或Symbian又有哪些优缺点?

 

 

--------------------------------------------------------------------------------

 

   把这个作为面试题也是考察下，可以大概了解到它对Android的了解程度，多移动开发的认识。

 

【2011-5-12 补充】

 

 

 

--------------------------------------------------------------------------------

 

 

1.   请描述下Activity的生命周期。

 

 

 

 

创建 oncreate-  启动onstart C 恢复 onResume C 暂停 onPause C 结束 onEnd C 销毁onDestroy

 

 

 

 

2.   如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？

 

 

 

 

在”暂停 onPause” 状态将数据保存。

 

 

 

3.   如何将一个Activity设置成窗口的样式。

 

 

 

 

设置Theme。

 

 

 

 

4.   如何退出Activity？如何安全退出已调用多个Activity的Application？

 

 

 

 

5.   请介绍下Android中常用的五种布局。

 

 

 

 

线性布局LinearLayout， 相对布局 RelativeLayout

 

 

表单布局TableLayout，

绝对布局AbsLayout（已淘汰）

 

 

帧布局FrameLayout

 

 

 

 

6.   请介绍下Android的数据存储方式。

 

 

 

 

Preference,文件,数据库SQlite,网络存储

 

 

 

 

7.   请介绍下ContentProvider是如何实现数据共享的。

 

 

 

 

 

8.   如何启用Service，如何停用Service。

 

 

 

 

启动：

Context.startService()

and

Context.bindService().

 

 

关闭：Context.stopService().

 

          Service.stopSelf()

or

Service.stopSelfResult()

 

 

 

 

9.   注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。

 

 

 

10.   请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。

 

 

 

11.   AIDL的全称是什么？如何工作？能处理哪些类型的数据？

 

 

 

12.   请解释下Android程序运行时权限与文件系统权限的区别。(Edited by Sodino)

 

 

 

13.   系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。

 

 

 

14.   有一个一维整型数组int[]data保存的是一张宽为width，高为height的图片像素值信息。请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50%。

 

 

 

15.   你如何评价Android系统？优缺点。 (这一题重复了)

 

 

 

 

优势：

一、开放性 三、丰富的硬件选择五、无缝结合的Google应用支持

 

缺点：  一、安全和隐私

二，开发商自定义，不够统一 四、同类机型用户减少

 

【2011-5-12 补充】

 

 

 

--------------------------------------------------------------------------------

 

 

1、什么是ANR 如何避免它？

 

 

 

http://blog.csdn.net/Zengyangtech/archive/2010/11/21/6025671.aspx

 

 

 

2、什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？

 

 

 

 

3、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？

 

 

 

 

会有运行时异常， 运行时异常无需捕捉

 

4、简要解释一下activity、 intent 、intent filter、service、Broadcast、BroadcaseReceiver

 

 

 

      这个问题问的很普遍，自己多看看吧。在此不多说了！

 

 

5、IntentService有何优点?

 

 

 

【2011-5-12 补充】

 

 

 

--------------------------------------------------------------------------------

 

 

1. android:paddingLeft与android:layout_marginLeft的区别

 

当按钮分别设置以上两个属性时，得到的效果是不一样的。

android:paddingLeft="30px"

按钮上设置的内容（例如图片）离按钮左边边界30个像素

android:layout_marginLeft="30px"

整个按钮离左边设置的内容30个像素

 

 

 

 

2. Android 动画有哪几种？描述一下

 

 

两种。 Tween动画和Frame动画。 Tween动画主要是透明度、尺寸伸缩、旋转、位移等效果。

 

 

 

Frame动画可以理解成gif， 一帧一帧的显示图片。比较常用的有滚动条效果。

 

 

 

 

3. 对Intent、Activity、广播、Service等的理解。

 

 

 

4. 哪些情况下会发生ANR ? 怎么对应 ？ (这个问题也重复了)

 

  Application Not Response。

 

 

 

 

5. 隐式、显式Intent的区别

 

・   显式意图

 

通过名字指明目标组件（这个组件名字字段component name field,

前面提到过,

有一个数值集）。既然组件名称通常不为其他应用程序的开发者所了解，显式意图典型的被用作应用程序的内部消息-例如一个活动启动一个附属服务或姊妹活动。

 

 

   隐式意图

 

不命名目标组件（组件名称字段为空）。隐式意图经常用来激活其他应用程序的组件。

 

    这一块参考Intent说明，可以同时看一下Notepad的例子， 帮助理解，个人感觉很重要！

 

(上面几个问题感觉都不错，各位自己查漏补缺吧！有些还没有写答案的， 各位有空可以回答一下~ 我会将你的答案填充上去)

 

 

 

-------------------------------------------------------------------

 

2011-07-05 补充

 

 

 

返回键与Home键区别？

 

 

 

back键默认行为是finish处于前台的Activity的即Activity的状态为Destroy状态为止，再次启动该Activity是从onCreate开始的(不会调用onSaveInstanceState方法)。Home键默认是stop前台的Activity即状态为onStop为止而不是Destroy,若再次启动它，会调用onSaveInstanceState方法，保持上次Activity的状态则是从OnRestart开始的---->onStart()--->onResume()。

 

 

1、Android操作系统是Google在什么时间公布的

A、2007年11月5日   B、2010年5月20日晚10点30分   C、2009年11月10日

正确答案：A

2、Android基于什么平台的开源智能手机操作系统名称

A、WinCE    B、Linux   C、SHP  

正确答案：B

3、Linux平台由以下下哪些组成？

A、操作系统  B、中间件   C、用户界面   D、应用软件

正确答案：ABCD

4、Android操作系统主要的特点是：（         ）

A、与Google无缝结合        B、实现个性化应用   

C、良好的平台开放性         D、软件均要收费

正确答案：ABC

5、Android操作系统向开发人员提供是

A、全部免费    B、部分收费     C、只有10%左右是收费的

正确答案：A

6、Android个性化界面设置的添加方式

A、点选屏幕下方添加键进行添加   B、长按屏幕空白处进行添加  C、直接拖拽至屏幕进行添加

正确答案：ABC

7、个性化界面设置不同内容包括：

A、快捷方式   B、小插件   C、窗口小部件      D、文件夹

正确答案：ABCD

8、Android操作系统采用全新解锁方式描述正确的是：（　　　　）

Ａ、自定义图型解锁；　Ｂ、滑动解锁；　Ｃ、规定图型解锁；　Ｄ、只可侧键解锁；

正确答案：AB

9、Android支持谷歌全方位移动服务，丰富最新网络体验包括：

Ａ、电子市场；  　 Ｂ、GoogleTalk；    Ｃ、Google搜索； 　

Ｄ、G-mail邮箱；  E、Google地图

正确答案：ABCDE

10、截止2010年12月，中国上市的Andriod操作系统已经发布了以下哪几个版本

A、1.0      B、1.3     C、1.5      D、1.6      E 、2.0   F、2.1   G、2.2

正确答案：ACDEFG

11、在中国，以下哪些属于Android软件主要下载门户？（       ）

A、安卓网    B、机锋网     C、百度      D、Google    E、优亿市场

正确答案：ABE

12、Android安装软件后缀是：（       ）

A．.sis         B．cab          C．.apk         D．.jar

正确答案：C

13、以下哪些不是Android操作系统的版本：（      ）

A、1.0     B、1.3     C、 2.0      D、2.1      E 、2.2

正确答案：B

14、Android操作平台的开放性也针对了众多手机品版的厂家进行了完全的开放，以下有哪几个品牌的手机从未使用过Android操作系统：（       ）

A．HTC     B．I phone       C．samsung         D．诺基亚        E．黑莓

正确答案：BDE

15、Android1.5操作系统叫（         ）

A．纸杯蛋糕    B．甜甜圈     C．法式奶油夹心甜点    D．果馅饼    E．冻酸奶

正确答案：A

16、Android1.6操作系统叫（         ）

A．纸杯蛋糕    B．甜甜圈     C．法式奶油夹心甜点    D．果馅饼    E．冻酸奶

正确答案：B

17、Android2.0操作系统叫（         ）

A．纸杯蛋糕    B．甜甜圈     C．法式奶油夹心甜点    D．果馅饼    E．冻酸奶

正确答案：C

18、Android2.1操作系统叫（         ）

A．纸杯蛋糕    B．甜甜圈     C．法式奶油夹心甜点    D．果馅饼    E．冻酸奶

正确答案：D

19、Android2.2操作系统叫（         ）

A．纸杯蛋糕    B．甜甜圈     C．法式奶油夹心甜点    D．果馅饼    E．冻酸奶

正确答案：E

20、Android2.2操作系统与Android2.1操作系统对比有哪些方面的提升（         ）

A．整体性能大幅度的提升    B．3G网络共享功能     C．全面的Flash支持

D．App 2 sd功能(安装程序到SD卡）     E．全新的软件商店

F．更好的网络体验

正确答案：ABCDEF

21、Android系统可以同时运行多个程序吗？（         ）

A．可以； B．不可以

正确答案：A

22、以下对Android操作系统描述正确的是：（        ）

A．系统资源占用少，系统运行速度快

B．完全开放性的操作系统，对所有软件开发商、手机厂商、运营商平等享有

C．有众多的软件提供给消费者下载

D．个性化的操作界面，操作简单

正确答案：ABCD

23、Android操作系统的手机可以有以下几个方法进行软件安装（       ）

A．通过手机直接登陆百度网站下载安装；

B．通过手机直接登陆Android门户网站进行下载安装；

C．通过数据线与电脑连接直接下载安装；

D．通过PC终端上网下载至SD卡里再插入手机进行安装；

正确答案：ABCD

24、Android操作系统具有个性化操作界面设置，以下关于进行添加描述正确的是（       ）

A．点选屏幕下方添加键进行添加      B．长按屏幕空白处进行添加

C．直接拖拽至屏幕进行添加          D．不可直接拖拽至屏幕进行添加

正确答案：ABC

26、Android从哪个版本开始支持动态壁纸（       ）

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：D

27、Android从哪个版本开始支持3D动态相册（       ）

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：D

28、Android从哪个版本开始系统自带支持mobileAP热点（        ）

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：E

29、Android从哪个版本开始支持Flash10.1（       ）

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：E

 

30、Android从哪个版本开始系统自带支持AllShare协议（        ）

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：E

31、Android从哪个版本开始可以提供多个不同账户统一收件箱

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：C

32、Android从哪个版本开始浏览器支持双击缩放

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：C

33、Android从哪个版本开始强化了语音识别的搜索功能

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：C

34、Android从哪个版本开始加入微软Exchange服务支持

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：C

35、Android从哪个版本开始支持双击上传图片至YouTube

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：C

36、Android从哪个版本开始支持谷歌地图服务更新

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：C

37、Android从哪个版本开始支持所有文本输入区应用语音识别

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：D

38、Android从哪个版本开始支持3D相片集

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：D

39、Android从哪个版本开始支持修复FM收音机

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：D

40、以下哪些是Android的优势（       ）

A、开源的操作系统，代码完全开放，开放成本最低

B、 便捷的用户体验界面，操作简单

C、 平台技术先进，更好的支持互联网业务

D、系统资源占用少，系统速度快

正确答案：ABCD

41、Android从哪个版本开始软件可安装到存储卡上

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：E

42、Android从哪个版本开始自动更新设备上已经安装的应用程序

A．1.0      B．1.3     C． 2.0      D．2.1      E ．2.2

正确答案：E

 

43、Android能实现手机的主屏幕的自定义，并将常用的各种应用以图标的形式添加至主屏幕界面

A、对

B、错

正确答案：A

44、Android能实现手机的主屏幕的自定义，但是添加的图标要按照功能属性排列

A、对

B、错

正确答案：B

45、Android操作系统的主屏界面图标设置一次后，就不能更改

A、对

B、错

正确答案：B

 

46、、Android操作系统可以将哪些类型不同内容，随意添加至主屏幕

A、快捷键

B、窗口小部件

C、文件夹

D、壁纸

正确答案：ABCD


========================================================================

 android面试题-简答题（一）
 
 


 
登录 | 注册







































































































 

关闭


       




busjb的专栏









目录视图
 摘要视图
 订阅
 . 




赠书 | AI专栏（AI圣经！《深度学习》中文版）      机器学习&数据挖掘 系统实训      【获奖公布】征文 | 你会为 AI 转型么？ 
  

  android面试题-简答题（一）    .


标签： android面试跳槽涨薪android面试题  

2014-02-11 22:42 14025人阅读 评论(3) 收藏 举报 
.  

 分类： 

andorid、移动开发、Android结构（26）   


 .

版权声明：本文为博主原创文章，未经博主允许不得转载。



目录(?)[+]



































1、在多线程编程这块，我们经常要使用Handler，Thread和Runnable这三个类，那么他们之间的关系你是否弄清楚了呢?

答：Android的CPU分配的最小单元是线程，Handler一般是在某个线程里创建的，因而Handler和Thread就是相互绑定的，一一对应。而Runnable是一个接口，Thread是Runnable的子类。所以说，他俩都算一个进程。HandlerThread顾名思义就是可以处理消息循环的线程，他是一个拥有Looper的线程，可以处理消息循环。与其说Handler和一个线程绑定，不如说Handler是和Looper一一对应的。最后需要说明的是，在UI线程(主线程)中：   mHandler=new Handler();　

mHandler.post(new Runnable(){

　　void run(){

　　//执行代码...}

　　});

　　这个线程其实是在UI线程之内运行的，并没有新建线程。

　　常见的新建线程的方法是：

　　Thread thread = new Thread();

　　thread.start();

　　HandlerThread thread = newHandlerThread("string");

　　thread.start();

2、如何设定应用程序为系统级别的应用？

答：apk 获取system权限；如何获取如下：

解释连接：http://blog.csdn.net/superkris/article/details/7709504

 第一个方法简单点，不过需要在android系统源码的环境下用make来编译：

       1. 在应用程序的AndroidManifest.xml中的manifest节点中加入android:sharedUserId="android.uid.system"这个属性。

       2. 修改Android.mk文件，加入LOCAL_CERTIFICATE := platform这一行

       3. 使用mm命令来编译，生成的apk就有修改系统时间的权限了。

       第二个方法是直接把eclipse编出来的apk用系统的签名文件签名

       1. 加入android:sharedUserId="android.uid.system"这个属性。

       2. 使用eclipse编译出apk文件。

       3. 使用目标系统的platform密钥来重新给apk文件签名。首先找到密钥文件，在我ndroid源码目录中的位置是"build/target/product/security"，下面的platform.pk8和platform.x509.pem两个文件。然后用Android提供的Signapk工具来签名，signapk的源代码是在"build/tools/signapk"下，编译后在out/host/Linux-x86/framework下，用法为Java -jarsignapk.jar  platform.x509.pem platform.pk8 input.apk output.apk"。

       加入android:sharedUserId="android.uid.system"这个属性。通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中。那么把程序的UID配成android.uid.system，也就是要让程序运行在系统进程中，这样就有权限来修改系统时间了。

       只是加入UID还不够，如果这时候安装APK的话发现无法安装，提示签名不符，原因是程序想要运行在系统进程中还要有目标系统的platform key，就是上面第二个方法提到的platform.pk8和platform.x509.pem两个文件。用这两个key签名后apk才真正可以放入系统进程中。第一个方法中加入LOCAL_CERTIFICATE :=platform其实就是用这两个key来签名。

       这也有一个问题，就是这样生成的程序只有在原始的Android系统或者是自己编译的系统中才可以用，因为这样的系统才可以拿到platform.pk8和platform.x509.pem两个文件。要是别家公司做的Android上连安装都安装不了。试试原始的Android中的key来签名，程序在模拟器上运行OK，不过放到G3上安装直接提示"Package... has no signatures that match those in shared user android.uid.system"，这样也是保护了系统的安全。

3、谈谈Android的IPC（进程间通信）机制

答：http://blog.csdn.NET/luoshengyang/article/details/6618363

Android系统中，每一个应用程序都是由一些Activity和Service组成的，这些Activity和Service有可能运行在同一个进程中，也有可能运行在不同的进程中，android的IPC机制也就是Binder机制，Android系统是基于linux内核的，而Linux内核继承和兼容了丰富的Unix系统进程间通信（IPC）机制， 但是，Android系统没有采用上述提到的各种进程间通信机制，而是采用Binder机制，Binder是一种进程间通信机制，它是一种类似于COM和CORBA分布式组件架构，通俗一点，其实是提供远程过程调用（RPC）功能。从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动程序了，Service Manager提供了辅助管理的功能，Client和Server正是在Binder驱动和ServiceManager提供的基础设施上，进行Client-Server之间的通信；


 

    1. Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中

  2. Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server

   3.Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信

  4. Client和Server之间的进程间通信通过Binder驱动程序间接实现

   5. Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力

4、apk安装卸载的原理

答：http://blog.csdn.net/lizhiguo0532/article/details/7077432

      http://www.itivy.com/android/archive/2011/8/10/android-apk-setup-method-and-principles.html

APK安装可以通过以下四种方式：
1. 系统应用安装，开机时完成系统应用的检查，没安装就安装，安装就跳过，无安装界面。
2. 网络下载应用安装，通过market应用完成，无安装界面。
3. ADB工具安装，无安装界面
4. 通过SD卡来安装apk，有安装界面，由packageinstaller.apk应用处理安装及卸载过程的界面。

应用安装涉及到如下几个目录：
system/app     系统自带的应用程序，无法删除
data/app     用户程序安装的目录，有删除权限
data/data     存放应用程序的数据
Data/dalvik-cache   将apk中的dex文件安装到dalvik-cache目录下
(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)

安装过程：复制APK安装包到data/app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录，并data/data目录下创建对应的应用数据目录。

 卸载过程：删除安装过程中在上述三个目录下创建的文件及目录。

5、如何做适配

1)android有H、L、M、X、XX四个不同的文件夹存放不同分辨率的图片，系统会自动加载

2) 偏移量d的设置可以在values-hpdi,values-mdpi,values-ldpi三种文件夹中的dimens.xml文件进行设置

值得一提的是：

    <dimen name=“bitmap_common_topoffset”>40dp</dimen>

    <dimen name=“bitmap_common_bottomoffset”>-14dp</dimen>

这里的负数是完全起作用的，系统会认为它是一个负值

3）各大手机厂商对于Android操作系统都有或多或少的改动，当然这些改动会对我们应用程序产生某些影响

 比如：

  （1）系统源代码中连接music服务的aidl文件所在包名：com.android.music 

  （2）LG则可能将该aidl文件修改所在的包（例如修改为 com.android.music.player），并且修改其中的文件内容（增加一个方法，或者减少几个方法，或者修改方法名称）那么我们的应用要想在LG的手机上发布，那么我们就必须改变所要连接的aidl文件,必须跟LG厂商修改的完全一致。

 

6、是否进行过apk反编译，如何防止反编译

反编译：

     Android反编译工具

・       dex2jar + jdgui

・       apktool

防止反编译：

・       代码加密

这方式，也只能想想，一旦你自己加密了，Android系统都不认识你了，还怎么运行？（如果有那估计就是eoe现在推的爱加密吧）.

・       代码混淆

这种方式，其实我不大愿意将他归类于防止反编译，从Android、Java编译原理上来说，针对自身代码做混淆等操作，必然防止不了反编译这个事实。他能做到的就是将字符，函数等混淆成各种a,b,c,d,1,2,3等。

这种方式一般称为，
妨碍对反编译代码的阅读、观看和理解

Android中主要是针对 proguard.cfg 的配置来实现。

具体的实现网上针对这部分的解释已经太多，所以这里不详细介绍了。

・       动态加载类

这种方式的启发是根据web端来的。Web端你要防止，那就不发布呗。

所以我们可以将我们重要的源码，丢在服务器上，必要的时候通过DexClassLoader类去加载重要类。来防止核心代码被反编译。

具体可看DexClassLoader示例

・       用NDK开发核心代码

从上面已经能知道，C/C++等编译型语言的反汇编难度。所以我们可以放心的使用NDK去开发，生成SO库文件再来调用。

PS:部分资源文件若十分珍贵，可以通过 #include直接编译到库里（当然内存可能就大了），这种方式可以自己考虑。

 

7、Android的动画分类以及两种动画的阐述

Tween动画

        又称“补间动画”、“中间动画”，最早接触Tween类是在学习Flash时候，使用ActionScript做动画的时候，使用过类Tween。

        Tween动画主要的功能是在绘制动画前设置动画绘制的轨迹，包括时间， 位置 ，等等。但是Tween动画的缺点是它只能设置起始点与结束点的两帧，中间过程全部由系统帮我们完成。所以在帧数比较多的游戏开发中是不太会用到它的。
       Tween一共提供了4中动画的效果

       Scale：缩放动画
       Rotate：旋转动画
       Translate：移动动画
       Alpha:：透明渐变动画

Frame动画

       又称帧动画，主要显示方式是<animation-list>为动画的总标签，这里面放着帧动画<item>标签，也就是说若干<item>标签的帧 组合在一起就是帧动画了。<animation-list > 标签中android:oneshot="false"这是一个非常重要的属性，默认为false 表示 动画循环播放， 如果这里写true 则表示动画只播发一次。 <item>标签中记录着每一帧的信息android:drawable="@drawable/a"表示这一帧用的图片为"a"，下面以此类推。 android:duration="100" 表示这一帧持续100毫秒，可以根据这个值来调节动画播放的速度。

 

 8、AIDL全称，如何工作，可处理那些数据

答：AIDL的英文全称是Android Interface Define Language
当A进程要去调用B进程中的service时，并实现通信，我们通常都是通过AIDL来操作的
A工程：
 首先我们在net.blogjava.mobile.aidlservice包中创建一个RemoteService.aidl文件，在里面我们自定义一个接口，含有方法get。ADT插件会在gen目录下自动生成一个RemoteService.java文件，该类中含有一个名为RemoteService.stub的内部类，该内部类中含有aidl文件接口的get方法。
 说明一：aidl文件的位置不固定，可以任意
 然后定义自己的MyService类，在MyService类中自定义一个内部类去继承RemoteService.stub这个内部类，实现get方法。在onBind方法中返回这个内部类的对象，系统会自动将这个对象封装成IBinder对象，传递给他的调用者。
 其次需要在AndroidManifest.xml文件中配置MyService类，代码如下：
<!-- 注册服务 --> 
 <service android:name=".MyService"> 
   <intent-filter> 
    <!--  指定调用AIDL服务的ID  --> 
       <actionandroid:name="net.blogjava.mobile.aidlservice.RemoteService"/> 
    </intent-filter> 
 </service>
为什么要指定调用AIDL服务的ID,就是要告诉外界MyService这个类能够被别的进程访问，只要别的进程知道这个ID，正是有了这个ID,B工程才能找到A工程实现通信。
 说明：AIDL并不需要权限
B工程：
      首先我们要将A工程中生成的RemoteService.java文件拷贝到B工程中，在bindService方法中绑定aidl服务
      绑定AIDL服务就是将RemoteService的ID作为intent的action参数。
      说明：如果我们单独将RemoteService.aidl文件放在一个包里，那个在我们将gen目录下的该包拷贝到B工程中。如果我们将RemoteService.aidl文件和我们的其他类存放在一起，那么我们在B工程中就要建立相应的包，以保证RmoteService.java文件的报名正确，我们不能修改RemoteService.java文件
         bindService(newInten("net.blogjava.mobile.aidlservice.RemoteService"),serviceConnection,Context.BIND_AUTO_CREATE); 
       ServiceConnection的onServiceConnected(ComponentName name, IBinderservice)方法中的service参数就是A工程中MyService类中继承了RemoteService.stub类的内部类的对象。

9、Android系统中GC什么情况下不会出现内存泄露

1. 数据库的cursor没有关闭

2.构造adapter时,没有使用缓存contentview
    衍生listview的优化问题-----减少创建view的对象,充分使用contentview,可以使用一静态类来优化处理getview的过程/

3.Bitmap对象不使用时采用recycle()释放内存

4.activity中的对象的生命周期大于activity
调试方法: DDMS==> HEAPSZIE==>dataobject==>[TotalSize]

 

10、什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?
答：一般像空指针啊，可以看起logcat，然后对应到程序中 来解决错误

11、activity的4种模式，以及不同模式的作用。

http://blog.csdn.net/zhangjg_blog/article/details/10923643

activity有四种启动模式，分别为standard，singleTop，singleTask，singleInstance。如果要使用这四种启动模式，必须在manifest文件中<activity>标签中的launchMode属性中配置，如：

<activity android:name=".app.InterstitialMessageActivity"  
          android:label="@string/interstitial_label"  
          android:theme="@style/Theme.Dialog"  
          android:launchMode="singleTask"  
</activity> 

standard

标准启动模式，也是activity的默认启动模式。在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，即调用startActivity（new Intent（this，A.class）），会在A的上面再次启动一个A的实例，即当前的C中的状态为A-->A。

singleTop

如果一个以singleTop模式启动的activity的实例已经存在于任务C的C顶，那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。举例来说，如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中，那么再调用startActivity（new Intent（this，A.class））启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。这是任务C中还是这有一个A的实例。

如果以singleTop模式启动的activity的一个实例已经存在与任务C中，但是不在C顶，那么它的行为和standard模式相同，也会创建多个实例。

singleTask

谷歌的官方文档上称，如果一个activity的启动模式为singleTask，那么系统总会在一个新任务的最底部（root）启动这个activity，并且被这个activity启动的其他activity会和该activity同时存在于这个新任务中。如果系统中已经存在这样的一个activity则会重用这个实例，并且调用他的onNewIntent()方法。即，这样的一个activity在系统中只会存在一个实例。

其实官方文档中的这种说法并不准确，启动模式为singleTask的activity并不会总是开启一个新的任务。详情请参考 解开Android应用程序组件Activity的"singleTask"之谜，在本文后面也会通过示例来进行验证。

singleInstance

总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他activity会自动运行于另一个任务中。当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。和singleTask相同，同一时刻在系统中只会存在一个这样的Activity实例。

 

12、NDK是什么

NDK：NativeDevelopment Kit

 AndroidNDK是一个让开发人员在Android应用中嵌入使用本地代码编写的组件的工具集。

Android应用运行在Dalvik虚拟机中。NDK允许开发人员使用本地代码语言(例如C和C++)实现应用的部分功能。这样以代码重用的形式能够给某类应用提供方便，而且在某些情况下能提高运行速度(感谢老婆的帮助)。

 

13、请解释下Android程序运行时权限与文件系统权限的区别

答：运行时权限Dalvik( android授权) 
     文件系统 linux 内核授权



14、横竖屏切换时候activity的生命周期?

1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 

2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 

3、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法

15、如何设定Android应用为系统应用

1  将自己的应用方到android源代码的packages/apps/目录下，添加Android.mk文件 
2 在应用程序的AndroidManifest.xml中的manifest节点中加入android:sharedUserId="android.uid.system"这个属性。 
3 修改Android.mk文件，加入LOCAL_CERTIFICATE:= platform这一行 
4 使用mm命令来编译，生成的apk就有同system一样的权限了。 
5 在android根目录下用make snod重新生成system.img 
 6 启动emulator运行下应用看看是否好了。 



16、如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?

可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中 
17.如何将打开res aw目录中的数据库文件? 
解答：在Android中不能直接打开resaw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。

18、线程中wait和sleep的区别

答：wait释放线程锁，sleep不是线程锁，wait不占用系统资源sleep占用资源

19、两种方法注册broadcaseReceiver，及区别。

答：动态注册和静态注册一个BroadcastReceiver的区别： 

动态注册较静态注册灵活。实验证明：当静态注册一个BroadcastReceiver时，不论应用程序是启动与否。都可以接受对应的广播。 

动态注册的时候，如果不执行unregisterReceiver();方法取消注册，跟静态是一样的。但是如果执行该方法，当执行过以后，就不能接受广播了。

20、在android中，请简述jni的调用过程。

1)安装和下载Cygwin，下载 Android NDK
 2)在ndk项目中JNI接口的设计
3)使用C/C++实现本地方法
4)JNI生成动态链接库.so文件
5)将动态链接库复制到java工程，在java工程中调用，运行java工程即可
21、简述Android应用程序结构是哪些? 

Android应用程序结构是：
Linux Kernel(Linux内核)、

Libraries(系统运行库或者是c/c++核心库)、

Application Framework(开发框架包)、

Applications (核心应用程序)
22、请继承SQLiteOpenHelper实现：

1）.创建一个版本为1的“diaryOpenHelper.db”的数据库，
2）.同时创建一个 “diary” 表（包含一个_id主键并自增长，topic字符型100
长度， content字符型1000长度）
3）.在数据库版本变化时请删除diary表，并重新创建出diary表。

publicclass DBHelper  extendsSQLiteOpenHelper{

 public final static String DATABASENAME ="diaryOpenHelper.db";
 public final static int DATABASEVERSION =1;

 //创建数据库
public DBHelper(Context context,Stringname,CursorFactory factory,int version)
 {
 super(context, DATABASENAME, factory, DATABASEVERSION);
 }
 //创建表等机构性文件
public void onCreate(SQLiteDatabase db)
 {
 String sql ="create tablediary"+
 "("+
 "_idinteger primary key autoincrement,"+
 "topicvarchar(100),"+
 "contentvarchar(1000)"+
 ")";
 db.execSQL(sql);
 }
 //若数据库版本有更新，则调用此方法
public void onUpgrade(SQLiteDatabasedb,int oldVersion,int newVersion)
 {

 String sql = "drop table ifexists diary";
 db.execSQL(sql);
 this.onCreate(db);
 }
 }

23、页面上现有ProgressBar控件progressBar，请用书写线程以10秒的的时间完成其进度显示工作。
publicclass ProgressBarStu extends Activity {

 private ProgressBar progressBar = null;
 protected void onCreate(BundlesavedInstanceState) {
 super.onCreate(savedInstanceState);
 setContentView(R.layout.progressbar);
 //从这到下是关键
progressBar = (ProgressBar)findViewById(R.id.progressBar);

 Thread thread = new Thread(newRunnable() {

 @Override
 public void run() {
 int progressBarMax =progressBar.getMax();
 try {
 while(progressBarMax!=progressBar.getProgress())
 {

 intstepProgress = progressBarMax/10;
 intcurrentprogress = progressBar.getProgress();
 progressBar.setProgress(currentprogress+stepProgress);
 Thread.sleep(1000);
 }

 } catch(InterruptedException e) {
 // TODO Auto-generatedcatch block
 e.printStackTrace();
 }

 }
 });

 thread.start();

 //关键结束
}

 }
24、请描述下Activity的生命周期。 

必调用的三个方法：onCreate() --<onStart() --< onResume()，用AAA表示
 （1）父Activity启动子Activity，子Actvity退出，父Activity调用顺序如下
AAA --< onResume () --< onPause() --< onStop() --<onRestart()--< onStart(),onResume() …
（2）用户点击Home，Actvity调用顺序如下
AAA --< onResume () --< onPause() --< onStop() -- Maybe--<onDestroy() C Maybe
（3）调用finish()， Activity调用顺序如下
AAA --< onPause() --< onStop() --< onDestroy()
（4）在Activity上显示dialog，Activity调用顺序如下
AAA
（5）在父Activity上显示透明的或非全屏的activity，Activity调用顺序如下
AAA --< onResume () --< onPause()
（6）设备进入睡眠状态，Activity调用顺序如下
AAA --< onFreeze() --< onPause()
25、如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？ 

在oncreate中写如下取得保存的状态：


1.   if (savedInstanceState != null  

2.               && savedInstanceState.getInt("currentposition") != 0) {  

3.     

4.           videoView.seekTo(savedInstanceState.getInt("currentposition"));  

5.       }  


重写这个方法保存状态


6.   protected void onSaveInstanceState(Bundle outState) {  

7.       // TODO Auto-generated method stub  

8.       outState.putInt("currentposition", videoView.getCurrentPosition());  

9.       Log.v("tag", "onSaveInstanceState");  

10.      super.onSaveInstanceState(outState);  

11.  }   


当你的程序中某一个Activity A在运行时，主动或被动地运行另一个新的Activity B，这个时候A会执行onSaveInstanceState()。B完成以后又会来找A，这个时候就有两种情况：一是A被回收，二是A没有被回收，被回收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上了参数savedInstanceState；而没被收回的就直接执行onResume()，跳过onCreate()了。 
26、如何将一个Activity设置成窗口的样式。 

在AndroidManifest.xml 中定义Activity的地方一句话android:theme="@android:style/Theme.Dialog"或android:theme="@android:style/Theme.Translucent"就变成半透明的
27、如何退出Activity？如何安全退出已调用多个Activity的Application？

对于单一Activity的应用来说，退出很简单，直接finish()即可。
 当然，也可以用killProcess()和System.exit()这样的方法。

28、请介绍下ContentProvider是如何实现数据共享的。

创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Contentprovider中，前提是有相同数据类型并且有写入Contentprovider的权限。

29、请解释下在单线程模型中Message、Handler、MessageQueue、Looper之间的关系。

Handler简介：
 一个Handler允许你发送和处理Message和Runable对象，这些对象和一个线程的MessageQueue相关联。每一个线程实例和一个单独的线程以及该线程的MessageQueue相关联。当你创建一个新的Handler时，它就和创建它的线程绑定在一起了。这里，线程我们也可以理解为线程的MessageQueue。从这一点上来看，Handler把Message和Runable对象传递给MessageQueue，而且在这些对象离开MessageQueue时，Handler负责执行他们。

Handler有两个主要的用途：

（1）确定在将来的某个时间点执行一个或者一些Message和Runnable对象。

（2）在其他线程（不是Handler绑定线程）中排入一些要执行的动作。

Scheduling Message，即（1），可以通过以下方法完成：
post(Runnable):Runnable在handler绑定的线程上执行，也就是说不创建新线程。
postAtTime(Runnable,long):
 postDelayed(Runnable,long):
 sendEmptyMessage(int):
 sendMessage(Message):
 sendMessageAtTime(Message,long):
 sendMessageDelayed(Message,long):
 post这个动作让你把Runnable对象排入MessageQueue,MessageQueue受到这些消息的时候执行他们，当然以一定的排序。sendMessage这个动作允许你把Message对象排成队列，这些Message对象包含一些信息，Handler的hanlerMessage(Message)会处理这些Message.当然，handlerMessage(Message)必须由Handler的子类来重写。这是编程人员需要作的事。

 当posting或者sending到一个Hanler时，你可以有三种行为：当MessageQueue准备好就处理，定义一个延迟时间，定义一个精确的时间去处理。后两者允许你实现timeout,tick,和基于时间的行为。

 当你的应用创建一个新的进程时，主线程（也就是UI线程）自带一个MessageQueue，这个MessageQueue管理顶层的应用对象（像activities,broadcastreceivers等）和主线程创建的窗体。你可以创建自己的线程，并通过一个Handler和主线程进行通信。这和之前一样，通过post和sendmessage来完成，差别在于在哪一个线程中执行这么方法。在恰当的时候，给定的Runnable和Message将在Handler的MessageQueue中被Scheduled。


Message简介：
Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象提供额外的两个int域和一个Object域，这可以让你在大多数情况下不用作分配的动作。
 尽管Message的构造函数是public的，但是获取Message实例的最好方法是调用Message.obtain(),或者Handler.obtainMessage()方法，这些方法会从回收对象池中获取一个。


MessageQueue简介：
 这是一个包含message列表的底层类。Looper负责分发这些message。Messages并不是直接加到一个MessageQueue中，而是通过MessageQueue.IdleHandler关联到Looper。
 你可以通过Looper.myQueue()从当前线程中获取MessageQueue。


Looper简介：
Looper类被用来执行一个线程中的message循环。默认情况，没有一个消息循环关联到线程。在线程中调用prepare()创建一个Looper，然后用loop()来处理messages，直到循环终止。

 大多数和message loop的交互是通过Handler。

 下面是一个典型的带有Looper的线程实现。
  class LooperThread extends Thread {
       public Handler mHandler;
       
       public void run() {
           Looper.prepare();
           
           mHandler = new Handler() {
               publicvoidhandleMessage(Message msg) {
                   // processincomingmessages here
               }
           };
           
           Looper.loop();
       }
   }
30、系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。

通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性

31、什么是ANR如何避免它?

ANR：ApplicationNotResponding，五秒 

 在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了： 

 对输入事件(如按键、触摸屏事件)的响应超过5秒 

 意向接受器(intentReceiver)超过10秒钟仍未执行完毕 

Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intentbroadcast)。 

 因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和 onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束 -- 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题

 
 ================================================================================
 
 前言
 http://blog.csdn.net/cym492224103/article/details/38417927

最近才开的博客，希望大家多多关注，andorid开发也做了3年有余了，也面试多家企业，借此机会分享一下，我们中遇到过的问题以及解决方案吧，希望能够对正在找工作的andoird程序员有一定的帮助。学完本人博客发表《ym--andorid从零开始教程》+面试题目全理解，年薪18w以上绝对没问题。

特别献上整理过的50道面试题目

1.listView的优化方式

 

重用convertView 
viewHolder 
static class viewHolder 
在列表里面有图片的情况下,监听滑动不加载图片 
多个不同布局，可以创建不同的viewHolder和convertView进行重用 
2.listView展示数据几种形式


从sqlite拉取数据源显示 
从xml使用pull解析拉取数据源显示 
从网络上拉取数据源显示 
 
3.ipc


进程间通信主要包括管道, 系统IPC(Inter-Process Communication，进程间通信)(包括消息队列,信号,共享存储), 套接字(SOCKET).
目的:
l 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。
l 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。
l 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
l 资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。
l 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
进程通过与内核及其它进程之间的互相通信来协调它们的行为。Linux支持多种进程间通信（IPC）机制，信号和管道是其中的两种。除此之外，linux还支持System V 的IPC机制（用首次出现的Unix版本命名）。  

4.Parcel的机制


Android中的Parcel机制
    实现了Bundle传递对象
    使用Bundle传递对象，首先要将其序列化，但是，在android中要使用这种传递对象的方式需要用到Android Parcel机制，即，Android实现的轻量级的高效的对象序列化和反序列化机制。

    Java中的Serialize机制，译成串行化、序列化……，其作用是能将数据对象存入字节流当中，在需要时重新生成对象。主要应用是利用外部存储设备保存对象状态，以及通过网络传输对象等。
    
    Android中的新的序列化机制
        在Android系统中，定位为针对内存受限的设备，因此对性能要求更高，另外系统中采用了新的IPC（进程间通信）机制，必然要求使用性能更出色的对象传输方式。在这样的环境下，
        Parcel被设计出来，其定位就是轻量级的高效的对象序列化和反序列化机制。
        Android中序列化有以下几个特征：
        1. 整个读写全是在内存中进行，所以效率比JAVA序列化中使用外部存储器会高很多；
        2. 读写时是4字节对齐的
        3. 如果预分配的空间不够时，会一次多分配50%；
        4. 对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。

代码：
activity代码：
 Intent mIntent =newIntent(this,ParcelableDemo.class);   
        Bundle mBundle =newBundle();   
        mBundle.putParcelable(PAR_KEY, mPolice);   
        mIntent.putExtras(mBundle);   

实体类：

public class Police implements Parcelable {
       
    private String name;
    private int workTime;
   
    public String getName() {
        returnname;
    }
   
    public void setName(String name) {
        this.name = name;
    }
   
    public int getWorkTime() {
        returnworkTime;
    }
   
    public void setWorkTime(int workTime) {
        this.workTime = workTime;
    }
       
    public static final Parcelable.Creator<Police> CREATOR =newCreator<Police>() {
   
        @Override
        public Police createFromParcel(Parcel source) {
            Police police =newPolice();
            police.name = source.readString();
            police.workTime = source.readInt();
            returnpolice;
        }
   
        @Override
        public Police[] newArray(int size) {
            returnnewPolice[size];
        }
    };
   
    @Override
    public int describeContents() {
        return0;
    }
   
    @Override
    public void writeToParcel(Parcel parcel, int flags) {
        parcel.writeString(name);
        parcel.writeInt(workTime);
    }
} 
 
5.JNI调用


(1) Eclipse中新建android工程 
工程名 JNItest 
Package名com.ura.test 
Activity名 JNItest 
应用程序名 JNItest 
(2) 编辑main.xml 
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    >
<TextView 
    android:id="@+id/JNITest"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:text="@string/JNITest"
    />
</LinearLayout>
 (3)编辑java文件 
package com.ura.test;
 

 import android.app.Activity;
 import android.os.Bundle;
 import android.widget.TextView;
 public class JNITest extends Activity {
     /** Called when the activity is first created. */
    static {
             System.loadLibrary("JNITest");
    }
    public native String GetTest();
          @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
         String str =GetTest();
         TextView JNITest = (TextView)findViewById(R.id.JNITest);
         JNITest.setText(str);
     }
 }
 (4)生成head文件 
编译上面工程声称class文件，然后用javah工具生成c/c++ 头文件 
javah -classpath bin -d jni com.ura.test.JNItest
生成的头文件如下 
/* DO NOT EDIT THIS FILE - it is machine generated */
 #include <jni.h>
 /* Header for class com_ura_test_JNITest */
 

 #ifndef _Included_com_ura_test_JNITest
 #define _Included_com_ura_test_JNITest
 #ifdef __cplusplus
 extern "C" {
 #endif
 /*
 * Class:     com_ura_test_JNITest
 * Method:    GetTest
 * Signature: ()Ljava/lang/String;
 */
 JNIEXPORT jstring JNICALL Java_com_ura_test_JNITest_GetTest
   (JNIEnv *, jobject);
 

 #ifdef __cplusplus
 }
 #endif
 #endif
 (5)编写c/c++文件如下 
include "com_ura_test_JNITest.h"

#define LOG_TAG "JNITest"
#undef LOG
#include <utils/Log.h>

 JNIEXPORT jstring JNICALL Java_com_ura_test_JNITest_GetTest
   (JNIEnv * env, jobject obj)
 {
     return (*env)->NewStringUTF(env, (char *)"JNITest Native String");
     LOGD("Hello LIB!\n");
 

 }
(6)编写android.mk文件 
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES:= \
    com_ura_test_JNITest.c
LOCAL_C_INCLUDES := \
    $(JNI_H_INCLUDE)
LOCAL_SHARED_LIBRARIES := libutils
LOCAL_PRELINK_MODULE := false
LOCAL_MODULE := libJNITest
include $(BUILD_SHARED_LIBRARY) 
(7)编译生成动态库 
新建文件夹 
~/mydroid/external/libJNITest 
把上面编写好的头文件，c/c++源文件，make文件拷贝进上面目录中 
* 需要注意的是把PRELINK_MOUDULE设置成false 
否则需要重新做成img文件再烧入。 
在 ubuntu中执行 
cd
cd mydroid/build/
envsetup.sh
cd ~/mydroid
cd external/libJNITest/
mm 
编译成功的后会在下面目录中生成libJNITest.so文件 
~mydroid/out/target/product/generic/system/lib/ 
(8)在模拟器中执行程序 
首先要把动态库拷进/system/lib中。 
启动模拟器 
adb shell
adb remount
adb push libJNITest.so /system/lib 
确认拷贝成功
 cd /system/lib
 ls
然后不要关闭模拟器（关掉再开动态库就没了，因为模拟器rom是只读） 
执行java程序JNITest 
会看到屏幕上打印出 
JNITest Native String  
6.细谈四大组件

     activity

     1.什么是activity？


四大组件之一,一般的,一个用户交互界面对应一个activity
setContentView() ,// 要显示的布局
button.setOnclickLinstener{
}
, activity 是Context的子类,同时实现了window.callback和keyevent.callback, 可以处理与窗体用户交互的事件.
 
里面不能进行耗时操作
 
我开发常用的的有ListActivity  , PreferenceActivity ,TabAcitivty等…
 
如果界面有共同的特点或者功能的时候,还会自己定义一个BaseActivity. 
     2.activity生命周期？


Activity生命周期
1 完整生命周期
  onCreate()  
  --> onStart()
  --> onResume()
   可以在手机上看见activity
  ---> onPause()
  --> onStop()
   看不见了
  ---> onDestory()
   销毁了

2 前台生命周期
  onstart()  ---> onStop()之间进行切换
  onCreate() --> onStart() --> onResume()
   现在有一个activity完全覆盖
  onPause()  ----> onStop()
   如果上面的activity关闭
  onRestart() ---> onStart() --> onResume()
   
3 可视生命周期
   onResume()  ---> onPause()之间进行切换
  onCreate() --> onStart() --> onResume()
   现在有一个activity没有完全覆盖
  onPause()
   如果上面的activity关闭
  onResume()  

     3.横竖屏切换时候activity的生命周期？


 这个生命周期跟清单文件里的配置有关系
1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期
默认首先销毁当前activity,然后重新加载
 
2、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法
 
游戏开发中, 屏幕的朝向都是写死的. 
    
      4.如何将一个activity设置成窗口的样式？

 可以自定义一个activity的样式,详细见手机卫士的程序详细信息
android:theme="@style/FloatActivity" 
E:\day9\mobilesafe\res\values\style
  

     5.activity启动模式？


Activity启动模式任务堆栈
Activity中的任务是与用户交互的一组Activity的集合，Activity会被按打开顺序安排在一个堆栈里。
任务栈：并不是Activity是Activity的引用（内存地址） 
standard 标准模式
每次激活Activity时都会创建Activity，并放入任务栈中
默认模式
  singleTop 独享堆栈顶端
如果在任务的栈顶正好存在该Activity的实例，就重用该实例，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例)
浏览器的书签
  singleTask 独享任务堆栈
如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中
浏览器的主页
  singleInstance单例
在一个新栈中创建该Activity实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity的实例存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中
通话界面
Singletop：如果重复使用上一次的Activity，就重用。
singleTask：如果使用已经实例化Activity，就重用，并且删除重用Activity前面的Activity，重用的Activity置顶任务栈。
singleInstance：在一个新栈中创建该Activity实例，并让多个应用共享该栈中的该Activity实例。（调用Activity和重用Activity不在一个栈中）
singleTop 、singleTask 、singleInstance 优化性能、重用Activity。 
 
     6.后台activity被系统回收了怎么办？如果后台activity由于某种原因被系统回收了，如何保存之前状态？

除了在栈顶的activity,其他的activity都有可能在内存不足的时候被系统回收,一个activity越处于栈底,被回收的可能性越大.
protected void onSaveInstanceState(Bundle outState) {
       super.onSaveInstanceState(outState);
       outState.putLong("id", 1234567890);
}
public void onCreate(Bundle savedInstanceState) {
//判断savedInstanceState是不是空.
//如果不为空就取出来
        super.onCreate(savedInstanceState);
} 
     7.如何退出activity,如何安全退出已调用多个activity的application？

退出activity 直接调用 finish () 方法 . //用户点击back键 就是退出一个activity
退出activity 会执行 onDestroy()方法 .
1、抛异常强制退出：
该方法通过抛异常，使程序Force Close。
验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。
 
       //安全结束进程        android.os.Process.killProcess(android.os.Process.myPid());
2、记录打开的Activity：
每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。
 
                     List<Activity> lists ; 在application 全集的环境里面
              lists = new ArrayList<Activity>();
 
lists.add(activity);
 
for(Activity activity: lists)
{
       activity.finish();
}
 
3、发送特定广播：
在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。
//给某个activity 注册接受接受广播的意图   
       registerReceiver(receiver, filter)
 
//如果过接受到的是 关闭activity的广播  就调用finish()方法 把当前的activity finish()掉
 
4、递归退出
在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。
 
 
上面是网上的一些做法.
 
其实 可以通过 intent的flag 来实现.. intent.setFlag(FLAG_ACTIVITY_CLEAR_TOP)激活一个新的activity,然后在新的activity的oncreate方法里面 finish掉. 
     8.两activity之间怎么传递数据？

基本数据类型可以通过.  Intent 传递数据 
在A activity中
Intent intent = new Intent();
intent.putExtra(name, value) 
      Bundle bundle = new Bundle();
      bundle.putBoolean(key,value);
      intent.putExtras(bundle);
extras.putDouble(key, value)
// 通过intent putExtra 方法 基本数据类型 都传递
     
      Intent i = getIntent();
      i.getExtras();
 
intent.getStringExtra("key","value");
intent.getBooleanExtra("key","value")
      Bundle bundle = new  Bundle();
       bumdle.putShort(key, value);
       intent.putExtras(bumdle);
intent.putExtras(bundle)
--------------
Application 全局里面存放 对象 ,自己去实现自己的application的这个类,
基础系统的application , 每个activity都可以取到
-----------------
 
让对象实现 implements  Serializable 接口把对象存放到文件上. 
让类实现Serializable 接口,然后可以通过ObjectOutputStream              //对象输出流 
            File file = new File("c:\1.obj");
            FileOutputStream fos  = new FileOutputStream(file);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
           
            Student stu = new Student();
            oos.writeObject(stu);
           
           
            //从文件中把对象读出来 
            ObjectInputStream ois = new ObjectInputStream(arg0);
             Student stu1 = (Student) ois.readObject();
 
文件/网络
 
intent.setData(Uri)
Uri.fromFile();  //大图片的传递 

     9.讲一讲对activity的理解？

把上面的几点用自己的心得写出来 
     
     service

     1.什么是Service以及描述下它的生命周期。Service有哪些启动方法，有什么区别，怎样停用Service？

在Service的生命周期中，被回调的方法比Activity少一些，只有onCreate, onStart, onDestroy,
onBind和onUnbind。
通常有两种方式启动一个Service,他们对Service生命周期的影响是不一样的。
1 通过startService
    Service会经历 onCreate 到onStart，然后处于运行状态，stopService的时候调用onDestroy方法。
   如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。
  2 通过bindService  
    Service会运行onCreate，然后是调用onBind， 这个时候调用者和Service绑定在一起。调用者退出了，Srevice就会调用onUnbind->onDestroyed方法。
   所谓绑定在一起就共存亡了。调用者也可以通过调用unbindService方法来停止服务，这时候Srevice就会调用onUnbind->onDestroyed方法。
需要注意的是如果这几个方法交织在一起的话，会出现什么情况呢？
一个原则是Service的onCreate的方法只会被调用一次，就是你无论多少次的startService又bindService，Service只被创建一次。
如果先是bind了，那么start的时候就直接运行Service的onStart方法，
 
如果先是start，那么bind的时候就直接运行onBind方法。
 
如果service运行期间调用了bindService，这时候再调用stopService的话，service是不会调用onDestroy方法的，service就stop不掉了，只能调用UnbindService, service就会被销毁
 
 
如果一个service通过startService 被start之后，多次调用startService 的话，service会多次调用onStart方法。多次调用stopService的话，service只会调用一次onDestroyed方法。
 
 
如果一个service通过bindService被start之后，多次调用bindService的话，service只会调用一次onBind方法。
 
多次调用unbindService的话会抛出异常。 

     2.service是否在main thread中执行, service里面是否能执行耗时的操作?

默认情况,如果没有显示的指定service所运行的进程, Service和activity是运行在当前app所在进程的main thread(UI主线程)里面 
service里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )
在子线程中执行 new Thread(){}.start();
 
特殊情况 ,可以在清单文件配置 service 执行所在的进程 ,让service在另外的进程中执行 

     3.怎么让在启动一个Activity是就启动一个service？

在activity的onCreate()方法里面 startService(); 

     4.Activity怎么和service绑定，怎么在activity中启动自己对应的service？

startService() 一旦被创建  调用着无关   没法使用service里面的方法
bindService () 把service 与调用者绑定 ,如果调用者被销毁, service会销毁
bindService() 我们可以使用service 里面的方法
       bindService().  让activity能够访问到 service里面的方法
       构建一个intent对象,
Intent service = new Intent(this,MyService.class);
 通过bindService的方法去启动一个服务,
    bindService(intent, new MyConn(), BIND_AUTO_CREATE);
       ServiceConnection 对象(重写onServiceConnected和OnServiceDisconnected方法) 和BIND_AUTO_CREATE.
       private class myconn implements ServiceConnection
 
       {
 
              public void onServiceConnected(ComponentName name, IBinder service) {
                     // TODO Auto-generated method stub
                     //可以通过IBinder的对象 去使用service里面的方法
              }
 
              public void onServiceDisconnected(ComponentName name) {
                     // TODO Auto-generated method stub
                    
              }
             
       } 

     5.不用service，B页面为音乐播放，从A跳转到B，再返回，如何使音乐继续播放？

 这个问题问的很山寨.默认不做任何处理,B里面的音乐都能播放.
遇到问题, 可以随机应变,灵活发挥,多考虑些细节,比如说这个题就可以这样说,说说你对startActivityForResult的理解()
B的结束的时候 setResult()
 
A会调用到onActivityResult()
就会获取到resultCode 
A开启B的时候,用startActivityForResult()方法, B返回的时候把播放的状态信息返回给A ,A继续播放音乐.
seekTo(resultCode) 
     6.什么是IntentService？有何优点？

普通的service ,默认运行在ui main 主线程
    Sdk给我们提供的方便的,带有异步处理的service类,
       可以在OnHandleIntent() 处理耗时的操作 

     7.什么时候使用Service?

后台操作，耗时操作的时候
 
       拥有service的进程具有较高的优先级
    官方文档告诉我们，Android系统会尽量保持拥有service的进程运行，只要在该service已经被启动(start)或者客户端连接(bindService)到它。当内存不足时，需要保持，拥有service的进程具有较高的优先级。
1． 如果service正在调用onCreate,  onStartCommand或者onDestory方法，那么用于当前service的进程相当于前台进程以避免被killed。
2． 如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed.
3． 如果客户端已经连接到service (bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。
4． 如果service可以使用startForeg round(int, Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed。
如果有其他的应用组件作为Service,Activity等运行在相同的进程中，那么将会增加该进程的重要性。
       1.Service的特点可以让他在后台一直运行,可以在service里面创建线程去完成耗时的操作.
new Thread(){
TimerTask // 循环的执行一个定时的任务
 
}.start();    
       2.Broadcast receiver捕获到一个事件之后,可以起一个service来完成一个耗时的操作.
ANR  new Service()
 
       3.远程的service如果被启动起来,可以被多次bind, 但不会重新create.  索爱手机X10i的人脸识别的service可以被图库使用,可以被摄像机,照相机等程序使用.
画廊 摄像机 照相机  bindService()  Ibinder的对象, 访问service 

     8.如何在让Service杀不死？

Android开发的过程中，每次调用startService(Intent)的时候，都会调用该Service对象的onStartCommand(Intent,int,int)方法，然后在onStartCommand方法中做一些处理。
从Android官方文档中，我们知道onStartCommand有4种int返回值，首先简单地讲讲int返回值的作用。
一、onStartCommand有4种返回值：
START_STICKY：如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。
START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。
START_REDELIVER_INTENT：重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。
START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。
 
二、创建不被杀死的service
1.在service中重写下面的方法，这个方法有三个返回值， START_STICKY（或START_STICKY_COMPATIBILITY）是service被kill掉后自动重写创建
@Override  public int onStartCommand(Intent intent, int flags, int startId)  {   return START_STICKY_COMPATIBILITY;    //return super.onStartCommand(intent, flags, startId);  }
或
 @Override  public int onStartCommand(Intent intent, int flags, int startId)  {   flags = START_STICKY;   return super.onStartCommand(intent, flags, startId);   // return START_REDELIVER_INTENT;  }
@Override public void onStart(Intent intent, int startId) { // 再次动态注册广播 IntentFilter localIntentFilter = new IntentFilter("android.intent.action.USER_PRESENT"); localIntentFilter.setPriority(Integer.MAX_VALUE);// 整形最大值 myReceiver searchReceiver = new myReceiver(); registerReceiver(searchReceiver, localIntentFilter); super.onStart(intent, startId); }
2.在Service的onDestroy()中重启Service.
 public void onDestroy()  {   Intent localIntent = new Intent();   localIntent.setClass(this, MyService.class); // 销毁时重新启动Service   this.startService(localIntent);  }
3.创建一个广播
public class myReceiver extends BroadcastReceiver {  @Override  public void onReceive(Context context, Intent intent)  {   context.startService(new Intent(context, Google.class));  } }
4.AndroidManifest.xml中注册广播myReceiver及MyService服务
<receiver android:name=".myReceiver" >             <intent-filter android:priority="2147483647" ><!--优先级加最高-->                 <!-- 系统启动完成后会调用 -->                 <action android:name="android.intent.action.BOOT_COMPLETED" />                                <!-- 解锁完成后会调用 -->                 <action android:name="android.intent.action.USER_PRESENT" />                 <!-- 监听情景切换 -->                 <action android:name="android.media.RINGER_MODE_CHANGED" />                            </intent-filter> </receiver>
<service android:name=".MyService" >
注：解锁，启动，切换场景激活广播需加权限，如启动完成，及手机机状态等。
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /> <uses-permission android:name="android.permission.READ_PHONE_STATE" />
 亲测ZTE U795手机Android 4.0.4版本adb push到system\app下android:persistent="true" 变成核心程序，在360杀掉进程的时候，myReceiver照样有效，保证service重生。呃
KILL问题： 1. settings 中stop service onDestroy方法中，调用startService进行Service的重启。 2.settings中force stop 应用 捕捉系统进行广播（action为android.intent.action.PACKAGE_RESTARTED） 3. 借助第三方应用kill掉running task 提升service的优先级，程序签名，或adb push到system\app下等
相较于/data/app下的应用，放在/system/app下的应用享受更多的特权，比如若在其Manifest.xml文件中设置persistent属性为true，则可使其免受out-of-memory killer的影响。如应用程序'Phone'的AndroidManifest.xml文件：
    <application android:name="PhoneApp"
                 android:persistent="true"
                 android:label="@string/dialerIconLabel"
                 android:icon="@drawable/ic_launcher_phone">
         ...
    </application>
设置后app提升为系统核心级别
 
     Broadcast Receiver

     1.什么是Broadcast Receiver


下面是Android Doc中关于BroadcastReceiver的概述：①广播接收器是一个专注于接收广播通知信息，并做出对应处理的组件。很多广播是源自于系统代码的──比如，通知时区改变、电池电量低、拍摄了一张照片或者用户改变了语言选项。应用程序也可以进行广播──比如说，通知其它应用程序一些数据下载完成并处于可用状态。
②应用程序可以拥有任意数量的广播接收器以对所有它感兴趣的通知信息予以响应。所有的接收器均继承自BroadcastReceiver基类。
③广播接收器没有用户界面。然而，它们可以启动一个activity来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。

有很多广播接收者 ,系统已经实现了.
广播分两种 有序广播
无序广播
 指定接收者的有序广播 .
 sendOrderedBroadcast(intent,receiverPermission,resultReceiver,scheduler,initialCode,initialData,initialExtras)
   接受者一定会获取到 广播的事件 
 
sendStickyBroadcast(intent)  //阴魂不散
广播接受者在onReceive 方法获取到广播的事件
 
Wifi设置  等待wifi状态更新完毕
 
  是不可以被拦截掉的 
<intent-filter android:priority="1000"> -1000 - 1000
<action android:name="android.provider.Telephony.SMS_RECEIVED"/>
</intent-filter>
 abortBroadcast();
 
 
代码配置优先级比xml配置优先级的级别高，因为代码运行在内存中，而清单在系统中
 
 手机卫士中自定义一个broadcast receiver
<intent-filter  android:> <action> sms_received </action>  </intent-filter>
 
来获取短信到来的广播, 根据黑名单来判断是否拦截该短信.
 画画板生成图片后,发送一个sd挂载的通知,通知系统的gallery去获取到新的图片.
Intent intent = new Intent(Intent.ACTION_MEDIA_MOUNTED,Uri.parse("file://"+Environment.getExternalStorageDirectory()));
                        sendBroadcast(intent); 

     2.什么时候使用Broadcast Receiver

用于接收系统的广播通知, 系统会有很多sd卡挂载,手机重启,广播通知,低电量,来电,来短信等…. 

     3.如何使用Broadcast Receiver

设置广播接收者的优先级,设置广播接受者的action名字 等…
详细见工程代码.
         <intent-filter android:priority="1000">
                 <action android:name="android.intent.action.NEW_OUTGOING_CALL"/>        
         </intent-filter>
        </receiver>
              <receiver android:name=".SmsReceiver">
                     <intent-filter android:priority="1000">
                            <action android:name="android.provider.Telephony.SMS_RECEIVED"/>
                     </intent-filter>
              </receiver>
              <receiver android:name=".BootCompleteReceiver">
                     <intent-filter >
                            <action android:name="android.intent.action.BOOT_COMPLETED"      />           
                            </intent-filter>
              </receiver>
 
可以通过代码   registerReceiver(receiver,filter) 
     ContentProvider

     1.什么是ContentProvider


ContentProvider内容提供者
ContentProvider 进程间通讯，进程间数据的访问/对外共享数据用
优点：提供了统一的访问方式
原理分析图


 
 
     2.什么时候使用ContentProvider

需要访问别人的数据的时候 

     3.如何使用ContentProvider

1.先是提供的数据类型等数据的类。package org.juetion.cp;

import android.NET.Uri;
import android.provider.BaseColumns;

/**
 * 提供的数据类型等数据。
 * Created by juetionke on 13-12-21.
 */
public class MyProviderMetaData {


    public static final String AUTHORIY = "org.juetion.cp.MyContentProvider";
    /**
     * 数据库名称
     */
    public static final String DATABASE_NAME = "MyProvider.db";
    /**
     * 数据库版本
     */
    public static final int DATABASE_VERSION = 1;
    /**
     * 表名
     */
    public static final String USERS_TABLE_NAME = "users";

    /**
     * 继承了BaseColumns，所以已经有了_ID
     */
    public static final class UserTableMetaData implements BaseColumns {
        /**
         * 表名
         */
        public static final String TABLE_NAME = "users";
        /**
         * 访问该ContentProvider的URI
         */
        public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORIY + "/users");
        /**
         * 该ContentProvider所返回的数据类型定义
         */
        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/org.juetion.user";
        public static final String CONTENT_TYPE_ITEM = "vnd.android.cursor.item/org.juetion.user";
        /**
         * 列名
         */
        public static final String USER_NAME = "name";
        public static final String USER_AGE = "age";
        /**
         * 默认的排序方法
         */
        public static final String DEFAULT_SORT_ORDER = "_id desc";
    }
}
2，继承ContentProvider的类：
package org.juetion.cp;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;

import org.juetion.sqlite3.DatabaseHelper;

import java.util.HashMap;

/**
 * Created by juetionke on 13-12-21.
 */
public class MyContentProvider extends ContentProvider {

    /**
     * 定义规则
     */
    public static final UriMatcher uriMatcher;
    public static final int USERS_COLLECTION = 1;//用于标记
    public static final int USERS_SINGLE = 2;//用于标记
    private DatabaseHelper databaseHelper;//这里的数据共享是共享Sqlite里的数据，当然，可以试用其他，如文本数据共享。
    static {
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);//试用一个没有规则的Uri。然后下面自己匹配。
        uriMatcher.addURI(MyProviderMetaData.AUTHORIY,"/users",USERS_COLLECTION);//自己定义的规则，有点像路由器，是uri匹配的方案。
        uriMatcher.addURI(MyProviderMetaData.AUTHORIY,"/users/#",USERS_SINGLE);//同上。
    }

    /**
     * 为列定义别名
     */
    public static HashMap<String,String> usersMap;
    static {
        usersMap = new HashMap<String, String>();
        usersMap.put(MyProviderMetaData.UserTableMetaData._ID, MyProviderMetaData.UserTableMetaData._ID);
        usersMap.put(MyProviderMetaData.UserTableMetaData.USER_NAME, MyProviderMetaData.UserTableMetaData.USER_NAME);
        usersMap.put(MyProviderMetaData.UserTableMetaData.USER_AGE, MyProviderMetaData.UserTableMetaData.USER_AGE);
    }


    @Override
    public boolean onCreate() {
        Log.i("juetion","onCreate");
        databaseHelper = new DatabaseHelper(getContext(), MyProviderMetaData.DATABASE_NAME);//这里的实现，常见前篇关于Sqlite的文章。
        return true;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        Log.i("juetion","query");
        SQLiteQueryBuilder sqLiteQueryBuilder = new SQLiteQueryBuilder();//写入查询条件，有点像hibernate。
        switch (uriMatcher.match(uri)) {//判断查询的是单个数据还是多个数据。
            case USERS_SINGLE:
                sqLiteQueryBuilder.setTables(MyProviderMetaData.UserTableMetaData.TABLE_NAME);//需要查询的表
                sqLiteQueryBuilder.setProjectionMap(usersMap);//列的别名定义
                sqLiteQueryBuilder.appendWhere(MyProviderMetaData.UserTableMetaData._ID + "=" + uri.getPathSegments().get(1));
                //查询条件，uri.getPathSegments().get(1)，getPathSegments是将内容根据／划分成list。
                break;
            case USERS_COLLECTION:
                sqLiteQueryBuilder.setTables(MyProviderMetaData.UserTableMetaData.TABLE_NAME);
                sqLiteQueryBuilder.setProjectionMap(usersMap);
                break;
        }
        String orderBy;//判断sortOrder是否为空，加入默认。
        if (TextUtils.isEmpty(sortOrder)) {
            orderBy = MyProviderMetaData.UserTableMetaData.DEFAULT_SORT_ORDER;
        } else {
            orderBy = sortOrder;
        }
        SQLiteDatabase sqLiteDatabase = databaseHelper.getWritableDatabase();
        Cursor cursor = sqLiteQueryBuilder.query(sqLiteDatabase, projection, selection, selectionArgs, null, null, sortOrder);//可以使用下面的方法，不过此时sqLiteDatabase将会没有用。
        //Cursor cursor = sqLiteDatabase.query(MyProviderMetaData.UserTableMetaData.TABLE_NAME, projection, selection, selectionArgs, null, null, orderBy);
        cursor.setNotificationUri(getContext().getContentResolver(),uri);
        return cursor;
    }

    /**
     * 根据传入的URI，返回URI说表示的数据类型
     * @param uri
     * @return
     */
    @Override
    public String getType(Uri uri) {
        Log.i("juetion","getType");
        switch (uriMatcher.match(uri)) {//匹配uri的规则
            case USERS_COLLECTION:
                return MyProviderMetaData.UserTableMetaData.CONTENT_TYPE;
            case USERS_SINGLE:
                return MyProviderMetaData.UserTableMetaData.CONTENT_TYPE_ITEM;
            default:
                throw new IllegalArgumentException("Unknown URI" + uri);
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        Log.i("juetion","insert");
        SQLiteDatabase sqLiteDatabase = databaseHelper.getWritableDatabase();
        long rowId = sqLiteDatabase.insert(MyProviderMetaData.UserTableMetaData.TABLE_NAME, null, values);
        if (rowId > 0) {
            Uri insertUserUri = ContentUris.withAppendedId(MyProviderMetaData.UserTableMetaData.CONTENT_URI, rowId);//简单来说就是字符串拼凑一下。只不过是uri专用的。
            //通知监听器
            getContext().getContentResolver().notifyChange(insertUserUri,null);
            return insertUserUri;
        }else
            throw new IllegalArgumentException("Failed to insert row into" + uri);
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        Log.i("juetion","delete");
        return 0;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        Log.i("juetion","update");
        return 0;
    }
}
还有重要的一点，再第二个APP的AndroidManifest.xml里面需要添加
<!-- provider name填写ContentProvider那个类的全称，authorities填写MyProviderMetaData里的AUTHORIY -->
        <provider
            android:authorities="org.juetion.cp.MyContentProvider"
            android:name="org.juetion.cp.MyContentProvider”/>


以下代码是在第一个APP里面的。
关于使用。只需要将uri的string提供给第一个APP。
例如在第一个APP的Activity调用数据插入：
ContentValues contentValues = new ContentValues();
                    contentValues.put("name","zhangsan");
                    contentValues.put("age",19);
                    Uri uri = getContentResolver().insert(Uri.parse("content://org.juetion.cp.MyContentProvider/users"),contentValues);
                    Log.i("juetion", "insert uri-->" + uri.toString()); 

例如在第一个APP的Activity调用数据的查询：
Cursor cursor = getContentResolver().query(Uri.parse("content://org.juetion.cp.MyContentProvider/users"),
                            new String[]{"name", "age"},
                            null, null, null);
                    while (cursor.moveToNext()) {
                        Log.i("juetion", cursor.getString(cursor.getColumnIndex("name")));
                    } 

     4.请介绍下ContentProvider是如何实现数据共享的。

ContentProvider 可以屏蔽数据操作的细节 文件 xml
MyContentProvider 可以在不同应用程序之间共享数据  sharedpreference db
       把自己的数据通过uri的形式共享出去
android  系统下 不同程序 数据默认是不能共享访问
      
       需要去实现一个类去继承ContentProvider
       public class PersonContentProvider extends ContentProvider{
       public boolean onCreate(){
              //..
       }
query(Uri, String[], String, String[], String)
insert(Uri, ContentValues)
update(Uri, ContentValues, String, String[])
delete(Uri, String, String[])
 
联系人的信息 sms的内容content://sms/
} 
     安全共同点

android安全学习 
签名作用
1.sharedUserId 一样并且签名一次 可以实现数据共享
2.升级应用
权限：细粒度的特权管理
权限与操作关联
应用需要显式申请权限
用户对权限可知（不可控）
对特权权限单独控制
四大组件
exported = true 等于public
exported = false 等于private
默认组件private
如果该组件设置了intent-filter默认是public
如果同时希望是private，就需要主动设置expoted=false
Securing Activities
可知指定权限才能启动activity
service同上
BoradcastReceiver可以设置接发的权限
ContentPrivider 可设置读写Permission
 
7.多线程管理


本篇随笔将讲解一下Android的多线程的知识，以及如何通过AsyncTask机制来实现线程之间的通信。
一、Android当中的多线程
在Android当中，当一个应用程序的组件启动的时候，并且没有其他的应用程序组件在运行时，Android系统就会为该应用程序组件开辟一个新的线程来执行。默认的情况下，在一个相同Android应用程序当中，其里面的组件都是运行在同一个线程里面的，这个线程我们称之为Main线程。当我们通过某个组件来启动另一个组件的时候，这个时候默认都是在同一个线程当中完成的。当然，我们可以自己来管理我们的Android应用的线程，我们可以根据我们自己的需要来给应用程序创建额外的线程。
二、Main Thread 和 Worker Thread
在Android当中，通常将线程分为两种，一种叫做Main Thread，除了Main Thread之外的线程都可称为Worker Thread。
当一个应用程序运行的时候，Android操作系统就会给该应用程序启动一个线程，这个线程就是我们的Main Thread，这个线程非常的重要，它主要用来加载我们的UI界面，完成系统和我们用户之间的交互，并将交互后的结果又展示给我们用户，所以Main Thread又被称为UI Thread。
Android系统默认不会给我们的应用程序组件创建一个额外的线程，所有的这些组件默认都是在同一个线程中运行。然而，某些时候当我们的应用程序需要完成一个耗时的操作的时候，例如访问网络或者是对数据库进行查询时，此时我们的UI Thread就会被阻塞。例如，当我们点击一个Button，然后希望其从网络中获取一些数据，如果此操作在UI Thread当中完成的话，当我们点击Button的时候，UI线程就会处于阻塞的状态，此时，我们的系统不会调度任何其它的事件，更糟糕的是，当我们的整个现场如果阻塞时间超过5秒钟(官方是这样说的)，这个时候就会出现 ANR (Application Not Responding)的现象，此时，应用程序会弹出一个框，让用户选择是否退出该程序。对于Android开发来说，出现ANR的现象是绝对不能被允许的。
另外，由于我们的Android UI控件是线程不安全的，所以我们不能在UI Thread之外的线程当中对我们的UI控件进行操作。因此在Android的多线程编程当中，我们有两条非常重要的原则必须要遵守：
绝对不能在UI Thread当中进行耗时的操作，不能阻塞我们的UI Thread
不能在UI Thread之外的线程当中操纵我们的UI元素
 三、如何处理UI Thread 和 Worker Thread之间的通信
既然在Android当中有两条重要的原则要遵守，那么我们可能就有疑问了？我们既不能在主线程当中处理耗时的操作，又不能在工作线程中来访问我们的UI控件，那么我们比如从网络中要下载一张图片，又怎么能将其更新到UI控件上呢？这就关系到了我们的主线程和工作线程之间的通信问题了。在Android当中，提供了两种方式来解决线程直接的通信问题，一种是通过Handler的机制(这种方式在后面的随笔中将详细介绍),还有一种就是今天要详细讲解的 AsyncTask 机制。
四、AsyncTask
AsyncTask：异步任务，从字面上来说，就是在我们的UI主线程运行的时候，异步的完成一些操作。AsyncTask允许我们的执行一个异步的任务在后台。我们可以将耗时的操作放在异步任务当中来执行，并随时将任务执行的结果返回给我们的UI线程来更新我们的UI控件。通过AsyncTask我们可以轻松的解决多线程之间的通信问题。
怎么来理解AsyncTask呢？通俗一点来说，AsyncTask就相当于Android给我们提供了一个多线程编程的一个框架，其介于Thread和Handler之间，我们如果要定义一个AsyncTask，就需要定义一个类来继承AsyncTask这个抽象类，并实现其唯一的一个 doInBackgroud 抽象方法。要掌握AsyncTask，我们就必须要一个概念，总结起来就是: 3个泛型，4个步骤。
3个泛型指的是什么呢？我们来看看AsyncTask这个抽象类的定义，当我们定义一个类来继承AsyncTask这个类的时候，我们需要为其指定3个泛型参数：
AsyncTask　<Params, Progress, Result>
Params: 这个泛型指定的是我们传递给异步任务执行时的参数的类型
Progress: 这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型
Result: 这个泛型指定的异步任务执行完后返回给UI线程的结果的类型
 我们在定义一个类继承AsyncTask类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则都将其写成Void，例如：
AsyncTask <Void, Void, Void>
4个步骤：当我们执行一个异步任务的时候，其需要按照下面的4个步骤分别执行
onPreExecute(): 这个方法是在执行异步任务之前的时候执行，并且是在UI Thread当中执行的，通常我们在这个方法里做一些UI控件的初始化的操作，例如弹出要给ProgressDialog
doInBackground(Params... params): 在onPreExecute()方法执行完之后，会马上执行这个方法，这个方法就是来处理异步任务的方法，Android操作系统会在后台的线程池当中开启一个worker thread来执行我们的这个方法，所以这个方法是在worker thread当中执行的，这个方法执行完之后就可以将我们的执行结果发送给我们的最后一个 onPostExecute 方法，在这个方法里，我们可以从网络当中获取数据等一些耗时的操作
onProgressUpdate(Progess... values): 这个方法也是在UI Thread当中执行的，我们在异步任务执行的时候，有时候需要将执行的进度返回给我们的UI界面，例如下载一张网络图片，我们需要时刻显示其下载的进度，就可以使用这个方法来更新我们的进度。这个方法在调用之前，我们需要在 doInBackground 方法中调用一个 publishProgress(Progress) 的方法来将我们的进度时时刻刻传递给 onProgressUpdate 方法来更新
onPostExecute(Result... result): 当我们的异步任务执行完之后，就会将结果返回给这个方法，这个方法也是在UI Thread当中调用的，我们可以将返回的结果显示在UI控件上
 为什么我们的AsyncTask抽象类只有一个 doInBackground 的抽象方法呢？？原因是，我们如果要做一个异步任务，我们必须要为其开辟一个新的Thread，让其完成一些操作，而在完成这个异步任务时，我可能并不需要弹出要给ProgressDialog，我并不需要随时更新我的ProgressDialog的进度条，我也并不需要将结果更新给我们的UI界面，所以除了 doInBackground 方法之外的三个方法，都不是必须有的，因此我们必须要实现的方法是 doInBackground 方法。
五、通过AsyncTask来从网络上下载一张图片
下面我们就通过两个代码示例，来看看如何通过AsyncTask来从网络上下载一张图片，并更新到我们的ImageView控件上。
①下载图片时，弹出一个ProgressDialog，但是不显示实时进度
我们来看看布局文件：

<RelativeLayoutxmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"]]
>


    <ImageView
       android:id="@+id/imageView"
        android:layout_width="wrap_content"
        android:layout_height="200dp"
        android:layout_alignParentRight="true"
        android:layout_alignParentTop="true"
        android:scaleType="fitCenter"/>

    <Button
       android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/imageView"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="41dp"
        android:text="从网络上下载一张图片"/>

</RelativeLayout]]
>


就是很简单的一个ImageView控件和一个Button控件，当点击Button控件时，弹出一个ProgressDialog，然后开启一个异步任务，从网络中下载一张图片，并更新到我们的ImageView上。这里还要注意一点，如果我们要使用手机访问网络，必须还要给其授权才行，在后续的学习当中，将会详细讲解Android当中的授权的知识。我们来看看
AndroidManifest.xml文件：

<?xml version="1.0" encoding="utf-8"?><manifestxmlns:android="http://schemas.android.com/apk/res/android"
    package="com.xiaoluo.android_asynctast"
    android:versionCode="1"
    android:versionName="1.0"]]
>


    <uses-sdk
       android:minSdkVersion="8"
        android:targetSdkVersion="18"/>
    
    <!-- 授权手机能够访问网络 -->
    <uses-permissionandroid:name="android.permission.INTERNET"/>
    
    <application
       android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme"]]
>

         <activity
           android:name="com.xiaoluo.android_asynctast.MainActivity"
            android:label="@string/app_name"]]
>

             <intent-filter]]
>

               <actionandroid:name="android.intent.action.MAIN"/>

               <categoryandroid:name="android.intent.category.LAUNCHER"/>
             </intent-filter]]
>

         </activity]]
>

    </application]]
>


</manifest]]
>


接下来我们来看看我们的Activity代码：

publicclass MainActivityextends Activity
{
    private Button button;
    private ImageView imageView;
    private ProgressDialog progressDialog;
    privatefinal String IMAGE_PATH = "http://developer.android.com/images/home/kk-hero.jpg";
//    private final String IMAGE_PATH2 = "http://ww2.sinaimg.cn/mw690/69c7e018jw1e6hd0vm3pej20fa0a674c.jpg";    @Override
    protectedvoid onCreate(Bundle savedInstanceState)
    {
         super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        button = (Button)findViewById(R.id.button);
        imageView = (ImageView)findViewById(R.id.imageView);
         //    弹出要给ProgressDialog
        progressDialog =new ProgressDialog(MainActivity.this);
        progressDialog.setTitle("提示信息");
        progressDialog.setMessage("正在下载中，请稍后......");
         //    设置setCancelable(false); 表示我们不能取消这个弹出框，等下载完成之后再让弹出框消失
        progressDialog.setCancelable(false);
         //    设置ProgressDialog样式为圆圈的形式        progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
        
        button.setOnClickListener(new View.OnClickListener()
        {
            @Override
             publicvoid onClick(View v)
            {　　　　　　　　　// 在UI Thread当中实例化AsyncTask对象，并调用execute方法
               new MyAsyncTask().execute(IMAGE_PATH);
            }
        });
    }
    
    /**
     * 定义一个类，让其继承AsyncTask这个类
     * Params: String类型，表示传递给异步任务的参数类型是String，通常指定的是URL路径
     * Progress: Integer类型，进度条的单位通常都是Integer类型
     * Result：byte[]类型，表示我们下载好的图片以字节数组返回
     *@author xiaoluo
     *
     */
    publicclass MyAsyncTaskextends AsyncTask<String, Integer,byte[]>
    {
        @Override
         protectedvoid onPreExecute()
        {
             super.onPreExecute();
             //    在onPreExecute()中我们让ProgressDialog显示出来            progressDialog.show();
        }
        @Override
         protectedbyte[] doInBackground(String... params)
        {
             //    通过Apache的HttpClient来访问请求网络中的一张图片
            HttpClient httpClient =new DefaultHttpClient();
            HttpGet httpGet =new HttpGet(params[0]);
             byte[] image =newbyte[]{};
             try
            {
                HttpResponse httpResponse = httpClient.execute(httpGet);
                HttpEntity httpEntity = httpResponse.getEntity();
               if(httpEntity !=null && httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)
                {
                    image = EntityUtils.toByteArray(httpEntity);
                }
            }
             catch (Exception e)
            {
                e.printStackTrace();
            }
             finally
            {
                httpClient.getConnectionManager().shutdown();
            }
             return image;
        }
        @Override
         protectedvoid onProgressUpdate(Integer... values)
        {
             super.onProgressUpdate(values);
        }
        @Override
         protectedvoid onPostExecute(byte[] result)
        {
             super.onPostExecute(result);
             //    将doInBackground方法返回的byte[]解码成要给Bitmap
            Bitmap bitmap = BitmapFactory.decodeByteArray(result, 0, result.length);
             //    更新我们的ImageView控件            imageView.setImageBitmap(bitmap);
             //    使ProgressDialog框消失            progressDialog.dismiss();
        }
    }
    
    @Override
    publicboolean onCreateOptionsMenu(Menu menu)
    {
        getMenuInflater().inflate(R.menu.main, menu);
         returntrue;
    }

}

我们来看看效果图：
 
 
②带有进度条更新的下载一张网络图片
下面这个代码示例，将会在下载图片的时候，显示进度条的更新，配置文件都不变，我们来看看Activity代码：

publicclass MainActivityextends Activity
{
    private Button button;
    private ImageView imageView;
    private ProgressDialog progressDialog;
    privatefinal String IMAGE_PATH = "http://developer.android.com/images/home/kk-hero.jpg";
//    private final String IMAGE_PATH2 = "http://ww2.sinaimg.cn/mw690/69c7e018jw1e6hd0vm3pej20fa0a674c.jpg";    @Override
    protectedvoid onCreate(Bundle savedInstanceState)
    {
         super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        button = (Button)findViewById(R.id.button);
        imageView = (ImageView)findViewById(R.id.imageView);
         //    弹出要给ProgressDialog
        progressDialog =new ProgressDialog(MainActivity.this);
        progressDialog.setTitle("提示信息");
        progressDialog.setMessage("正在下载中，请稍后......");
         //    设置setCancelable(false); 表示我们不能取消这个弹出框，等下载完成之后再让弹出框消失
        progressDialog.setCancelable(false);
         //    设置ProgressDialog样式为水平的样式        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
        
        button.setOnClickListener(new View.OnClickListener()
        {
            @Override
             publicvoid onClick(View v)
            {
               new MyAsyncTask().execute(IMAGE_PATH);
            }
        });
    }
    
    /**
     * 定义一个类，让其继承AsyncTask这个类
     * Params: String类型，表示传递给异步任务的参数类型是String，通常指定的是URL路径
     * Progress: Integer类型，进度条的单位通常都是Integer类型
     * Result：byte[]类型，表示我们下载好的图片以字节数组返回
     *@author xiaoluo
     *
     */
    publicclass MyAsyncTaskextends AsyncTask<String, Integer,byte[]>
    {
        @Override
         protectedvoid onPreExecute()
        {
             super.onPreExecute();
             //    在onPreExecute()中我们让ProgressDialog显示出来            progressDialog.show();
        }
        @Override
         protectedbyte[] doInBackground(String... params)
        {
             //    通过Apache的HttpClient来访问请求网络中的一张图片
            HttpClient httpClient =new DefaultHttpClient();
            HttpGet httpGet =new HttpGet(params[0]);
             byte[] image =newbyte[]{};
             try
            {
                HttpResponse httpResponse = httpClient.execute(httpGet);
                HttpEntity httpEntity = httpResponse.getEntity();
                InputStream inputStream =null;
                ByteArrayOutputStream byteArrayOutputStream =new ByteArrayOutputStream();
               if(httpEntity !=null && httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)
                {
                   //    得到文件的总长度
                   long file_length = httpEntity.getContentLength();
                   //    每次读取后累加的长度
                   long total_length = 0;
                   int length = 0;
                   //    每次读取1024个字节
                   byte[] data =newbyte[1024];
                    inputStream = httpEntity.getContent();
                   while(-1 != (length = inputStream.read(data)))
                    {
                       //    每读一次，就将total_length累加起来
                        total_length += length;
                       //    边读边写到ByteArrayOutputStream当中
                        byteArrayOutputStream.write(data, 0, length);
                       //    得到当前图片下载的进度
                       int progress = ((int)(total_length/(float)file_length) * 100);
                       //    时刻将当前进度更新给onProgressUpdate方法                        publishProgress(progress);
                    }
                }
                image = byteArrayOutputStream.toByteArray();
                inputStream.close();
                byteArrayOutputStream.close();
            }
             catch (Exception e)
            {
                e.printStackTrace();
            }
             finally
            {
                httpClient.getConnectionManager().shutdown();
            }
             return image;
        }
        @Override
         protectedvoid onProgressUpdate(Integer... values)
        {
             super.onProgressUpdate(values);
             //    更新ProgressDialog的进度条
            progressDialog.setProgress(values[0]);
        }
        @Override
         protectedvoid onPostExecute(byte[] result)
        {
             super.onPostExecute(result);
             //    将doInBackground方法返回的byte[]解码成要给Bitmap
            Bitmap bitmap = BitmapFactory.decodeByteArray(result, 0, result.length);
             //    更新我们的ImageView控件            imageView.setImageBitmap(bitmap);
             //    使ProgressDialog框消失            progressDialog.dismiss();
        }
    }
    
    @Override
    publicboolean onCreateOptionsMenu(Menu menu)
    {
        getMenuInflater().inflate(R.menu.main, menu);
         returntrue;
    }

}

我们来看看效果图：

 
这样我们就能够通过AsyncTask来实现从网络中下载一张图片，然后将其更新到UI控件中，并时时刻刻的更新当前的进度这个功能了。
六、AsyncTask的重要知识点
在上面两节已经详细讲解了AsyncTask的工作原理了，这里我们还要补充一下AsyncTask的一些其他知识点：
1.Cancelling a Task
我们可以在任何时刻来取消我们的异步任务的执行，通过调用 cancel(boolean)方法，调用完这个方法后系统会随后调用 isCancelled() 方法并且返回true。如果调用了这个方法，那么在 doInBackgroud() 方法执行完之后，就不会调用 onPostExecute() 方法了，取而代之的是调用 onCancelled() 方法。为了确保Task已经被取消了，我们需要经常调用 isCancelled() 方法来判断，如果有必要的话。
2.在使用AsyncTask做异步任务的时候必须要遵循的原则：
AsyncTask类必须在UI Thread当中加载，在Android Jelly_Bean版本后这些都是自动完成的
AsyncTask的对象必须在UI Thread当中实例化
execute方法必须在UI Thread当中调用
不要手动的去调用AsyncTask的onPreExecute, doInBackground, publishProgress, onProgressUpdate, onPostExecute方法，这些都是由Android系统自动调用的
AsyncTask任务只能被执行一次
 
到此，有关AsyncTask的总结就到此为止了，本篇随笔主要讲解了Android中的多线程知识，并且详细地讲解了 AsyncTask 异步任务的概念和实现机制，并通过实例来了解 AsyncTask 的执行过程，最后还补充了 AsyncTask 的一些重要知识点，包括如何取消一个 AsyncTask 以及，我们在使用 AsyncTask 时所必须遵循的规则。
   
8.android内存优化及管理


1、使用优化过的数据容器。 在Android framework下，建议使用优化过的数据容器比如：SparseArray,SparseBooleanArray,LongSparseArray。通用的HashMap实现的内存使用率非常的低，因为他需要为每一个mapping创建一个分离的entry object。另外，SparseArray类避免了系统对有些key的自动装箱，因而带来了更高的效率。 2、注意内存的开销。[size=12.800000190734863px]  注意你使用的语言和第三方库的成本和开销，要自始至终的将这些因素考虑在你的程序设计中。通常，有些事情表面上看着没什么问题但实际上的开销让人惊叹。比如： 
   ・枚举相对于静态常量来说，需要两倍甚至更多的内存。你应该完全避免在Android中使用枚举。 
    [size=12.666666984558105px]・每一个在java中的类（包括匿名内部类）使用大约500 bytes的代码量。    ・每一个类的实例拥有12-16 bytes的RAM消耗。    ・放置一个单独的实体到HashMap中，一个额外加的实体对象分配需要花费32 bytes。
[size=12.666666984558105px]3、关于代码的抽象  抽象是一个好的编程的基础，因为抽象可以提高代码的灵活性和可维护性。然而抽象也带来了一定的花销，一般情况下，他们有更多的代码需要执行，需要更多的时间和更多RAM来将这些代码映射到内存中。因此，如果你的抽象不能带来巨大的好处，你就应该割掉你的赘肉。
4、避免依赖注入框架  虽然注入框架给我们带来了很多方便，但是在使用这些框架的时候，框架需要花费很多时间来扫描我们自己写的代码，甚至会将哪些你根本不需要的东西也加载到内存中。
5、小心的使用扩展库  很多扩展库的代码不是针对手机环境开发的，可能在用到移动客户端的时候会导致很低的效率。因此在使用之前，需要评估一下其占用内存的大小。     即使库针对手机开发，也会有潜在的危险，因为每一个Library做的事情不尽相同。比如，一个Library使用nano protobufs而另一个使用micro protobufs。现在，在你的app中就有两个protobuf。类似情况经常发生。
6、使用混淆器移除不必要的代码  ProGuard工具通过移除无用代码，使用语意模糊来保留类，字段和方法来压缩，优化和混淆代码。可以使你的代码更加完整，更少的RAM 映射页。
7、使用多个进程（注意是process 不是 thread ok？）  如果这适合你的app，可能帮助你管理你的app的内存就是将你的app多个部分分配到多个进程中。该技术必须小心使用并且大多数应用不应该运行在多个进程下。这个技术的主要应用是后台工作跟天台工作一样重要的情况下。典型应用就是：当音乐播放器从服务器下载并长时间播放音乐，一般将其分为两个进程：一个是UI，另一个位置后台服务的运行。 like this:




1
 <serviceandroid:name=".PlaybackService"         android:process=":background"/>  


[size=12.666666984558105px]process后面需要记住要有个":",这表示该进程属于你的app。 一般情况下，一块基本的空进程需要的内存大小在1.4m左右。




1
 adb shell dumpsys meminfo com.example.android.apis:empty  

8、基本性能优化方法的基本原则：    

1）不要做你不必要的工作；

2）不要申请不必要的内存；
    例如，你明明知道一个方法返回一个String之后，你需要对这个String重新进行修改，那么就不要返回一个String，返回一个StringBuffer会是你更好的选择。     再比如，使用int比使用Integer占用更少的空间。这个大家肯定都是晓得的。     数组比一个Map拥有更好的性能。     如果你的方法不需要访问类字段，那么让你的方法是static的吧，这将会带来15%-20%速度的提升。     对于常量，请尽量使用static and final定义。如果使用final定义常量之后，会减少编译器在类生成时初始化<clinit>方法调用时对常量的存储，对于int型常量，将会直接使用其数值来进行替换，而对于String对象将会使用相对廉价的“string constant”指令来替换字段查找表。虽然这个方法并不完全对所有类型都有效，但是，将常量声明为static final绝对是一个好的做法。     避免Getters/Setters。虽然在一般的面向对象的设计模式中使用Getter和Setter是稀松平常的事情，但是在Android中使用getters/Setters是一个非常糟糕的主意，方法的调用相对于直接查找字段来说十分的昂贵。在没有JIT的情况下，直接对字段进行访问要比通过Getter访问快了近3倍。在有JIT的情况下，前者比后者快近7倍。     使用最新的循环方式。比如增强for。     避免使用浮点类型。在某些可以的情况下，将浮点替换成整型数据，然后进行计算会得到更精确的结果和更快的速度。     小心使用Native Methods。这里需要纠正的是，Native 方法并不一定能提高你应用的速度，有些甚至会拖后腿，因为，首先来说就需要一部分开销在Java-native transition上，而且JIT并不能对其进行优化。另外你需要为每个你想要在其上运行的系统结构上进行编译；即便是同一个处理器上，你也可能需要多个版本，比如为G1上的ARM处理器编译的就不能很好的在Nexus One的ARM上运行。Native代码最主要的用途是，你已经有了很多native 代码，并且你迫切希望接入Android中。而不是使用Native Method来提高你应用中某部分代码的运行速度。     [size=12.666666984558105px] 对于效率的提高除了使用遵守上面两条外基本准则外，选择合适的算法和数据结构也是非常关键的。

9、关于UI上的一些问题[size=12.800000190734863px]  Hierarchy Viewer[size=12.666666984558105px] [size=12.666666984558105px]通过他，可以看到你自己的Layout文件存在的问题。你可以看到你的Layout每一部分计算，布局，渲染所需要的时间。尽量的使你的Layout扁平话，深度最好保持 在三层之内[size=12.666666984558105px] 。RelativeLayout[size=12.666666984558105px] 是解决使用LinearLayout堆叠多层问题的利剑。那些为了方便 使[size=12.666666984558105px] 用LinearLayout的layout_weight属性[size=12.666666984558105px] 的哥们，需要重点注意，这个属性真的可以减慢measure速度。所以在使用之前，一定要再三考虑，是否真的不能通过其他方法来完成你要的效果？ 
    官方文档上 推荐使用RelativeLayout和GridLayout来避免Layout深度过深的问题[size=12.666666984558105px] 。 
    之前看文档，Google提供一个叫 ViewSub[size=12.666666984558105px] 的控件来优化那些不是必须要立即在UI上显示的控件，感兴趣的同学可以去看看。在API Level 1中就提供了这个东西，但是在实际开发中很少见到有人用或者提及（可能是我孤陋寡闻，公司就两个Android开发，另一个还要转iOS，我们俩的Android技术就代表了我们公司的Android技术能力，想想真悲哀！），其实蛮好用的。 
    重用Layout。可以使用<include/> <merge/>将其他布局嵌入到当前布局中。 
    ListView的优化：ViewHolder的使用；AsyncTask的使用；针对ListView当前滑动状态，对图片数据的加载进行控制；（ListView在配以AsyncTask加载图片时需要注[size=12.666666984558105px] 意图片的加载完显示的位置以及图片的缓存问题，具体可以参考Google的Demo[size=12.666666984558105px] ）[size=12.666666984558105px] 
[size=12.800000190734863px]10、将大消耗操作交给多个线程。 11、如果你的应用需要发送Broadcast但是又不希望别的应用获取到，或者你不希望处理别的应用发送的同样的action，那么请使用LocalBroadcastManager。
[size=12.666666984558105px]    该类是在Android Support v4中提供的，用来在同一个应用内的不同组件之间发送Broadcast。好处上面说了，可以保证应用的私密性。会比全局广播有更高的效率，但是官方文档没有说明具体数值。具体使用方法：




1
 LocalBroadcastManager.getInstance(this).registerReceiver( mStateReceiver, mStatusIntentFilter);LocalBroadcastManager.getInstance(this).sendBroadcast(localBroadcastIntent);  


使用oc计数器的方式可以更好的控制内存




Android OnLowMemory和OnTrimMemory 

OnLowMemory
OnLowMemory是Android提供的API，在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用OnLowMemory。系统提供的回调有：
Application.onLowMemory()
Activity.OnLowMemory()
Fragement.OnLowMemory()
Service.OnLowMemory()
ContentProvider.OnLowMemory()
除了上述系统提供的API，还可以自己实现ComponentCallbacks，通过API注册，这样也能得到OnLowMemory回调。例如：
public static class MyCallback implements ComponentCallbacks {
 
        @Override
        public void onConfigurationChanged(Configuration arg) {
 
        }
 
        @Override
        public void onLowMemory() {
            //do release operation
        }
    }
然后，通过Context.registerComponentCallbacks ()在合适的时候注册回调就可以了。通过这种自定义的方法，可以在很多地方注册回调，而不需要局限于系统提供的组件。
OnTrimMemory
OnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。系统提供的回调有：
Application.onTrimMemory()
Activity.onTrimMemory()
Fragement.OnTrimMemory()
Service.onTrimMemory()
ContentProvider.OnTrimMemory()
OnTrimMemory的参数是一个int数值，代表不同的内存状态：
TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理
TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。
TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。
TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。      
      以上4个是4.0增加
TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存
TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存
TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存      
 
      以上3个是4.1增加
系统也提供了一个ComponentCallbacks2，通过Context.registerComponentCallbacks()注册后，就会被系统回调到。
OnLowMemory和OnTrimMemory的比较
1，OnLowMemory被回调时，已经没有后台进程；而onTrimMemory被回调时，还有后台进程。 2，OnLowMemory是在最后一个后台进程被杀时调用，一般情况是low memory killer 杀进程后触发；而OnTrimMemory的触发更频繁，每次计算进程优先级时，只要满足条件，都会触发。 3，通过一键清理后，OnLowMemory不会被触发，而OnTrimMemory会被触发一次。
 
9.图片缓存机制


目前很多商业应用都会涉及到从网络上读取图片数据的问题，为了节约用户流量，应用一般会将图片缓存起来。图片缓存一般分为内存缓存和外存缓存。内存缓存运用java的缓存机制，在程序完全退出后，缓存所在的内存空间可能被其它应用程序占用从而丢失。外存缓存一般放在程序特有的访问空间或者sd卡中，在sd卡中存放的资源为公有资源，其它程序也可以访问，且对用户来讲没有一个强制清除缓存的规范机制。综合以上，本文采用将缓存图片放置在程序的特有空间中， 其它应用程序无法访问，且用户可以在应用程序管理中的"清除数据"选项中清除缓存。 
      本文提供三种缓存策略：（1）LRU算法，固定缓存图片数量(max_num)，当图片数量超出max_num时，将缓存中最近用的最少的图片删除。（2）FTU算法，固定每张图片的缓存时限，以最后一次使用算起，超过时限后删除。（3）FMU算法，在存储器中固定一定大小的存储空间，超过固定空间后将缓存中占用最大尺寸的图片删除。使用时只需要向方法体中传递图片的URL即可。

代码片段

使用方法：
    1.导入jar;
    2. 获取服务；
    3.提交url,交给程序去判断是否下载。 
 

public class ImagecachetacticsdemoActivity extends Activity {     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.item);         /*FMU*/         imageCacheManager = ImageCacheManager.getImageCacheService(this,                 ImageCacheManager.MODE_FIXED_MEMORY_USED, "memory");         imageCacheManager.setMax_Memory(1024 * 1024);         /*FTU*/         // imageCacheManager = ImageCacheManager.getImageCacheService(this,         // ImageCacheManager.MODE_FIXED_TIMED_USED, "time");         // imageCacheManager.setDelay_millisecond(3 * 60 * 1000);                    /*LRU*/         // imageCacheManager = ImageCacheManager.getImageCacheService(this,         // ImageCacheManager.MODE_LEAST_RECENTLY_USED, "num");         // imageCacheManager.setMax_num(5);         // imageCacheManager = ImageCacheManager.getImageCacheService(this,         // ImageCacheManager.MODE_NO_CACHE_USED, "nocache");         mImageView = (ImageView) findViewById(R.id.imageView);         new DownloadTask()                 .execute("http://www.touxiang99.com/uploads/allimg/110417/1_110417112640_2.jpg");     }     private class DownloadTask extends AsyncTask<String, Void, Bitmap> {         @Override         protected Bitmap doInBackground(String... params) {             try {                 return imageCacheManager.downlaodImage(new URL(params[0]));             } catch (IOException e) {                 e.printStackTrace();             }             return null;         }         @Override         protected void onPostExecute(Bitmap result) {             mImageView.setImageBitmap(result);             super.onPostExecute(result);         }         @Override         protected void onPreExecute() {             mImageView.setImageResource(R.drawable.ic_launcher);             super.onPreExecute();         }     }     private ImageView mImageView;     private ImageCacheManager imageCacheManager;
}  

 
 
10.Handler机制


 
11.什么是ANR 如何避免它？


ANR：Application NotResponding，五秒
　　在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：
　　对输入事件(如按键、触摸屏事件)的响应超过5秒
　　意向接受器(intentReceiver)超过10秒钟仍未执行完毕
　　Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intentbroadcast)。
　　因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和 onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束 -- 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。 

12.sqlite操作使用



本帖最后由 y_m 于 2013-6-2 00:27 编辑SQLite数据库
数据库:它就是一个软件，需要安装，安装完后就有自己的目录结构。
         都有客户端和服务端，所有的数据库都实现了SQL标准
SQLite数据库:它是一个轻量级数据库，设计目的是嵌入式的，而且它占用的资源非常少
        注意:除了主键不能存储任意的类型之外，其他的字段可以存放任意的数据类型
                SqliteDatabase它要求:表的主键的字段名最好是_id，一定要_id  否则报错;




Cmd操作指令：
sqlite3 qjq.db 进入数据库
.tables 查看数据库里面的表
创建数据库文件：
三种方式：
第一种通过上下文创建数据库：
public class DBsqlite {
        private Context context;
        public DBsqlite(Context context) {
                super();
                this.context = context;
        }
        public void createDB() {
                //通过上下文创建数据库
                   context.openOrCreateDatabase("persons.db", Context.MODE_PRIVATE, null);
        }
｝
第二种SQLiteDatabase创建数据库
    public void createDB(){
                String dir="/data/data/"+context.getPackageName();
                File file=new File(dir,"persons.db");
                SQLiteDatabase.openOrCreateDatabase(file, null);
        }
第三种创建一个help类继承SQLiteOpenHelper
实现DBhelp构造onCreate方法onUpgrade方法
public class DBhelp extends SQLiteOpenHelper {
        public DBhelp(Context context) {
//                上下文        ，数据库名，游标工厂 ，数据版本
                super(context, "persons.db", null, 2);
                // TODO Auto-generated constructor stub
        }
        //数据库第一次创建之后调用该方法。创建表、视图。。。 或者初始化表信息
        public void onCreate(SQLiteDatabase db) {
                // 创建数据库
                db.execSQL("create table fish(_id integer primary key autoincrement,name text)");
        }
        @Override
//当数据版本被改变则会执行该方法super(context, "persons.db", null, 3)；
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                // 版本修改表添加一列
                db.execSQL("ALTER TABLE fish ADD amount integer");
        }
Crud
以下分别用两种方式crud了，一种是面向SQL ，一种是面向对象，但是面向对象的源码里面其实也是在帮你拼接sql。
public class OtherFishService {
        private SQLiteOpenHelper mOpenHelper;
        public OtherFishService(Context context) {
                // TODO Auto-generated constructor stub
                mOpenHelper = new DBHelper(context);
        }
        /**
         * 插入数据
         * @param name
         */
        public void insert(String name){
                SQLiteDatabase db = mOpenHelper.getWritableDatabase();
//                String sql = "insert into fish(name) values(?)";
                if(db.isOpen()){
//                        db.execSQL(sql, new Object[]{name});
                        //insert into fish
                        //ContentValues里面就是要插入的值
                        ContentValues values = new ContentValues();
                        values.put("name", name);
                        db.insert("fish", "_id", values);
                        db.close();
                }
        }
        public List<Fish> query(){
                List<Fish> fishs = new ArrayList<Fish>();
                SQLiteDatabase db = mOpenHelper.getReadableDatabase();
//                String sql ="select * from fish";
                if(db.isOpen()){
                        //cursor 就是resultset
//                        Cursor cursor = db.rawQuery(sql, null);
                        Cursor cursor = db.query("fish",//表名
                                        new String[]{"*"},//要查询的列名
                                        null,//查询条件
                                        null,//条件参数
                                        null,//分组
                                        null,//条件
                                        null);//排序
                        while(cursor.moveToNext()){
                                //得到_id的下标
                                int column_index = cursor.getColumnIndex("_id");
                                //得到_id的值
                                int _id = cursor.getInt(column_index);
                                String name = cursor.getString(cursor.getColumnIndex("name"));
                                Fish fish = new Fish(_id, name);
                                fishs.add(fish);
                        }
                        //cursor使用完成之后一定要关闭
                        cursor.close();
                        db.close();
                }
                return fishs;
        }
        public void update(Fish fish){
                SQLiteDatabase db = mOpenHelper.getWritableDatabase();
                if(db.isOpen()){
//                        String sql = "update Fish set name = ? where _id = ?";
//                        db.execSQL(sql,new Object[]{fish.name,fish._id});
                        ContentValues values = new ContentValues();
                        values.put("name",fish.name);
                        String whereClause = " _id = ?";
                        String[] whereArgs = new String[]{fish._id+""};
                        db.update("fish", values, whereClause, whereArgs);
                }
        }
        public void delete(int _id){
                SQLiteDatabase db = mOpenHelper.getWritableDatabase();
                if(db.isOpen()){
//                        String sql = "delete from fish where _id = ?";
//                        db.execSQL(sql,new Object[]{_id});
                        String whereClause = " _id = ?";
                        String[] whereArgs = new String[]{_id+""};
                        db.delete("fish", whereClause, whereArgs);
                }
        }
} 


SqliteDatabase事务列表显示多条数据事务，以及事务的完整性SQLiteDatabase控制事务方法：
beginTransaction();        开启事务
setTransactionSuccessful();        设置事务成功
endTransaction();结束事务
db.beginTransaction();                //开始事务
        try {
                db.execSQL("update student set amount=amount-300 where name=?", new Object[]{"张三"});
                db.execSQL("update student set amount=amount+300 where name=?", new Object[]{"李四"});
                db.setTransactionSuccessful();         //设置事务成功
       
        } catch (Exception e) {
                System.out.println("事务执行出现异常，不能设置事务成功！");
        }finally{
        //无论是否出现异常，都要结束事务。
                db.endTransaction();
        }
cmd常见指令：
Sqlite3 xx.db                查看xx数据库
.tables                        查看所有表
.exit                                退出
.databases                查看所有数据库
标签：
include标签实现组件复用
将另一个布局文件加载到当前布局文件，实现组件复用
<!-- 加载一个布局文件 -->
<include layout="@layout/item"/>
属性 android:visibility=有三个选项
<!--
Visible :可见
           都是不可见
    invisible : 还占据空间
    gone：不占据空间
     -->
列表显示多条数据 simpleAdapter
代码：
OtherFishService ofs = new OtherFishService(this);
            List<Fish> fishs = ofs.query();
            List<Map<String,Object>>data=new ArrayList<Map<String,Object>>();
            for(Fish f:fishs){
                    Map<String,Object> map = new HashMap<String, Object>();
                    map.put("_id", f._id);
                    map.put("name",f.name);
                    map.put("age", f.age);
                    data.add(map);
            }
            String[] from = new String[]{"_id","name","age"};
            int[] to = new int[]{R.id.tv_id,R.id.tv_name,R.id.tv_age};
            SimpleAdapter adapter = new SimpleAdapter(this,
                            data,
                            R.layout.item,
                            from,
                            to);
            lv.setAdapter(adapter);
以上可以实现但是过于麻烦！
我们还可以使用专门为数据库提供的
Cursoradapter
OtherFishService ofs = new OtherFishService(this);
            Cursor c = ofs.getAllCursor();
            String[] from = new String[]{"_id","name","age"};
            int[] to = new int[]{R.id.tv_id,R.id.tv_name,R.id.tv_age};
            SimpleCursorAdapter adapter = new SimpleCursorAdapter(
                            this,
                            R.layout.item,
                            c,
                            from,
                            to);
            lv.setAdapter(adapter);
我们不单单只用android给我们提过的CursorAdapter我们还可以自定义一个CursorAdapter
自定义CursorAdapter
public class MyCursorAdapter extends CursorAdapter {
        //布局加载器（是一个服务，用来加载xml布局文件到java代码中）
        private LayoutInflater mInflater;
       
        public MyCursorAdapter(Context context, Cursor c) {
                super(context, c);
        mInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
               
                mInflater = LayoutInflater.from(context);
               
        }
        //创建一个item的布局
        @Override
        public View newView(Context context, Cursor cursor, ViewGroup parent) {
                // TODO Auto-generated method stub
                //通过布局加载器加载布局
                View view = mInflater.inflate(R.layout.item, null);
                return view;
        }
        //把数据绑定给item里面的布局
        @Override
        public void bindView(View view, Context context, Cursor cursor) {
                // TODO Auto-generated method stub
        //1 先得到控件
                //2 得到数据
                //3 绑定数据给控件
                TextView tv_id = (TextView) view.findViewById(R.id.tv_id);
                TextView tv_name = (TextView) view.findViewById(R.id.tv_name);
                TextView tv_age = (TextView) view.findViewById(R.id.tv_age);
               
                String _id = cursor.getString(0);
                String name = cursor.getString(1);
                String age = cursor.getString(2);
               
                tv_id.setText(_id);
                tv_name.setText(name);
                tv_age.setText(age);
               
                int position = cursor.getPosition();
                if(position%2 ==0){
                        view.setBackgroundColor(Color.RED);
                }else{
                        view.setBackgroundColor(Color.GREEN);
                }
               
        }
}
为了实现 我们想要的并且系统没提供的效果所以我们要自定义Adapter
不仅可以继承CursorAdapter 实现自定义CursorAdapter ，我们还可以通
过继承BaseAdapter 。
private class MyCursorAdapter extends BaseAdapter {
                private Context context;
                private Cursor c;
                private LayoutInflater mInflater;
               
                public MycursorAdapter1(Context context, Cursor c) {
                        super();
                        this.context = context;
                        this.c = c;
                        mInflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
                }
                @Override
                public int getCount() {
                        // TODO Auto-generated method stub
                        return c.getCount();
                }
                @Override
                public Object getItem(int position) {
                        Person p = null;
                        if (c.moveToPosition(position)) {
                                String id = c.getString(0);
                                String name = c.getString(1);
                                String age = c.getString(2);
                                p = new Person(id, name, age);
                        }
                        return p;
                }
                @Override
                public long getItemId(int position) {
                        // TODO Auto-generated method stub
                        return position;
                }
                @Override
                public View getView(int position, View convertView, ViewGroup parent) {
                        //1得到视图
//2从视图中拿到要显示对象
//3从cursor里面拿值
//4绑定
//5返回
注意：getView方法实际会执行原本次数2倍（例：7条数据与，getView执行7*2次），第一遍执行是为了测试有多少条数据，第2遍执行才是真正的现实操作
                        View view = mInflater.inflate(R.layout.item, null);
                        TextView tv_id = (TextView) view.findViewById(R.id.bt_id);
                        TextView tv_name = (TextView) view.findViewById(R.id.bt_name);
                        TextView tv_age = (TextView) view.findViewById(R.id.bt_age);
                        if (c.moveToPosition(position)) {
                                String id = c.getString(0);
                                String name = c.getString(1);
                                String age = c.getString(2);
                                tv_id.setText(id);
                                tv_name.setText(name);
                                tv_age.setText(age);
                                 
                        }
                        if ( position% 2 == 0) {
                                view.setBackgroundColor(Color.RED);
                        }
                        return view;
                }
        }
当我们用完cursor的时候，怎么关闭他？
//应用回收资源  退出程序时调用该方法
        @Override
        protected void onDestroy() {
                // TODO Auto-generated method stub
                super.onDestroy();r
                Cursor c = adapter.getCursor();
                if(c != null && !c.isClosed()){
                        c.close();
                }
        } 

 
 
13请描述一下Intent 和 Intent Filter。


Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。
通过Intent 可以实现各种系统组件的调用与激活. 
 
 
Intent filter: 可以理解为邮局或者是一个信笺的分拣系统…
这个分拣系统通过3个参数来识别
Action: 动作    view
Data: 数据uri   uri
Category : 而外的附加信息 
Action 匹配
Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件，一个 Intent Filter 可以包含多个 Action。在 AndroidManifest.xml 的 Activity 定义时可以在其 <intent-filter >节点指定一个 Action 列表用于标示 Activity 所能接受的“动作”，例如：
 <intent-filter >
 <action android:name="android.intent.action.MAIN" />
 <action android:name="cn.itcast.action" />
……
 </intent-filter>
 
如果我们在启动一个 Activity 时使用这样的 Intent 对象：
 Intent intent =new Intent();
 intent.setAction("cn.itcast.action");
 startActivity(intent);
 
那么所有的 Action 列表中包含了“cn.itcast”的 Activity 都将会匹配成功。
Android 预定义了一系列的 Action 分别表示特定的系统动作。这些 Action 通过常量的方式定义在 android.content. Intent中，以“ACTION_”开头。我们可以在 Android 提供的文档中找到它们的详细说明。
URI 数据匹配
一个 Intent 可以通过 URI 携带外部数据给目标组件。在 <intent-filter >节点中，通过 <data/>节点匹配外部数据。
mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。如下：
 <data android:mimeType="mimeType" android:scheme="scheme"
 android:host="host" android:port="port" android:path="path"/>
Intent intent = new Intent();
intent.setAction(Intent.ACTION_CALL);
insent.setData( Uri.parse(tel:12345));
startAcitivty();
电话的uri   tel: 12345
           http://www.baidu.com
自己定义的uri  itcast://cn.itcast/person/10
 
如果在 Intent Filter 中指定了这些属性，那么只有所有的属性都匹配成功时 URI 数据匹配才会成功。
Category 类别匹配
<intent-filter >节点中可以为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。
默认是DEFAULT 
14.Intent传递数据时，可以传递哪些类型数据？


1.一般的基本数据类型  Intent .putextra() intent.getextra();
Parselable Serializable
 
       2.数据的uri, intent.setData() intent.getData(); 

15.Android事件传递机制


Android中dispatchTouchEvent,onInterceptTouchEvent, onTouchEvent的理解ec
android中的事件类型分为按键事件和屏幕触摸事件，Touch事件是屏幕触摸事件的基础事件，有必要对它进行深入的了解。 一个最简单的屏幕触摸动作触发了一系列Touch事件：ACTION_DOWN->ACTION_MOVE->ACTION_MOVE->ACTION_MOVE...->ACTION_MOVE->ACTION_UP
android的事件处理分为3步。
1）public booleandispatchTouchEvent(MotionEvent ev)  这个方法用来分发TouchEvent 2）public boolean onInterceptTouchEvent(MotionEvent ev) 这个方法用来拦截TouchEvent 3）public boolean onTouchEvent(MotionEvent ev) 这个方法用来处理TouchEvent
假设当前Activity 布局如下：


dispatchTouchEvent事件分发
当TouchEvent发生时，首先Activity将TouchEvent传递给最顶层的View， TouchEvent最先到达最顶层 view 的 dispatchTouchEvent 。然后由  dispatchTouchEvent 方法进行分发，如果dispatchTouchEvent返回true ，则交给这个view的onTouchEvent处理，如果dispatchTouchEvent返回 false ，则交给这个 view 的 onInterceptTouchEvent方法来决定是否要拦截这个事件，
如果onInterceptTouchEvent返回 true ，也就是拦截掉了，则交给它的 onTouchEvent 来处理，如果onInterceptTouchEvent返回 false ，那么就传递给子 view，由子 view 的 dispatchTouchEvent 再来开始这个事件的分发。
 如图：



事件拦截：onInterceptTouchEvent
 onInterceptTouchEvent用于改变事件的传递方向。决定传递方向的是返回值，返回为false时事件会传递给子控件，返回值为true时事件会传递给当前控件的onTouchEvent()，这就是所谓的Intercept(拦截)。
[tisa ps:正确的使用方法是，在此方法内仅判断事件是否需要拦截，然后返回。即便需要拦截也应该直接返回true，然后由onTouchEvent方法进行处理。]
onTouchEvent用于处理事件，返回值决定当前控件是否消费（consume）了这个事件。尤其对于ACTION_DOWN事件，返回true，表示我想要处理后续事件（ACTION_MOVE或者ACTION_UP）；返回false，表示不关心此事件，并返回由父类进行处理。 
在没有重写onInterceptTouchEvent()和onTouchEvent()的情况下(他们的返回值都是false), 对上面这个布局，MotionEvent事件的传递顺序如下：


当某个控件的onInterceptTouchEvent()返回值为true时，就会发生截断，事件被传到当前控件的onTouchEvent()。如我们将LayoutView2的onInterceptTouchEvent()返回值为true,则传递流程变成：



 如果我们同时将LayoutView2的onInterceptTouchEvent()和onTouchEvent()设置成true，那么LayoutView2将消费被传递的事件，同时后续事件（如跟着ACTION_DOWN的ACTION_MOVE或者ACTION_UP）会直接传给LayoutView2的onTouchEvent(),不传给其他任何控件的任何函数。同时传递给子空间一个ACTION_CANCEL事件。传递流程变成（图中没有画出ACTION_CANCEL事件）：



小总结：onInterceptTouchEvent是自rootiew向下传递, onTouchEvent正好相反。
 
16.请介绍下Android中常用的五种布局。


FrameLayout（帧布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）
   FrameLayout
    从屏幕的左上角开始布局,叠加显示, 实际应用 播放器的暂停按钮.   
   LinearLayout
线性布局，这个东西，从外框上可以理解为一个div，他首先是一个一个从上往下罗列在屏幕上。每一个LinearLayout里面又可分为垂直布局
（android:orientation="vertical"）和水平布局（android:orientation="horizontal"
）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。
AbsoluteLayout
绝对布局犹如div指定了absolute属性，用X,Y坐标来指定元素的位置android:layout_x="20px"  view
android:layout_y="12px" fwvga 854*480apk
qq斗地主 qq游戏大厅800*480 800*480.apk  fwvga  854*480
指定平板机型的游戏开发中经常用到绝对布局  widget 绝对布局 
指定机型的平板游戏开发. 2.3 3.0
1.  界面布局  任务管理器 gridview
2.  手机 任务管理 listview
 
lephone 
lepad 
  RelativeLayout
    相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：
        相对于某一个元素
    android:layout_below="@id/aaa" 该元素在 id为aaa的下面
    android:layout_toLeftOf="@id/bbb" 改元素的左边是bbb
        相对于父元素的地方
     android:layout_alignParentLeft="true"  在父元素左对齐
android:layout_alignParentRight="true" 在父元素右对齐
 
 
Android  oa客户端.
TableLayout <table>
表格布局类似Html里面的Table。每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素，设定他的对齐方式android:gravity="" 。
每一个布局都有自己适合的方式，另外，这五个布局元素可以相互嵌套应用，做出美观的界面。
oa  自动化 生成报表 ,图标 表示   webview  
css div
webview
  
17.谈谈UI中，Padding和Margin有什么区别？

Padding 文字对边框, margin是控件对父窗体.
Padding 盒子里面的内容距离盒子的距离 , margin 盒子与盒子之间的距离  
18.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。





简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.
Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列.
Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息.
Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的Handler：Handler接受到消息后调用handleMessage进行处理.
Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理,在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)，线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：
1. Message
Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。
2. Handler
Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。
3. Message Queue
Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。
每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。
4. Looper
Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：
1. 在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。
2. 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。随后Looper取出了那个Message，则调用该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：
1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；
2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；
3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。
由此可见，我们实现的handleMessage方法是优先级最低的！
3. Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！
在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法――判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！
1. 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper；
2. Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。 

19.AIDL的全称是什么？如何工作？


AIDL的英文全称是Android Interface Define Language当A进程要去调用B进程中的service时，并实现通信，我们通常都是通过AIDL来操作的A工程：首先我们在net.blogjava.mobile.aidlservice包中创建一个RemoteService.aidl文件，在里面我们自定义一个接口，含有方法get。ADT插件会在gen目录下自动生成一个RemoteService.java文件，该类中含有一个名为RemoteService.stub的内部类，该内部类中含有aidl文件接口的get方法。说明一：aidl文件的位置不固定，可以任意然后定义自己的MyService类，在MyService类中自定义一个内部类去继承RemoteService.stub这个内部类，实现get方法。在onBind方法中返回这个内部类的对象，系统会自动将这个对象封装成IBinder对象，传递给他的调用者。其次需要在AndroidManifest.xml文件中配置MyService类，代码如下：<!-- 注册服务 -->  <service android:name=".MyService">    <intent-filter>    <!--  指定调用AIDL服务的ID  -->        <action android:name="net.blogjava.mobile.aidlservice.RemoteService" />     </intent-filter> </service>为什么要指定调用AIDL服务的ID,就是要告诉外界MyService这个类能够被别的进程访问，只要别的进程知道这个ID，正是有了这个ID,B工程才能找到A工程实现通信。说明：AIDL并不需要权限B工程：      首先我们要将A工程中生成的RemoteService.java文件拷贝到B工程中，在bindService方法中绑定aidl服务      绑定AIDL服务就是将RemoteService的ID作为intent的action参数。      说明：如果我们单独将RemoteService.aidl文件放在一个包里，那个在我们将gen目录下的该包拷贝到B工程中。如果我们将RemoteService.aidl文件和我们的其他类存放在一起，那么我们在B工程中就要建立相应的包，以保证RmoteService.java文件的报名正确，我们不能修改RemoteService.java文件           bindService(new Inten("net.blogjava.mobile.aidlservice.RemoteService"), serviceConnection, Context.BIND_AUTO_CREATE);        ServiceConnection的onServiceConnected(ComponentName name, IBinder service)方法中的service参数就是A工程中MyService类中继承了RemoteService.stub类的内部类的对象。

 

20.请解释下Android程序运行时权限与文件系统权限的区别。


Android程序执行需要读取到安全敏感项必需在androidmanifest.xml中声明相关权限请求, 打电话,访问网络,获取坐标,读写sd卡,读写联系人等..安装的时候会提示用户…
 
文件系统的权限是linux权限. 比如说sharedpreference里面的Context.Mode.private  Context.Mode.world_read_able   Context.Mode_world_writeable 
777自己 同组 其他 
21.系统上安装了多种浏览器，能否指定某浏览器访问指定页面


 Intent intent =newIntent();        
         intent.setAction("android.intent.action.VIEW");    
         Uri content_url =Uri.parse("http://www.163.com");   
         intent.setData(content_url);           
         intent.setClassName("com.android.browser","com.android.browser.BrowserActivity");   
         startActivity(intent);
只要修改以intent.setClassName("com.android.browser","com.android.browser.BrowserActivity");
中相应的应用程序packagename 和要启动的activity即可启动其他浏览器来
uc浏览器"："com.uc.browser", "com.uc.browser.ActivityUpdate“
opera浏览器："com.opera.mini.android", "com.opera.mini.android.Browser"
qq浏览器："com.tencent.mtt", "com.tencent.mtt.MainActivity" 
22.对android主线程的运用和理解。


主ui线程不能执行耗时的操作 
23.对android虚拟机的理解，包括内存管理机制垃圾回收机制。dalvik和art区别



虚拟机很小,空间很小,谈谈移动设备的虚拟机的大小限制 16M ,
谈谈加载图片的时候怎么处理大图片的,
outmemoryException
BitmapFactory.option 
垃圾回收,没有引用的对象,在某个时刻会被系统gc掉 .

Dalvik和标准Java虚拟机(JVM)首要差别
Dalvik 基于寄存器，而 JVM 基于栈。
基于寄存器的虚拟机对于编译后变大的程序来说，在它们执行的时候，花费的时间更短。
Dalvik和Java运行环境的区别
1：Dalvik主要是完成对象生命周期管理，堆栈管理，线程管理，安全和异常管理，以及垃圾回收等等重要功能。
2：Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。
3：不同于Java虚拟机运行java字节码，Dalvik虚拟机运行的是其专有的文件格式Dex
4:dex文件格式可以减少整体文件尺寸，提高I/o操作的类查找速度。
5:odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化。
6：所有的Android应用的线程都对应一个Linux线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制
7：有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化，库的加载，预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的数据提供给系统。对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域。
8：Dalvik是由Dan Bornstein编写的，名字来源于他的祖先曾经居住过名叫Dalvík的小渔村，村子位于冰岛Eyjafj&ouml;r&eth;ur

许多GC实现都是在对象开头的地方留一小块空间给GC标记用。Dalvik VM则不同，在进行GC的时候会单独申请一块空间，以位图的形式来保存整个堆上的对象的标记，在GC结束后就释放该空间。 
dalvik是执行的时候编译+运行，安装比较快，开启应用比较慢，应用占用空间小ART是安装的时候就编译好了，执行的时候直接就可以运行的，安装慢，开启应用快，占用空间大用个比喻来说就是，骑自行车dalvik 是已经折叠起来的自行车，每次骑都要先组装自行车才能骑ART 是已经组装好的自行车，每次骑直接上车就能走人效率高在开启的时候，运行中的速度是差不多的 
24.Framework工作方式及原理，Activity是如何生成一个view的，机制是什么。


主要用到反射和代理的知识。主要用pull解析xml，然后通过反射得到属性，在onDrew画出来
 
反射 , 配置文件 
 可以讲下activity的源码,比如说 每个activity里面都有window.callback和keyevent.callback,一些回调的接口或者函数吧. 框架把activity创建出来就会调用里面的这些回调方法,会调用activity生命周期相关的方法.
 
 
Activity创建一个view是通过ondraw 画出来的, 画这个view之前呢,还会调用onmeasure方法来计算显示的大小. 
25.android本身的一些限制，比如apk包大小限制，读取大文件时的时间限


这个问题问的有问题, apk包大小限制不好说,
极品飞车有100M 还是能装到手机上,
世面google market 上大程序  主程序 很小 5~10M    下载sdcard
200~300M 
15分钟之内 申请退款 
apk包,精简包, 素材存放在服务器. 游戏程序.
 
 
读大文件的时间限制应该是main线程里面的时间限制吧.5秒. 
26.Android程序与Java程序的区别？


Android程序用android sdk开发,java程序用javasdk开发.
Android SDK引用了大部分的Java SDK，少数部分被Android SDK抛弃，比如说界面部分，java.awt  swing  package除了java.awt.font被引用外，其他都被抛弃，在Android平台开发中不能使用。 android sdk 添加工具jar httpclient , pull  opengl
 
将Java 游戏或者j2me程序移植到Android平台的过程中，
Android  SDK 与java SDK的区别是很需要注意的地方。
sampleDataAdpter("YY-MM-DD") 
27.Android中Task任务栈的分配


首先我们来看下Task的定义，Google是这样定义Task的：a task is what the user experiences as an "application." It's a group of related activities, arranged in a stack. A task is a stack of activities, not a class or an element in the manifest file. 这意思就是说Task实际上是一个Activity栈，通常用户感受的一个Application就是一个Task。从这个定义来看，Task跟Service或者其他Components是没有任何联系的，它只是针对Activity而言的。
Activity有不同的启动模式, 可以影响到task的分配
Task，简单的说，就是一组以栈的模式聚集在一起的Activity组件集合。它们有潜在的前后驱关联，新加入的Activity组件，位于栈顶，并仅有在栈顶的Activity，才会有机会与用户进行交互。而当栈顶的Activity完成使命退出的时候，Task会将其退栈，并让下一个将跑到栈顶的Activity来于用户面对面，直至栈中再无更多Activity，Task结束。

事件 Task栈（粗体为栈顶组件） 
点开Email应用，进入收件箱（Activity A） A 
选中一封邮件，点击查看详情（Activity B） AB 
点击回复，开始写新邮件（Activity C） ABC 
写了几行字，点击选择联系人，进入选择联系人界面（Activity D） ABCD 
选择好了联系人，继续写邮件 ABC 
写好邮件，发送完成，回到原始邮件 AB 
点击返回，回到收件箱 A 
退出Email程序 null 
 
如上表所示，是一个实例。从用户从进入邮箱开始，到回复完成，退出应用整个过程的Task栈变化。这是一个标准的栈模式，对于大部分的状况，这样的Task模型，足以应付，但是，涉及到实际的性能、开销等问题，就会变得残酷许多。
 
比如，启动一个浏览器，在Android中是一个比较沉重的过程，它需要做很多初始化的工作，并且会有不小的内存开销。但与此同时，用浏览器打开一些内容，又是一般应用都会有的一个需求。设想一下，如果同时有十个运行着的应用（就会对应着是多个Task），都需要启动浏览器，这将是一个多么残酷的场面，十个Task栈都堆积着很雷同的浏览器Activity，
是多么华丽的一种浪费啊。
于是你会有这样一种设想，浏览器Activity，可不可以作为一个单独的Task而存在，不管是来自那个Task的请求，浏览器的Task，都不会归并过去。这样，虽然浏览器Activity本身需要维系的状态更多了，但整体的开销将大大的减少，这种舍小家为大家的行为，还是很值得歌颂的
standard", "singleTop", "singleTask", "singleInstance"。
 
standard模式， 是默认的也是标准的Task模式，在没有其他因素的影响下，使用此模式的Activity，会构造一个Activity的实例，加入到调用者的Task栈中去，对于使用频度一般开销一般什么都一般的Activity而言，standard模式无疑是最合适的，因为它逻辑简单条理清晰，所以是默认的选择。
 
而singleTop模式，基本上于standard一致，仅在请求的Activity正好位于栈顶时，有所区别。此时，配置成singleTop的Activity，不再会构造新的实例加入到Task栈中，而是将新来的Intent发送到栈顶Activity中，栈顶的Activity可以通过重载onNewIntent来处理新的Intent（当然，也可以无视...）。这个模式，降低了位于栈顶时的一些重复开销，更避免了一些奇异的行为（想象一下，如果在栈顶连续几个都是同样的Activity，再一级级退出的时候，这是怎么样的用户体验...），很适合一些会有更新的列表Activity展示。一个活生生的实例是，在Android默认提供的应用中，浏览器（Browser）的书签Activity（BrowserBookmarkPage），就用的是singleTop。
 
singleTask，和singleInstance，则都采取的另辟Task的蹊径。
标志为singleTask的Activity，最多仅有一个实例存在，并且，位于以它为根的Task中。所有对该Activity的请求，都会跳到该Activity的Task中展开进行。singleTask，很象概念中的单件模式，所有的修改都是基于一个实例，这通常用在构造成本很大，但切换成本较小的Activity中。最典型的例子，还是浏览器应用的主Activity（名为Browser...），它是展示当前tab，当前页面内容的窗口。它的构造成本大，但页面的切换还是较快的，于singleTask相配，还是挺天作之合的。
 
singleInstance显得更为极端一些。在大部分时候singleInstance与singleTask完全一致，唯一的不同在于，singleInstance的Activity，是它所在栈中仅有的一个Activity，如果涉及到的其他Activity，都移交到其他Task中进行。这使得singleInstance的Activity，像一座孤岛，彻底的黑盒，它不关注请求来自何方，也不计较后续由谁执行。在Android默认的各个应用中，很少有这样的Activity，在我个人的工程实践中，曾尝试在有道词典的快速取词Activity中采用过，
是因为我觉得快速取词入口足够方便（从notification中点选进入），并且会在各个场合使用，应该做得完全独立。
 
大的apk 拆成 很多小的apk 
  ●Activity的android:affinity属性
1.配置后 当启动这个activity时就先去找有没有activity的亲和力属性相同 有就加入这个
       activity所在的任务中没有就新开任务
2.affinity起作用需要的条件而者具备一个:
              1.intent包含FLAG_ACTIVITY_NEW_TASK标记
              2.activity元素启用了allowTaskReparenting属性. 
28.在Android中，怎么节省内存的使用，怎么主动回收内存？


  回收已经使用的资源, 
  合理的使用缓存
合理设置变量的作用范围… 
application 对象
//未来的某一段时间执行 
System.gc(); 
29.不同工程中的方法是否可以相互调用？


可以,列举aidl访问远程服务的例子. 
30.dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念  是同一概念


Dvm的进程是dalivk虚拟机进程,每个android程序都运行在自己的进程里面,
每个android程序系统都会给他分配一个单独的liunx  uid(user id),
每个dvm都是linux里面的一个进程.所以说这两个进程是一个进程. 
31.在Android中是如何实现判断区分电话的状态，去电，来电、未接来电？


Day8 showAddressService.java
TelephoneyManger.listen(); 
32.谈谈Android的优点和不足之处。


1、开放性,开源ophone  阿里云( 完全兼容android)
2、挣脱运营商束缚 
3、丰富的硬件选择 mtk android 
4、不受任何限制的开发商
5、无缝结合的Google应用
 
缺点也有5处：
1、安全问题、隐私问题 
2、卖手机的不是最大运营商
3、运营商对Android手机仍然有影响
4、山寨化严重
5、过分依赖开发商，缺乏标准配置 
33.Android系统中GC什么情况下会出现内存泄露呢?


视频编解码/内存泄露
检测内存泄露   工具 
 
导致内存泄漏主要的原因是，先前申请了内存空间而忘记了释放。如果程序中存在对无用对象的引用，那么这些对象就会驻留内存，消耗内存，因为无法让垃圾回收器GC验证这些对象是否不再需要。如果存在对象的引用，这个对象就被定义为"有效的活动"，同时不会被释放。要确定对象所占内存将被回收，我们就要务必确认该对象不再会被使用。典型的做法就是把对象数据成员设为null或者从集合中移除该对象。但当局部变量不需要时，不需明显的设为null，因为一个方法执行完毕时，这些引用会自动被清理。
Java带垃圾回收的机制,为什么还会内存泄露呢?
 
Vector v = new Vector(10);    
 for (int i = 1; i < 100; i++)      {     
　Object o = new Object();      　
v.add(o);      　
o = null;     
}//此时，所有的Object对象都没有被释放，因为变量v引用这些对象。 
 
Java 内存泄露的根本原因就是 保存了不可能再被访问的变量类型的引用 
34.Android UI中的View如何刷新。


在主线程中  拿到view调用Invalide()方法,查看画画板里面更新imageview的方法
 
在子线程里面可以通过postInvalide()方法; 
35. 简单描述下Android 数字签名。


Android 数字签名
       在Android系统中，所有安装到系统的应用程序都必有一个数字证书，此数字证书用于标识应用程序的作者和在应用程序之间建立信任关系 
Android系统要求每一个安装进系统的应用程序都是经过数字证书签名的，数字证书的私钥则保存在程序开发者的手中。Android将数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。
这个数字证书并不需要权威的数字证书签名机构认证(CA)，它只是用来让应用程序包自我认证的。
同一个开发者的多个程序尽可能使用同一个数字证书，这可以带来以下好处。
(1)有利于程序升级，当新版程序和旧版程序的数字证书相同时，Android系统才会认为这两个程序是同一个程序的不同版本。如果新版程序和旧版程序的数字证书不相同，则Android系统认为他们是不同的程序，并产生冲突，会要求新程序更改包名。
 
(2)有利于程序的模块化设计和开发。Android系统允许拥有同一个数字签名的程序运行在一个进程中，Android程序会将他们视为同一个程序。所以开发者可以将自己的程序分模块开发，而用户只需要在需要的时候下载适当的模块。
在签名时，需要考虑数字证书的有效期：
(1)数字证书的有效期要包含程序的预计生命周期，一旦数字证书失效，持有改数字证书的程序将不能正常升级。
(2)如果多个程序使用同一个数字证书，则该数字证书的有效期要包含所有程序的预计生命周期。
(3)Android Market强制要求所有应用程序数字证书的有效期要持续到2033年10月22日以后。 
Android数字证书包含以下几个要点：
 (1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序
 (2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证
 (3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。
 (4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。 
36.android中的动画有哪几类，它们的特点和区别是什么？


两种，一种是Tween动画、还有一种是Frame动画。
Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化；
可以通过布局文件,可以通过代码
  1、  控制View的动画 
a)     alpha(AlphaAnimation)
渐变透明     
b)     scale(ScaleAnimation)
渐变尺寸伸缩 
c)     translate(TranslateAnimation)
画面转换、位置移动   
d)     rotate(RotateAnimation)
画面转移，旋转动画   
 
2、    控制一个Layout里面子View的动画效果
a)     layoutAnimation(LayoutAnimationController)
b)     gridAnimation(GridLayoutAnimationController)
另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。 
37.说说mvc模式的原理，它在android中的运用


Android中没有mvc，只有在j2ee中有，是用于逻辑也界面分离的
MVC英文即Model-View-Controller，即把一个应用的输入、处理、输出流程按照Model、View、Controller的方式进行分离，这样一个应用被分成三个层――模型层、视图层、控制层。
 
Android中界面部分也采用了当前比较流行的MVC框架，在Android中M就是应用程序中二进制的数据，V就是用户的界面。Android的界面直接采用XML文件保存的，界面开发变的很方便。在Android中C也是很简单的，一个Activity可以有多个界面，只需要将视图的ID传递到setContentView()，就指定了以哪个视图模型显示数据。
 
 
在Android SDK中的数据绑定，也都是采用了与MVC框架类似的方法来显示数据。在控制层上将数据按照视图模型的要求（也就是Android SDK中的Adapter）封装就可以直接在视图模型上显示了，从而实现了数据绑定。比如显示Cursor中所有数据的ListActivity，其视图层就是一个ListView，将数据封装为ListAdapter，并传递给ListView，数据就在ListView中显示。 
38.通过点击一个网页上的url 就可以完成程序的自动安装,描述下原理


Day11 AddJavascriptInterface
new Object{
       callphone();
       installapk();
}

将js与java相互调用再来一个例子，解决相互调用之间的关系。

首先说明一重要代码的情况：

android中的关键代码：
webview.getSettings().setJavaScriptEnabled(true);
webview.addJavascriptInterface(object,"name"); //把Name="name"的对象添加到object中。object如果是this，就是window.name
webview.loadUrl("file:///android_asset/index.html"); //注意这个资源的位置放在assets文件夹下。


js或html中调用android中方法代码：
js中使用 window.name.java中的方法()；
android中调用js的function方法：
         Callfunction(){
         webview.loadUrl("JavaScript: function ()");
需要注意的地方，很多数据类型js中不认识，最好是在android那边封装好，提供必要的方法接口。比如传到js中的list，在js中是没办法去得到里面的元素的。
addJavascriptInterface：addJavascriptInterface方法中要绑定的Java对象及方法要运行在另外的线程中，不能运行在构造他的线程中，也就是说不能运行在当前的activity线程中，就是把这个方法绑定到页面中，js也可以调用。
文档中的解释：
Use this function to bind an object to javascript so that the methods can be accessed from Javascript.
The Java object that is bound runs in another thread and not in the thread that it was constructed in.

下面给出具体的测试代码：
1、Activity 代码

[java] view plaincopyprint?
public class TestWebView extends Activity {  
    private WebView mWebView;  
    private List<String> list;  
    private int mkeyCode;  
  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
        mWebView = (WebView) findViewById(R.id.htmlview);  
  
        initData();  
          
        WebSettings webSettings = mWebView.getSettings();  
          
        // 是否允许在webview中执行javascript  
        webSettings.setJavaScriptEnabled(true);  
          
        mWebView.addJavascriptInterface(this, "javatojs");  
  
        //加载网页  
        mWebView.loadUrl("file:///android_asset/index.html");  
    }  
      
    @Override  
    public boolean onKeyUp(int keyCode, KeyEvent event) {  
        mkeyCode = keyCode;  
        Log.i("AA","keyCode="+keyCode);  
        mWebView.loadUrl("javascript: OnKeyUp()");  
        return super.onKeyUp(keyCode, event);  
    }  
      
    public int getKeyCode(){  
        return mkeyCode;  
    }  
      
    void initData() {  
        list = new ArrayList<String>();  
        for (int i = 0; i < 5; i++) {  
            list.add("我是List中的第" + (i + 1) + "行");  
        }  
    }  
      
    /** 
     * 该方法将在js脚本中，通过window.javatojs.....()进行调用 
     *  
     * @return 
     */  
    public Object getObject(int index) {  
        Log.i("A","getObject");       
        return list.get(index);  
    }  
  
    public int getSize() {  
        Log.i("A","getSize");  
        return list.size();  
    }  
  
    public void Callfunction() {  
        Log.i("A","Callfunction");  
        mWebView.loadUrl("javascript: GetList()");  
    }  
      
    public void printStr(String str){  
        Log.i("A","GetList:" + str);  
    }     
}  
    2、js 代码 index.html


[javascript] view plaincopyprint?
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">  
<html>  
  
<head>  
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  
  
<title>demotitle></title>  
  
<script language="javascript">   
  
function GetList(){  
    var i=window.javatojs.getSize();  
  
    for(var n=0;n<i;n++){  
        var jsdata= window.javatojs.getObject(n);//拿到activity里面的属性javadata  
        window.javatojs.printStr("test");  
    }  
}  
  
function OnKeyUp() {  
    var keycode = window.javatojs.getKeyCode();  
    window.javatojs.printStr(keycode);  
}  
  
</script>  
</head>  
  
 <body style="background-color:#000;">  
  <table width="400" align="center"><tr><td>  
  <p> </p>  
  <p>  
<table width="400" align="center">  
<div id="output" >test</div>  
    <input type="submit" value="buttons"  
    onclick="document.getElementById('output').innerHTML=window.javatojs.Callfunction()"/>  
  <br>  
  
  </p>  
  </td></tr></table>  
</body>  
  
</html>  
以上代码主要测试js与java相互调用，而由于按键这种系统事件被webview截获掉，有如下两种方式进行处理

1、把方向键的流程改成：先传给webcore，假如没处理，再在webview里面处理，这个需要修改webview.java代码
2、直接应用搞定，java捕获按键，然后调js函数，上面代码就是使用这种方法。

测试结果如下： 点击buttons按钮：
I/A       ( 4990): Callfunction
I/A       ( 4990): getSize
I/A       ( 4990): getObject
I/A       ( 4990): GetList:test
I/A       ( 4990): getObject
I/A       ( 4990): GetList:test
I/A       ( 4990): getObject
I/A       ( 4990): GetList:test
I/A       ( 4990): getObject
I/A       ( 4990): GetList:test
I/A       ( 4990): getObject
I/A       ( 4990): GetList:test

you press KEY_RIGHT
I/AA      ( 4990): keyCode=22
I/A       ( 4990): GetList:22

you press KEY_UP
I/AA      ( 4990): keyCode=19
I/A       ( 4990): GetList:19

you press KEY_DOWN
I/AA      ( 4990): keyCode=20
I/A       ( 4990): GetList:20

you press KEY_LEFT
I/AA      ( 4990): keyCode=21
I/A       ( 4990): GetList:21

这里为何使用这种方式，是因为对于上下左右及确定这种功能键被webview截取掉了，无法传递到webcore中，而只能重载OnKeyDown/OnKeyUp方法，再由js调用java方法来获取得。
对于数字键的处理可以直接在js中进行处理：
logcat中会有明显的打印，对于这些键没有截掉，所以可以直接获取得到：
D/webcore ( 4990): proc key: code=12
D/webcore ( 4990): proc key: nativeKey return false
D/webcore ( 4990): proc key: nativeKey return true
js代码可以如此编写：

[javascript] view plaincopyprint?
 <script language="JavaScript">  
  
document.onkeypress = grab_keypress_event;  
document.onirkeypress = grab_irkeypress_event;  
document.onsystemevent = grab_system_event;  
document.onkeydown = grab_keydown_event;  
document.onkeyup = grab_keyup_event;  
  
function init()  
{  
    document.getElementById("txt_keypress").innerHTML = "";  
    document.getElementById("txt_irkey").innerHTML= "";  
    document.getElementById("txt_systemevent").innerHTML="";  
    document.getElementById("txt_keydown").innerHTML="";  
    document.getElementById("txt_keyup").innerHTML="";  
}  
  
function grab_keypress_event(event)  
{  
    var keycode = event.keyCode;  
    document.getElementById("txt_keypress").innerHTML=keycode;  
}  
  
function grab_irkeypress_event(event)  
{  
    var keycode = event.keyCode;  
    document.getElementById("txt_irkey").innerHTML=keycode;  
}  
  
function grab_system_event(event)  
{  
    var keycode = event.which;  
    document.getElementById("txt_systemevent").innerHTML=keycode;  
}  
  
function grab_keydown_event(event)  
{  
    var keycode = event.keyCode;  
    var type = event.type;  
    var mod = event.modifiers;  
    document.getElementById("txt_keydown").innerHTML=keycode;  
}  
  
function grab_keyup_event(event)  
{  
    var keycode = event.keyCode;  
    document.getElementById("txt_keyup").innerHTML=keycode;  
}  
 </script>  
 
39.Service和Activity在同一个线程吗


默认情况同一线程 main主线程 ui线程 
40.ViewStub的应用


  在开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。
      推荐的做法是使用android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。
      但ViewStub也不是万能的，下面总结下ViewStub能做的事儿和什么时候该用ViewStub，什么时候该用可见性的控制。
     首先来说说ViewStub的一些特点：
         1. ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。
         2. ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。
     基于以上的特点，那么可以考虑使用ViewStub的情况有：
         1. 在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。
              因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要在运行时不止一次的显示和隐藏某个布局，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。
         2. 想要控制显示与隐藏的是一个布局文件，而非某个View。
              因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。
     所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。
下面来看一个实例
在这个例子中，要显示二种不同的布局，一个是用TextView显示一段文字，另一个则是用ImageView显示一个图片。这二个是在onCreate()时决定是显示哪一个，这里就是应用ViewStub的最佳地点。
先来看看布局，一个是主布局，里面只定义二个ViewStub，一个用来控制TextView一个用来控制ImageView，另外就是一个是为显示文字的做的TextView布局，一个是为ImageView而做的布局：

[html] view plaincopyprint?
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout  
  xmlns:android="http://schemas.android.com/apk/res/android"  
  android:orientation="vertical"  
  android:layout_width="fill_parent"  
  android:layout_height="fill_parent"  
  android:gravity="center_horizontal"]] >   
  <ViewStub   
    android:id="@+id/viewstub_demo_text"  
    android:layout_width="wrap_content"  
    android:layout_height="wrap_content"  
    android:layout_marginLeft="5dip"  
    android:layout_marginRight="5dip"  
    android:layout_marginTop="10dip"  
    android:layout="@layout/viewstub_demo_text_layout"/>  
  <ViewStub   
    android:id="@+id/viewstub_demo_image"  
    android:layout_width="wrap_content"  
    android:layout_height="wrap_content"  
    android:layout_marginLeft="5dip"  
    android:layout_marginRight="5dip"  
    android:layout="@layout/viewstub_demo_image_layout"/>  
</LinearLayout]] >   
为TextView的布局：


[html] view plaincopyprint?
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout  
  xmlns:android="http://schemas.android.com/apk/res/android"  
  android:orientation="vertical"  
  android:layout_width="wrap_content"  
  android:layout_height="wrap_content"]] >   
    <TextView  
        android:id="@+id/viewstub_demo_textview"  
        android:layout_width="fill_parent"  
        android:layout_height="wrap_content"  
        android:background="#aa664411"  
        android:textSize="16sp"/>  
</LinearLayout]] >   
为ImageView的布局：


[html] view plaincopyprint?
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout  
  xmlns:android="http://schemas.android.com/apk/res/android"  
  android:orientation="vertical"  
  android:layout_width="wrap_content"  
  android:layout_height="wrap_content"]] >   
    <ImageView  
        android:id="@+id/viewstub_demo_imageview"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"/>  
</LinearLayout]] >   
下面来看代码，决定来显示哪一个，只需要找到相应的ViewStub然后调用其infalte()就可以获得相应想要的布局：


[java] view plaincopyprint?
package com.effective;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.view.ViewStub;  
import android.widget.ImageView;  
import android.widget.TextView;  
  
public class ViewStubDemoActivity extends Activity {  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.viewstub_demo_activity);  
        if ((((int) (Math.random() * 100)) & 0x01) == 0) {  
            // to show text  
            // all you have to do is inflate the ViewStub for textview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_text);  
            stub.inflate();  
            TextView text = (TextView) findViewById(R.id.viewstub_demo_textview);  
            text.setText("The tree of liberty must be refreshed from time to time" +  
                    " with the blood of patroits and tyrants! Freedom is nothing but " +  
                    "a chance to be better!");  
        } else {  
            // to show image  
            // all you have to do is inflate the ViewStub for imageview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_image);  
            stub.inflate();  
            ImageView image = (ImageView) findViewById(R.id.viewstub_demo_imageview);  
            image.setImageResource(R.drawable.happy_running_dog);  
        }  
    }  
}  
运行结果：


使用的时候的注意事项：
1. 某些布局属性要加在ViewStub而不是实际的布局上面，才会起作用，比如上面用的android:layout_margin*系列属性，如果加在TextView上面，则不会起作用，需要放在它的ViewStub上面才会起作用。而ViewStub的属性在inflate()后会都传给相应的布局。
 
41.android开发中怎么去调试bug


逻辑错误 
1.断点 debug 
2. logcat ,
界面布局,显示 hierarchyviewer.bat 
42.书写出android工程的目录结构以及相关作用


下面是HelloAndroid项目在eclipse中的目录层次结构：

由上图可以看出项目的根目录下共有九个文件（夹），下面就这九个文件（夹）进行详解：
1.1src文件夹和assets文件夹：
每个Android程序都包含资源目录（src）和资产目录（assets），资源和资产听起来感觉没有多大差别，但在存储外部内容时用资源（src）比较多，其中它们的区别在于存放在资源（src）下的内容可以通过应用程序的R类进行访问，而存放在资产（assets）下的内容会保持原始文件的格式，如果需要访问，则必须使用AssetManager以字节流的方式来读取，用起来非常的不方便。为了方便使用，通常文件和数据都会保存在资源（src）目录下
1.2res(Resource)目录：资源目录
可以存放一些图标，界面文件和应用中用到的文字信息，下图为res目录截图:
1.2.1 drawable-*dpi文件夹:将图标按分辨率的高低放入不同的目录，其中draeable-hdpi用来存放高分辨率的图标，drawable-mdpi用来存放中等分辨率的图标，drawable-ldpi用来存放低分辨率的图标
1.2.2 values文件夹：用来存放文字的信息
（1）strings.xml:用来定义字符串和数值
<?xml version="1.0"encoding="utf-8"?>
<resources>
 
    <string name="hello">Hello World, Hello 3G</string>
    <string name="app_name">Android1.1</string>
        <string name="test">哥想你了</string>
        <string name="startButton">按钮1</string>
        <string name="start">按钮1</string> 
</resources>
每个string标签生命了一个字符串，name属性指定它的引用值
（2）为什么要把这些出现的文字单独放在strings.xml文件中？
答案：一是为了国际化，如果需要将文件中的文字换成别的国家的语言，就可以只需要替换掉一个strings.xml文件就可以了
二是为了减少应用的体积，例如，我们要在应用中使用“哥想你了”这句话1000次，如果我们没有将“哥想你了”定义在strings.xml文件中，而是直接在应用中使用时写上这几个字，那么我们就会在应用中写4000个字。4000个字和4个字占用的内存可是有很大差距的啊，况且手机的内存本来就小，所以应该是能省就省
（3）另外还有arrays.xml,color.xml等定义数组，颜色的，都最好用单独的一个xml文档
1.2.3 layout文件：用来存放界面信息
本例中的布局文件是自动生成的“main.xml”
<?xml version="1.0"encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical">
 
    <TextView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"/>
   
</LinearLayout>
<LinearLayout>元素：线性布局的意思，在该元素下的所有子元素都会根据他的”orientation”属性来决定是按行还是按列或者按逐个显示进行布局的
<TextView>元素：是一种显示控件，他的”text”属性指定了在这个元素上显示的内容
1.3 gen目录：gen目录下只有一个自动生成的“R.java”文件
/*AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated bythe
 * aapt tool from the resource data itfound.  It
 * should not be modified by hand.
 */
 
packagecn.csdn.android.demo;
 
public final class R {
    public static final class attr {
    }
    public static final class drawable {
        public static final int ic_launcher=0x7f020000;
    }
    public static final class id {
        public static final int button1=0x7f050000;
        public static final int radioButton1=0x7f050001;
        public static final int toggleButton1=0x7f050002;
    }
    public static final class layout {
        public static final int main=0x7f030000;
    }
    public static final class string {
        public static final int app_name=0x7f040001;
        public static final int hello=0x7f040000;
        public static final int start=0x7f040004;
        public static final int startButton=0x7f040003;
        public static final int test=0x7f040002;
    }
}
 
R.java文件：默认有attr,drawable,layout,string这四个静态内部类，每个静态内部类对应一中资源，如layout静态内部类对应layout中的界面文件，string静态内部类对应string内部的string标签。如果在layout中在增加一个界面文件或者在string内增加一个string标签，R.java会自动在其对应的内部类增加所增加的内容。
R.java除了自动标识资源的索引功能外，还有另一个功能，就是当res文件中的某个资源在应用中没有被用到，在这个应用被编译时，系统不会把对应的资源编译到应用中的APR包中。
1.4 AndroidManifest.xml 功能清单文件
每个应用程序都会有一个AndroidManifest在它的根目录里面。这个清单为Android系统提供了这个应用的基本信息，系统在运行之前必须知道这些信息，另外，如果我们使用系统自带的服务，如拨号服务，应用安装服务等，都必须在AndroidManifest.xml文件中声明权限
AndroidManifest.xml的功能：
命名应用程序的Java应用包，这个包名用来唯一标识应用程序；
描述应用程序的组件，对实现每个组件和公布其功能的类进行命名，这些声明使得Android系统了解这些组件以及它们在什么条件下可以被启动
决定哪个组件运行在哪个进程里面
声明应用程序必须具备的权限，用以访问受保护的API，以及和其他进程的交互
声明应用程序其他的必备权限，用以组件之间的交互
列举application所需要链接的库
以HelloAndroid项目的功能清单为例子进行讲解：
<?xml version="1.0"encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="cn.csdn.android.demo"
    android:versionCode="1"
    android:versionName="1.0">
 
    <uses-sdk android:minSdkVersion="8"/>
 
    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name">
        <activity
            android:label="@string/app_name"
            android:name=".HelloActivity">
            <intent-filter >
                <action android:name="android.intent.action.MAIN" />
 
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
1.4.1 <manifest>元素
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="cn.csdn.android.demo"
    android:versionCode="1"
    android:versionName="1.0">
<manifest>元素是AndroidManifest.xml的根元素,”xmlns:android”是指该文件的命名空间，“package”属性是Android应用所在的包，“android:versionCode”指定应用的版本号，如果应用不断升级，则需要修改这个值，”android:versionName”是版本的名称，这个可以根据自己的喜爱改变
1.4.2 <application> 元素
<application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name">
        <activity
            android:label="@string/app_name"
            android:name=".HelloActivity">
            <intent-filter >
                <action android:name="android.intent.action.MAIN"/>
 
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
<application>元素是一个很重要的元素，开发组件都会在此下定义
<application>元素的”icon”属性是用来设定应用的图标，其中“@drawable/ic_launcher”的意思是:在R.java文件中的drawable静态内部类下的icon，如下图所示
<application>元素的“label”属性用来设定应用的名称，其中“@string/app_name”和上述的一样，也是R.java文件中的string静态内部类下的app_name
1.4.3 <activity>元素
<activity
            android:label="@string/app_name"
           android:name=".HelloActivity" >
            <intent-filter >
                <action android:name="android.intent.action.MAIN" />
 
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
<activity>元素的作用是注册一个activity信息，当我们在创建“HelloAndroid”这个项目时，指定了“Created Activity”属性为“HelloActivity”，然后ADT在生成项目时帮我们自动创建了一个Activity，就是“HelloActivity.java”；
<activity>元素的“name“属性指定的是Activity的类名，其中“.HelloActivity”中的“.”指的是<manifest>元素中的“package”属性中指定的当前包，所以“.HelloActivity”就相当于“cn.csdn.android.demo.HelloActivity.java”，如果Activity在应用的包中可以不写“.”，但是为了避免出错，还是写上这个点把
1.4.4<intent-filter>元素
<intent-filter >
                <action android:name="android.intent.action.MAIN" />
 
                <category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
<intent-filter>如果直接翻译的话是“意图过滤器”，组件通过<intent-filter>告诉它们所具备的功能，就是能响应意图类型，在intent中设置action, data, categroy之后在对应的intentfilter中设置相同的属性即可通过过滤被activity调用
1.5<project.properties>应用要求运行的最低Android版本
1.6<android 2.2>  存放Android自身的jar包  
43.ddms 和traceview的区别.


 daivilk debug manager system
1.在应用的主activity的onCreate方法中加入Debug.startMethodTracing("要生成的traceview文件的名字");
2.同样在主activity的onStop方法中加入Debug.stopMethodTracing();
3.同时要在AndroidManifest.xml文件中配置权限
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
3.重新编译，安装，启动服务，测试完成取对应的traceview文件(adb pull /sdcard/xxxx.trace)。
4.直接在命令行输入traceview xxxxtrace，弹出traceview窗口，分析对应的应用即可。
 
traceview 分析程序执行时间和效率
 
KPI : key performance information : 关键性能指标:
 splash界面不能超过5秒
 从splash 界面加载mainactivity 不能超过0.7秒  
44.谈谈NDK

NDK全称：Native Development Kit。
1、NDK是一系列工具的集合。
* NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。[1] 
* NDK集成了交叉编译器，并提供了相应的mk文件隔离平台、CPU、API等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。
* NDK可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作。
2、NDK提供了一份稳定、功能有限的API头文件声明。
Google明确声明该API是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK中看出，这些API支持的功能非常有限，包含有：C标准库（libc）、标准数学库（libm）、压缩库（libz）、Log库（liblog）。  

45.请介绍下Android的数据存储方式。


一.SharedPreferences方式
二sdcard
三内部存储
四SqliteDatabase
　　五. 网络存储方式 
46.谈谈推送,优缺点以及实现原理


本文主旨在于，对目前Android平台上最主流的几种消息推送方案进行分析和对比，比较客观地反映出这些推送方案的优缺点，帮助大家选择最合适的实施方案。

方案1、使用GCM服务（Google Cloud Messaging）
简介：Google推出的云消息服务，即第二代的C2DM。
优点：Google提供的服务、原生、简单，无需实现和部署服务端。
缺点：Android版本限制（必须大于2.2版本），该服务在国内不够稳定、需要用户绑定Google帐号，受限于Google。

方案2、使用XMPP协议（Openfire + Spark + Smack）
简介：基于XML协议的通讯协议，前身是Jabber，目前已由IETF国际标准化组织完成了标准化工作。
优点：协议成熟、强大、可扩展性强、目前主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。
缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。

方案3、使用MQTT协议（更多信息见：http://mqtt.org/）
简介：轻量级的、基于代理的“发布/订阅”模式的消息传输协议。
优点：协议简洁、小巧、可扩展性强、省流量、省电，目前已经应用到企业领域（参考：http://mqtt.org/software），且已有C++版的服务端组件rsmb。
缺点：不够成熟、实现较复杂、服务端组件rsmb不开源，部署硬件成本较高。

方案4、使用HTTP轮循方式
简介：定时向HTTP服务端接口（Web Service API）获取最新消息。
优点：实现简单、可控性强，部署硬件成本低。
缺点：实时性差。

对各个方案的优缺点的研究和对比，推荐使用MQTT协议的方案进行实现，主要原因是：MQTT最快速，也最省流量（固定头长度仅为2字节），且极易扩展，适合二次开发。接下来，我们就来分析使用MQTT方案进行Android消息的原理和方法，并架设自己的推送服务。
1、推送原理分析



实际上，其他推送系统（包括GCM、XMPP方案）的原理都与此类似。

2、推送服务端准备

a> 下载&解压rsmb安装包（下载地址：http://www.alphaworks.ibm.com/tech/rsmb）
b> 进入对应的目录，比如32位的Linux系统则应该进入linux_ia32目录。
c> 编辑配置文件broker_1883.cfg，配置如下：

[html] view plaincopy
port 1883  
max_inflight_messages 10  
max_queued_messages 1000  
d> 运行./broker broker_1883.cfg，显示如下：
20120823 110454.039 CWNAN9999I Really Small Message Broker
20120823 110454.039 CWNAN9997I Licensed Materials - Property of IBM
20120823 110454.039 CWNAN9996I Copyright IBM Corp. 2007, 2010 All Rights Reserved
20120823 110454.039 CWNAN9995I US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
20120823 110454.039 CWNAN0049I Configuration file name is broker_1883.cfg
20120823 110454.040 CWNAN0053I Version 1.2.0, Aug 18 2010 17:03:35
20120823 110454.040 CWNAN0054I Features included: bridge
20120823 110454.040 CWNAN9993I Author: Ian Craggs (icraggs@uk.ibm.com)
20120823 110454.040 CWNAN0014I MQTT protocol starting, listening on port 1883
... ...
这样，推送服务的服务端就已经准备好了，监听1883端口。

3、推送客户端准备

a> 下载&解压AndroidPushNotificationsDemo项目（下载地址：https://github.com/tokudu/AndroidPushNotificationsDemo）
b> 将该项目导入Eclipse中（File -> Export -> Existing Projects into Workspace）
c> 修改PushService.java中的MQTT_HOST常量为推送服务端的IP地址。
d> 启动Android模拟器，并安装该项目。

注意：在新版本的Android SDK中可能会遇到以下错误。
... ...
08-23 02:28:44.184: W/dalvikvm(282): VFY: unable to find class referenced in signature (Lcom/ibm/mqtt/MqttPersistence;)
08-23 02:28:44.194: I/dalvikvm(282): Failed resolving Lcom/tokudu/demo/PushService$MQTTConnection; interface 35 'Lcom/ibm/mqtt/MqttSimpleCallback;'
08-23 02:28:44.194: W/dalvikvm(282): Link of class 'Lcom/tokudu/demo/PushService$MQTTConnection;' failed
08-23 02:28:44.194: E/dalvikvm(282): Could not find class 'com.tokudu.demo.PushService$MQTTConnection', referenced from method com.tokudu.demo.PushService.connect
08-23 02:28:44.194: W/dalvikvm(282): VFY: unable to resolve new-instance 42 (Lcom/tokudu/demo/PushService$MQTTConnection;) in Lcom/tokudu/demo/PushService;
... ...
08-23 02:28:44.404: E/AndroidRuntime(282): java.lang.VerifyError: com.tokudu.demo.PushService
08-23 02:28:44.404: E/AndroidRuntime(282):     at com.tokudu.demo.PushActivity$1.onClick(PushActivity.java:32)
08-23 02:28:44.404: E/AndroidRuntime(282):     at android.view.View.performClick(View.java:2408)
08-23 02:28:44.404: E/AndroidRuntime(282):     at android.view.View$PerformClick.run(View.java:8816)
08-23 02:28:44.404: E/AndroidRuntime(282):     at android.os.Handler.handleCallback(Handler.java:587)
08-23 02:28:44.404: E/AndroidRuntime(282):     at android.os.Handler.dispatchMessage(Handler.java:92)
08-23 02:28:44.404: E/AndroidRuntime(282):     at android.os.Looper.loop(Looper.java:123)
08-23 02:28:44.404: E/AndroidRuntime(282):     at android.app.ActivityThread.main(ActivityThread.java:4627)
08-23 02:28:44.404: E/AndroidRuntime(282):     at java.lang.reflect.Method.invokeNative(Native Method)
08-23 02:28:44.404: E/AndroidRuntime(282):     at java.lang.reflect.Method.invoke(Method.java:521)
08-23 02:28:44.404: E/AndroidRuntime(282):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:868)
08-23 02:28:44.404: E/AndroidRuntime(282):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:626)
08-23 02:28:44.404: E/AndroidRuntime(282):     at dalvik.system.NativeStart.main(Native Method)
... ...
原因是发布的时候没有加入wmqtt.jar包，解决办法如下：
1> 在项目根目录下创建libs目录，并把wmqtt.jar包移入该目录。
2> 重新配置项目的Java Build Path（右键菜单中的Properties选项中）。
3> 重新打包发布即可。

运行效果如下：



点击“Start Push Service”按钮即可开启推送服务。这时我们可以看到rsmb的服务日志中打出以下提示：
20120823 113742.297 CWNAN0033I Connection attempt to listener 1883 received from client tokudu/9774d56d682e549c on address 192.168.28.39:3345
其中的“9774d56d682e549c”就是对应的客户端ID号。

4、发送服务准备

a> 下载&解压PHP版的发送服务端代码send_mqtt.zip（下载地址：http://download.csdn.Net/detail/shagoo/4520102）
b> 修改etc/config.php中推送服务端的IP地址和端口号，即MQTT_SERVER_HOST和MQTT_SERVER_POST常量。
c> 打开对应的URL地址，就可以看到发送服务的界面，实际上就是向对应的推送客户端推送消息。 
47.谈谈数据加密


数据加密又称密码学，它是一门历史悠久的技术，指通过加密算法和加密密钥将明文转变为密文，而解密则是通过解密算法和解密密钥将密文恢复为明文。数据加密目前仍是计算机系统对信息进行保护的一种最可靠的办法。它利用密码技术对信息进行加密，实现信息隐蔽，从而起到保护信息的安全的作用。用自己的话来说就是，只有双方才知道的协议。
数据加密 - 密码算法分类
1按发展进程分密码的发展:古典密码,对称密钥 密码公开密钥密码.
2按加密模式分对称算法:序列密码和分组密码.
经典密码 代替密码: 简单代替多名或同音代替多表代替多字母或多码代替换位密码: ?对称加密算法 DES AES ?非对称公钥算法 RSA 背包密码McEliece密码Rabin 椭圆曲线EIGamal D_H  
48.解决问题和思考问题的方式


首先查看官方提供的API，通过自己对功能的理解，然后通过网络的途径，下载demo可以选择 github ，查找问题可以选择 stackover flow，然后可以问身边的朋友。 
49.列举7到12个设计模式  以及它们的应用场景


设计模式，提供了很多软件工程问题所需处理的解决方案。
根据模式的目的可分为3类： 1.创建型模式：与对象的创建有关。 2.结构性模式：处理类与对象的组合。 3.行为性模式：对类或对象怎样交互和怎样 分配职责进行描述。
面向对象设计的2个基本原则: 1.针对接口编程，而不是针对实现编程。 2.优先使用对象组合，而不是类继承。 
面向对象设计的5个设计原则： 1.单一职责原则(SRP) 2.开放封闭原则(OCP)  3.Liskov替换原则(LSP) 4.依赖倒置原则(DIP) 5.接口隔离原则(ISP) 
23中设计模式： 1.创建型模式： (1).工厂方法模式 (2).抽象工厂模式 (3).创建者模式 (4).原型模式 (5).单例模式 2.结构型模式： (6).适配器模式 (7).桥模式 (8).组合模式 (9).装饰模式 (10).外观模式 (11).享元模式 (12).代理模式 3.行为型模式 (13).解释器模式 (14).模板方法模式 (15).职责链模式 (16).命令模式 (17).迭代器模式 (18).中介者模式 (19).备忘录模式 (20).观察者模式 (21).状态模式 (22).策略模式 (23).访问者模式  除此之外，后来人发现很多新的模式，如空模式等。
下面列举几个常见的问题导致重新设计，可能需要设计模式来分析解决： 1.通过显示的指定一个类来创建对象 2.对特殊操作的依赖 3.对硬件和软件平台的依赖 4.对对象表示或实现的依赖 5.算法依赖 6.紧耦合 7.通过生产子类来扩展功能 8.不能方便的对类进行修改
软件的设计臭味： 1.僵化性 2.脆弱性 3.顽固性 4.粘滞性 5.不必要的复杂性 6.不必要的重复 7.晦涩性  ... ... 总而言之，一句话，面向对象特性+原则+模式，折腾来折腾去就是这么个回事。
 
设计模式（Design Patterns）
                                  ――可复用面向对象软件的基础
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章系Java之美[从菜鸟到高手演变]系列之设计模式，我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！
在阅读过程中有任何问题，请及时联系：egg。
邮箱：xtfggef@gmail.com 微博：http://weibo.com/xtfggef
如有转载，请说明出处：http://blog.csdn.net/zhangerqing
企业级项目实战(带源码)地址：http://zz563143188.iteye.com/blog/1825168
23种模式java实现源码及收集五年的开发资料下载地址：  http://pan.baidu.com/share/home?uk=4076915866&view=share
一、设计模式的分类
总体来说设计模式分为三大类：
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：

 
二、设计模式的六大原则
1、开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。―― From Baidu 百科
3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5、迪米特法则（最少知道原则）（Demeter Principle）
为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承。
三、Java的23中设计模式
从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。
1、工厂方法模式（Factory Method）
工厂方法模式分为三种：
11、普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：

举例如下：（我们举一个发送邮件和短信的例子）
首先，创建二者的共同接口：
[java] view plaincopy
public interface Sender {  
    public void Send();  
}  
其次，创建实现类：
[java] view plaincopy
public class MailSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println("this is mailsender!");  
    }  
}  
[java] view plaincopy
public class SmsSender implements Sender {  
  
    @Override  
    public void Send() {  
        System.out.println("this is sms sender!");  
    }  
}  
最后，建工厂类：
[java] view plaincopy
public class SendFactory {  
  
    public Sender produce(String type) {  
        if ("mail".equals(type)) {  
            return new MailSender();  
        } else if ("sms".equals(type)) {  
            return new SmsSender();  
        } else {  
            System.out.println("请输入正确的类型!");  
            return null;  
        }  
    }  
}  
我们来测试下：
public class FactoryTest {  
  
    public static void main(String[] args) {  
        SendFactory factory = new SendFactory();  
        Sender sender = factory.produce("sms");  
        sender.Send();  
    }  
}  
输出：this is sms sender!
22、多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：

将上面的代码做下修改，改动下SendFactory类就行，如下：
[java] view plaincopypublic class SendFactory {  
   public Sender produceMail(){  
        return new MailSender();  
    }  
      
    public Sender produceSms(){  
        return new SmsSender();  
    }  
}  
测试类如下：
[java] view plaincopy
public class FactoryTest {  
  
    public static void main(String[] args) {  
        SendFactory factory = new SendFactory();  
        Sender sender = factory.produceMail();  
        sender.Send();  
    }  
}  
输出：this is mailsender!
33、静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
[java] view plaincopy
public class SendFactory {  
      
    public static Sender produceMail(){  
        return new MailSender();  
    }  
      
    public static Sender produceSms(){  
        return new SmsSender();  
    }  
}  
[java] view plaincopy
public class FactoryTest {  
  
    public static void main(String[] args) {      
        Sender sender = SendFactory.produceMail();  
        sender.Send();  
    }  
}  
输出：this is mailsender!
总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种――静态工厂方法模式。
2、抽象工厂模式（Abstract Factory）
工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。

请看例子：
[java] view plaincopy
public interface Sender {  
    public void Send();  
}  
两个实现类：
[java] view plaincopy
public class MailSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println("this is mailsender!");  
    }  
}  
[java] view plaincopy
public class SmsSender implements Sender {  
  
    @Override  
    public void Send() {  
        System.out.println("this is sms sender!");  
    }  
}  
两个工厂类：
[java] view plaincopy
public class SendMailFactory implements Provider {  
      
    @Override  
    public Sender produce(){  
        return new MailSender();  
    }  
}  
[java] view plaincopy
public class SendSmsFactory implements Provider{  
  
    @Override  
    public Sender produce() {  
        return new SmsSender();  
    }  
}  
在提供一个接口：
[java] view plaincopy
public interface Provider {  
    public Sender produce();  
}  
测试类：
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
        Provider provider = new SendMailFactory();  
        Sender sender = provider.produce();  
        sender.Send();  
    }  
}  
其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！
3、单例模式（Singleton）
单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：
1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。
3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。
首先我们写一个简单的单例类：
[java] view plaincopy
public class Singleton {  
  
    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */  
    private static Singleton instance = null;  
  
    /* 私有构造方法，防止被实例化 */  
    private Singleton() {  
    }  
  
    /* 静态工程方法，创建实例 */  
    public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
  
    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  
    public Object readResolve() {  
        return instance;  
    }  
}  
这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：
[java] view plaincopy
public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：
[java] view plaincopy
public static Singleton getInstance() {  
        if (instance == null) {  
            synchronized (instance) {  
                if (instance == null) {  
                    instance = new Singleton();  
                }  
            }  
        }  
        return instance;  
    }  
似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：
a>A、B线程同时进入了第一个if判断
b>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();
c>由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。
d>B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。
e>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。
所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：
[java] view plaincopy
private static class SingletonFactory{           
        private static Singleton instance = new Singleton();           
    }           
    public static Singleton getInstance(){           
        return SingletonFactory.instance;           
    }   
实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式：
[java] view plaincopy
public class Singleton {  
  
    /* 私有构造方法，防止被实例化 */  
    private Singleton() {  
    }  
  
    /* 此处使用一个内部类来维护单例 */  
    private static class SingletonFactory {  
        private static Singleton instance = new Singleton();  
    }  
  
    /* 获取实例 */  
    public static Singleton getInstance() {  
        return SingletonFactory.instance;  
    }  
  
    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  
    public Object readResolve() {  
        return getInstance();  
    }  
}  
其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的：
[java] view plaincopy
public class SingletonTest {  
  
    private static SingletonTest instance = null;  
  
    private SingletonTest() {  
    }  
  
    private static synchronized void syncInit() {  
        if (instance == null) {  
            instance = new SingletonTest();  
        }  
    }  
  
    public static SingletonTest getInstance() {  
        if (instance == null) {  
            syncInit();  
        }  
        return instance;  
    }  
}  
考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。
补充：采用"影子实例"的办法为单例对象的属性同步更新
[java] view plaincopy
public class SingletonTest {  
  
    private static SingletonTest instance = null;  
    private Vector properties = null;  
  
    public Vector getProperties() {  
        return properties;  
    }  
  
    private SingletonTest() {  
    }  
  
    private static synchronized void syncInit() {  
        if (instance == null) {  
            instance = new SingletonTest();  
        }  
    }  
  
    public static SingletonTest getInstance() {  
        if (instance == null) {  
            syncInit();  
        }  
        return instance;  
    }  
  
    public void updateProperties() {  
        SingletonTest shadow = new SingletonTest();  
        properties = shadow.getProperties();  
    }  
}  
通过单例模式的学习告诉我们：
1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。
2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。
到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？
首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）
其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。
再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。
最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！
4、建造者模式（Builder）
工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：
还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下：
[java] view plaincopy
public class Builder {  
      
    private List<Sender> list = new ArrayList<Sender>();  
      
    public void produceMailSender(int count){  
        for(int i=0; i<count; i++){  
            list.add(new MailSender());  
        }  
    }  
      
    public void produceSmsSender(int count){  
        for(int i=0; i<count; i++){  
            list.add(new SmsSender());  
        }  
    }  
}  
测试类：
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
        Builder builder = new Builder();  
        builder.produceMailSender(10);  
    }  
}  
从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。
5、原型模式（Prototype）
原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类：
[java] view plaincopy
public class Prototype implements Cloneable {  
  
    public Object clone() throws CloneNotSupportedException {  
        Prototype proto = (Prototype) super.clone();  
        return proto;  
    }  
}  
很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：
浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。
此处，写一个深浅复制的例子：
[java] view plaincopy
public class Prototype implements Cloneable, Serializable {  
  
    private static final long serialVersionUID = 1L;  
    private String string;  
  
    private SerializableObject obj;  
  
    /* 浅复制 */  
    public Object clone() throws CloneNotSupportedException {  
        Prototype proto = (Prototype) super.clone();  
        return proto;  
    }  
  
    /* 深复制 */  
    public Object deepClone() throws IOException, ClassNotFoundException {  
  
        /* 写入当前对象的二进制流 */  
        ByteArrayOutputStream bos = new ByteArrayOutputStream();  
        ObjectOutputStream oos = new ObjectOutputStream(bos);  
        oos.writeObject(this);  
  
        /* 读出二进制流产生的新对象 */  
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());  
        ObjectInputStream ois = new ObjectInputStream(bis);  
        return ois.readObject();  
    }  
  
    public String getString() {  
        return string;  
    }  
  
    public void setString(String string) {  
        this.string = string;  
    }  
  
    public SerializableObject getObj() {  
        return obj;  
    }  
  
    public void setObj(SerializableObject obj) {  
        this.obj = obj;  
    }  
  
}  
  
class SerializableObject implements Serializable {  
    private static final long serialVersionUID = 1L;  
}  
 
要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。
我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图：

 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式，先看类图：

核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：
[java] view plaincopy
public class Source {  
  
    public void method1() {  
        System.out.println("this is original method!");  
    }  
}  
[java] view plaincopy
public interface Targetable {  
  
    /* 与原类中的方法相同 */  
    public void method1();  
  
    /* 新类的方法 */  
    public void method2();  
}  
[java] view plaincopy
public class Adapter extends Source implements Targetable {  
  
    @Override  
    public void method2() {  
        System.out.println("this is the targetable method!");  
    }  
}  
Adapter类继承Source类，实现Targetable接口，下面是测试类：
[java] view plaincopy
public class AdapterTest {  
  
    public static void main(String[] args) {  
        Targetable target = new Adapter();  接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户
        target.method1();  
        target.method2();  
    }  
}  
输出：
this is original method! this is the targetable method!
这样Targetable接口的实现类就具有了Source类的功能。
对象的适配器模式
基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：

 
只需要修改Adapter类的源码即可：
[java] view plaincopy
public class Wrapper implements Targetable {  
  
    private Source source;  
      
    public Wrapper(Source source){  
        super();  
        this.source = source;  
    }  
    @Override  
    public void method2() {  
        System.out.println("this is the targetable method!");  
    }  
  
    @Override  
    public void method1() {  
        source.method1();  
    }  
}  
测试类：
[java] view plaincopy
public class AdapterTest {  
  
    public static void main(String[] args) {  
        Source source = new Source();  
        Targetable target = new Wrapper(source);  
        target.method1();  
        target.method2();  
    }  
}  
输出与第一种一样，只是适配的方法不同而已。
第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：

这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：
[java] view plaincopy
public interface Sourceable {  
      
    public void method1();  
    public void method2();  
}  
抽象类Wrapper2：
[java] view plaincopy
public abstract class Wrapper2 implements Sourceable{  
      
    public void method1(){}  
    public void method2(){}  
}  
[java] view plaincopy
public class SourceSub1 extends Wrapper2 {  
    public void method1(){  
        System.out.println("the sourceable interface's first Sub1!");  
    }  
}  
[java] view plaincopy
public class SourceSub2 extends Wrapper2 {  
    public void method2(){  
        System.out.println("the sourceable interface's second Sub2!");  
    }  
}  
[java] view plaincopy
public class WrapperTest {  
  
    public static void main(String[] args) {  
        Sourceable source1 = new SourceSub1();  
        Sourceable source2 = new SourceSub2();  
          
        source1.method1();  
        source1.method2();  
        source2.method1();  
        source2.method2();  
    }  
}  
测试输出：
the sourceable interface's first Sub1! the sourceable interface's second Sub2!
达到了我们的效果！
 讲了这么多，总结一下三种适配器模式的应用场景：
类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。
7、装饰模式（Decorator）
顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：

Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：
[java] view plaincopy
public interface Sourceable {  
    public void method();  
}  
[java] view plaincopy
public class Source implements Sourceable {  
  
    @Override  
    public void method() {  
        System.out.println("the original method!");  
    }  
}  
[java] view plaincopy
public class Decorator implements Sourceable {  
  
    private Sourceable source;  
      
    public Decorator(Sourceable source){  
        super();  
        this.source = source;  
    }  
    @Override  
    public void method() {  
        System.out.println("before decorator!");  
        source.method();  
        System.out.println("after decorator!");  
    }  
}  
测试类：
[java] view plaincopy
public class DecoratorTest {  
  
    public static void main(String[] args) {  
        Sourceable source = new Source();  
        Sourceable obj = new Decorator(source);  
        obj.method();  
    }  
}  
输出：
before decorator! the original method! after decorator!
装饰器模式的应用场景：
1、需要扩展一个类的功能。
2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
缺点：产生过多相似的对象，不易排错！
8、代理模式（Proxy）
其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：
 
根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：
[java] view plaincopy
public interface Sourceable {  
    public void method();  
}  
[java] view plaincopy
public class Source implements Sourceable {  
  
    @Override  
    public void method() {  
        System.out.println("the original method!");  
    }  
}  
[java] view plaincopy
public class Proxy implements Sourceable {  
  
    private Source source;  
    public Proxy(){  
        super();  
        this.source = new Source();  
    }  
    @Override  
    public void method() {  
        before();  
        source.method();  
        atfer();  
    }  
    private void atfer() {  
        System.out.println("after proxy!");  
    }  
    private void before() {  
        System.out.println("before proxy!");  
    }  
}  
测试类：
[java] view plaincopy
public class ProxyTest {  
  
    public static void main(String[] args) {  
        Sourceable source = new Proxy();  
        source.method();  
    }  
  
}  
输出：
before proxy! the original method! after proxy!
代理模式的应用场景：
如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
9、外观模式（Facade）
外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）

我们先看下实现类：
[java] view plaincopy
public class CPU {  
      
    public void startup(){  
        System.out.println("cpu startup!");  
    }  
      
    public void shutdown(){  
        System.out.println("cpu shutdown!");  
    }  
}  
[java] view plaincopy
public class Memory {  
      
    public void startup(){  
        System.out.println("memory startup!");  
    }  
      
    public void shutdown(){  
        System.out.println("memory shutdown!");  
    }  
}  
[java] view plaincopy
public class Disk {  
      
    public void startup(){  
        System.out.println("disk startup!");  
    }  
      
    public void shutdown(){  
        System.out.println("disk shutdown!");  
    }  
}  
[java] view plaincopy
public class Computer {  
    private CPU cpu;  
    private Memory memory;  
    private Disk disk;  
      
    public Computer(){  
        cpu = new CPU();  
        memory = new Memory();  
        disk = new Disk();  
    }  
      
    public void startup(){  
        System.out.println("start the computer!");  
        cpu.startup();  
        memory.startup();  
        disk.startup();  
        System.out.println("start computer finished!");  
    }  
      
    public void shutdown(){  
        System.out.println("begin to close the computer!");  
        cpu.shutdown();  
        memory.shutdown();  
        disk.shutdown();  
        System.out.println("computer closed!");  
    }  
}  
User类如下：
[java] view plaincopy
public class User {  
  
    public static void main(String[] args) {  
        Computer computer = new Computer();  
        computer.startup();  
        computer.shutdown();  
    }  
}  
输出：
start the computer! cpu startup! memory startup! disk startup! start computer finished! begin to close the computer! cpu shutdown! memory shutdown! disk shutdown! computer closed!
如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！
10、桥接模式（Bridge）
桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图：

实现代码：
先定义接口：
[java] view plaincopy
public interface Sourceable {  
    public void method();  
}  
分别定义两个实现类：
[java] view plaincopy
public class SourceSub1 implements Sourceable {  
  
    @Override  
    public void method() {  
        System.out.println("this is the first sub!");  
    }  
}  
[java] view plaincopy
public class SourceSub2 implements Sourceable {  
  
    @Override  
    public void method() {  
        System.out.println("this is the second sub!");  
    }  
}  
定义一个桥，持有Sourceable的一个实例：
[java] view plaincopy
public abstract class Bridge {  
    private Sourceable source;  
  
    public void method(){  
        source.method();  
    }  
      
    public Sourceable getSource() {  
        return source;  
    }  
  
    public void setSource(Sourceable source) {  
        this.source = source;  
    }  
}  
[java] view plaincopy
public class MyBridge extends Bridge {  
    public void method(){  
        getSource().method();  
    }  
}  
测试类：
[java] view plaincopy
public class BridgeTest {  
      
    public static void main(String[] args) {  
          
        Bridge bridge = new MyBridge();  
          
        /*调用第一个对象*/  
        Sourceable source1 = new SourceSub1();  
        bridge.setSource(source1);  
        bridge.method();  
          
        /*调用第二个对象*/  
        Sourceable source2 = new SourceSub2();  
        bridge.setSource(source2);  
        bridge.method();  
    }  
}  
output：
this is the first sub! this is the second sub!
这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。

11、组合模式（Composite）
组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，看看关系图：

直接来看代码：
[java] view plaincopy
public class TreeNode {  
      
    private String name;  
    private TreeNode parent;  
    private Vector<TreeNode> children = new Vector<TreeNode>();  
      
    public TreeNode(String name){  
        this.name = name;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public TreeNode getParent() {  
        return parent;  
    }  
  
    public void setParent(TreeNode parent) {  
        this.parent = parent;  
    }  
      
    //添加孩子节点  
    public void add(TreeNode node){  
        children.add(node);  
    }  
      
    //删除孩子节点  
    public void remove(TreeNode node){  
        children.remove(node);  
    }  
      
    //取得孩子节点  
    public Enumeration<TreeNode> getChildren(){  
        return children.elements();  
    }  
}  
[java] view plaincopy
public class Tree {  
  
    TreeNode root = null;  
  
    public Tree(String name) {  
        root = new TreeNode(name);  
    }  
  
    public static void main(String[] args) {  
        Tree tree = new Tree("A");  
        TreeNode nodeB = new TreeNode("B");  
        TreeNode nodeC = new TreeNode("C");  
          
        nodeB.add(nodeC);  
        tree.root.add(nodeB);  
        System.out.println("build the tree finished!");  
    }  
}  
使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。
12、享元模式（Flyweight）
享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。
看个例子：

看下数据库连接池的代码：
[java] view plaincopy
public class ConnectionPool {  
      
    private Vector<Connection> pool;  
      
    /*公有属性*/  
    private String url = "jdbc:MySQL://localhost:3306/test";  
    private String username = "root";  
    private String password = "root";  
    private String driverClassName = "com.mysql.jdbc.Driver";  
  
    private int poolSize = 100;  
    private static ConnectionPool instance = null;  
    Connection conn = null;  
  
    /*构造方法，做一些初始化工作*/  
    private ConnectionPool() {  
        pool = new Vector<Connection>(poolSize);  
  
        for (int i = 0; i < poolSize; i++) {  
            try {  
                Class.forName(driverClassName);  
                conn = DriverManager.getConnection(url, username, password);  
                pool.add(conn);  
            } catch (ClassNotFoundException e) {  
                e.printStackTrace();  
            } catch (SQLException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
  
    /* 返回连接到连接池 */  
    public synchronized void release() {  
        pool.add(conn);  
    }  
  
    /* 返回连接池中的一个数据库连接 */  
    public synchronized Connection getConnection() {  
        if (pool.size() > 0) {  
            Connection conn = pool.get(0);  
            pool.remove(conn);  
            return conn;  
        } else {  
            return null;  
        }  
    }  
}  
 
通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！本章讲解了7种结构型模式，因为篇幅的问题，剩下的11种行为型模式，
本章是关于设计模式的最后一讲，会讲到第三种设计模式――行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。这段时间一直在写关于设计模式的东西，终于写到一半了，写博文是个很费时间的东西，因为我得为读者负责，不论是图还是代码还是表述，都希望能尽量写清楚，以便读者理解，我想不论是我还是读者，都希望看到高质量的博文出来，从我本人出发，我会一直坚持下去，不断更新，源源动力来自于读者朋友们的不断支持，我会尽自己的努力，写好每一篇文章！希望大家能不断给出意见和建议，共同打造完美的博文！
 
 
先来张图，看看这11中模式的关系：
第一类：通过父类与子类的关系进行实现。第二类：两个类之间。第三类：类的状态。第四类：通过中间类

13、策略模式（strategy）
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：

图中ICalculator提供同意的方法， AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：
首先统一接口：
[java] view plaincopy
public interface ICalculator {  
    public int calculate(String exp);  
}  
辅助类：
[java] view plaincopy
public abstract class AbstractCalculator {  
      
    public int[] split(String exp,String opt){  
        String array[] = exp.split(opt);  
        int arrayInt[] = new int[2];  
        arrayInt[0] = Integer.parseInt(array[0]);  
        arrayInt[1] = Integer.parseInt(array[1]);  
        return arrayInt;  
    }  
}  
三个实现类：
[java] view plaincopy
public class Plus extends AbstractCalculator implements ICalculator {  
  
    @Override  
    public int calculate(String exp) {  
        int arrayInt[] = split(exp,"\\+");  
        return arrayInt[0]+arrayInt[1];  
    }  
}  
[java] view plaincopy
public class Minus extends AbstractCalculator implements ICalculator {  
  
    @Override  
    public int calculate(String exp) {  
        int arrayInt[] = split(exp,"-");  
        return arrayInt[0]-arrayInt[1];  
    }  
  
}  
[java] view plaincopy
public class Multiply extends AbstractCalculator implements ICalculator {  
  
    @Override  
    public int calculate(String exp) {  
        int arrayInt[] = split(exp,"\\*");  
        return arrayInt[0]*arrayInt[1];  
    }  
}  
简单的测试类：
[java] view plaincopy
public class StrategyTest {  
  
    public static void main(String[] args) {  
        String exp = "2+8";  
        ICalculator cal = new Plus();  
        int result = cal.calculate(exp);  
        System.out.println(result);  
    }  
}  
输出：10
策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。
14、模板方法模式（Template Method）
解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：

就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：
[java] view plaincopy
public abstract class AbstractCalculator {  
      
    /*主方法，实现对本类其它方法的调用*/  
    public final int calculate(String exp,String opt){  
        int array[] = split(exp,opt);  
        return calculate(array[0],array[1]);  
    }  
      
    /*被子类重写的方法*/  
    abstract public int calculate(int num1,int num2);  
      
    public int[] split(String exp,String opt){  
        String array[] = exp.split(opt);  
        int arrayInt[] = new int[2];  
        arrayInt[0] = Integer.parseInt(array[0]);  
        arrayInt[1] = Integer.parseInt(array[1]);  
        return arrayInt;  
    }  
}  
[java] view plaincopy
public class Plus extends AbstractCalculator {  
  
    @Override  
    public int calculate(int num1,int num2) {  
        return num1 + num2;  
    }  
}  
测试类：
[java] view plaincopy
public class StrategyTest {  
  
    public static void main(String[] args) {  
        String exp = "8+8";  
        AbstractCalculator cal = new Plus();  
        int result = cal.calculate(exp, "\\+");  
        System.out.println(result);  
    }  
}  
我跟踪下这个小程序的执行过程：首先将exp和"\\+"做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。
15、观察者模式（Observer）
包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：

我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：
一个Observer接口：
[java] view plaincopy
public interface Observer {  
    public void update();  
}  
两个实现类：
[java] view plaincopy
public class Observer1 implements Observer {  
  
    @Override  
    public void update() {  
        System.out.println("observer1 has received!");  
    }  
}  
[java] view plaincopy
public class Observer2 implements Observer {  
  
    @Override  
    public void update() {  
        System.out.println("observer2 has received!");  
    }  
  
}  
Subject接口及实现类：
[java] view plaincopy
public interface Subject {  
      
    /*增加观察者*/  
    public void add(Observer observer);  
      
    /*删除观察者*/  
    public void del(Observer observer);  
      
    /*通知所有的观察者*/  
    public void notifyObservers();  
      
    /*自身的操作*/  
    public void operation();  
}  
[java] view plaincopy
public abstract class AbstractSubject implements Subject {  
  
    private Vector<Observer> vector = new Vector<Observer>();  
    @Override  
    public void add(Observer observer) {  
        vector.add(observer);  
    }  
  
    @Override  
    public void del(Observer observer) {  
        vector.remove(observer);  
    }  
  
    @Override  
    public void notifyObservers() {  
        Enumeration<Observer> enumo = vector.elements();  
        while(enumo.hasMoreElements()){  
            enumo.nextElement().update();  
        }  
    }  
}  
[java] view plaincopy
public class MySubject extends AbstractSubject {  
  
    @Override  
    public void operation() {  
        System.out.println("update self!");  
        notifyObservers();  
    }  
  
}  
测试类：
[java] view plaincopy
public class ObserverTest {  
  
    public static void main(String[] args) {  
        Subject sub = new MySubject();  
        sub.add(new Observer1());  
        sub.add(new Observer2());  
          
        sub.operation();  
    }  
  
}  
输出：
update self! observer1 has received! observer2 has received!
 这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：根据关系图，新建项目，自己写代码（或者参考我的代码）,按照总体思路走一遍，这样才能体会它的思想，理解起来容易！ 
16、迭代子模式（Iterator）
顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：
 
这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：
两个接口：
[java] view plaincopy
public interface Collection {  
      
    public Iterator iterator();  
      
    /*取得集合元素*/  
    public Object get(int i);  
      
    /*取得集合大小*/  
    public int size();  
}  
[java] view plaincopy
public interface Iterator {  
    //前移  
    public Object previous();  
      
    //后移  
    public Object next();  
    public boolean hasNext();  
      
    //取得第一个元素  
    public Object first();  
}  
两个实现：
[java] view plaincopy
public class MyCollection implements Collection {  
  
    public String string[] = {"A","B","C","D","E"};  
    @Override  
    public Iterator iterator() {  
        return new MyIterator(this);  
    }  
  
    @Override  
    public Object get(int i) {  
        return string[i];  
    }  
  
    @Override  
    public int size() {  
        return string.length;  
    }  
}  
[java] view plaincopy
public class MyIterator implements Iterator {  
  
    private Collection collection;  
    private int pos = -1;  
      
    public MyIterator(Collection collection){  
        this.collection = collection;  
    }  
      
    @Override  
    public Object previous() {  
        if(pos > 0){  
            pos--;  
        }  
        return collection.get(pos);  
    }  
  
    @Override  
    public Object next() {  
        if(pos<collection.size()-1){  
            pos++;  
        }  
        return collection.get(pos);  
    }  
  
    @Override  
    public boolean hasNext() {  
        if(pos<collection.size()-1){  
            return true;  
        }else{  
            return false;  
        }  
    }  
  
    @Override  
    public Object first() {  
        pos = 0;  
        return collection.get(pos);  
    }  
  
}  
测试类：
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
        Collection collection = new MyCollection();  
        Iterator it = collection.iterator();  
          
        while(it.hasNext()){  
            System.out.println(it.next());  
        }  
    }  
}  
输出：A B C D E
此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！
17、责任链模式（Chain of Responsibility）接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图：
 
 
Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。
[java] view plaincopy
public interface Handler {  
    public void operator();  
}  
[java] view plaincopy
public abstract class AbstractHandler {  
      
    private Handler handler;  
  
    public Handler getHandler() {  
        return handler;  
    }  
  
    public void setHandler(Handler handler) {  
        this.handler = handler;  
    }  
      
}  
[java] view plaincopy
public class MyHandler extends AbstractHandler implements Handler {  
  
    private String name;  
  
    public MyHandler(String name) {  
        this.name = name;  
    }  
  
    @Override  
    public void operator() {  
        System.out.println(name+"deal!");  
        if(getHandler()!=null){  
            getHandler().operator();  
        }  
    }  
}  
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
        MyHandler h1 = new MyHandler("h1");  
        MyHandler h2 = new MyHandler("h2");  
        MyHandler h3 = new MyHandler("h3");  
  
        h1.setHandler(h2);  
        h2.setHandler(h3);  
  
        h1.operator();  
    }  
}  
输出：
h1deal! h2deal! h3deal!
此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。
 18、命令模式（Command）
命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：

Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：
[java] view plaincopy
public interface Command {  
    public void exe();  
}  
[java] view plaincopy
public class MyCommand implements Command {  
  
    private Receiver receiver;  
      
    public MyCommand(Receiver receiver) {  
        this.receiver = receiver;  
    }  
  
    @Override  
    public void exe() {  
        receiver.action();  
    }  
}  
[java] view plaincopy
public class Receiver {  
    public void action(){  
        System.out.println("command received!");  
    }  
}  
[java] view plaincopy
public class Invoker {  
      
    private Command command;  
      
    public Invoker(Command command) {  
        this.command = command;  
    }  
  
    public void action(){  
        command.exe();  
    }  
}  
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
        Receiver receiver = new Receiver();  
        Command cmd = new MyCommand(receiver);  
        Invoker invoker = new Invoker(cmd);  
        invoker.action();  
    }  
}  
输出：command received!
这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！
其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。本章不出意外的话，应该是设计模式最后一讲了，首先还是上一下上篇开头的那个图：

本章讲讲第三类和第四类。
19、备忘录模式（Memento）
主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：

Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：
[java] view plaincopy
public class Original {  
      
    private String value;  
      
    public String getValue() {  
        return value;  
    }  
  
    public void setValue(String value) {  
        this.value = value;  
    }  
  
    public Original(String value) {  
        this.value = value;  
    }  
  
    public Memento createMemento(){  
        return new Memento(value);  
    }  
      
    public void restoreMemento(Memento memento){  
        this.value = memento.getValue();  
    }  
}  
[java] view plaincopy
public class Memento {  
      
    private String value;  
  
    public Memento(String value) {  
        this.value = value;  
    }  
  
    public String getValue() {  
        return value;  
    }  
  
    public void setValue(String value) {  
        this.value = value;  
    }  
}  
[java] view plaincopy
public class Storage {  
      
    private Memento memento;  
      
    public Storage(Memento memento) {  
        this.memento = memento;  
    }  
  
    public Memento getMemento() {  
        return memento;  
    }  
  
    public void setMemento(Memento memento) {  
        this.memento = memento;  
    }  
}  
测试类：
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
          
        // 创建原始类  
        Original origi = new Original("egg");  
  
        // 创建备忘录  
        Storage storage = new Storage(origi.createMemento());  
  
        // 修改原始类的状态  
        System.out.println("初始化状态为：" + origi.getValue());  
        origi.setValue("niu");  
        System.out.println("修改后的状态为：" + origi.getValue());  
  
        // 回复原始类的状态  
        origi.restoreMemento(storage.getMemento());  
        System.out.println("恢复后的状态为：" + origi.getValue());  
    }  
}  
输出：
初始化状态为：egg 修改后的状态为：niu 恢复后的状态为：egg
简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。
20、状态模式（State）
核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图：

State类是个状态类，Context类可以实现切换，我们来看看代码：
 
[java] view plaincopy
package com.xtfggef.dp.state;  
  
/** 
 * 状态类的核心类 
 * 2012-12-1 
 * @author erqing 
 * 
 */  
public class State {  
      
    private String value;  
      
    public String getValue() {  
        return value;  
    }  
  
    public void setValue(String value) {  
        this.value = value;  
    }  
  
    public void method1(){  
        System.out.println("execute the first opt!");  
    }  
      
    public void method2(){  
        System.out.println("execute the second opt!");  
    }  
}  
[java] view plaincopy
package com.xtfggef.dp.state;  
  
/** 
 * 状态模式的切换类   2012-12-1 
 * @author erqing 
 *  
 */  
public class Context {  
  
    private State state;  
  
    public Context(State state) {  
        this.state = state;  
    }  
  
    public State getState() {  
        return state;  
    }  
  
    public void setState(State state) {  
        this.state = state;  
    }  
  
    public void method() {  
        if (state.getValue().equals("state1")) {  
            state.method1();  
        } else if (state.getValue().equals("state2")) {  
            state.method2();  
        }  
    }  
}  
测试类：
 
 
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
          
        State state = new State();  
        Context context = new Context(state);  
          
        //设置第一种状态  
        state.setValue("state1");  
        context.method();  
          
        //设置第二种状态  
        state.setValue("state2");  
        context.method();  
    }  
}  
输出：
 
execute the first opt! execute the second opt!
根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。21、访问者模式（Visitor）
访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。―― From 百科
简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：

来看看原码：一个Visitor类，存放要访问的对象，
 
[java] view plaincopy
public interface Visitor {  
    public void visit(Subject sub);  
}  
[java] view plaincopy
public class MyVisitor implements Visitor {  
  
    @Override  
    public void visit(Subject sub) {  
        System.out.println("visit the subject："+sub.getSubject());  
    }  
}  
Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性，
[java] view plaincopy
public interface Subject {  
    public void accept(Visitor visitor);  
    public String getSubject();  
}  
[java] view plaincopy
public class MySubject implements Subject {  
  
    @Override  
    public void accept(Visitor visitor) {  
        visitor.visit(this);  
    }  
  
    @Override  
    public String getSubject() {  
        return "love";  
    }  
}  
测试：
 
 
 
 
 
 
 
 
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
          
        Visitor visitor = new MyVisitor();  
        Subject sub = new MySubject();  
        sub.accept(visitor);      
    }  
}  
输出：visit the subject：love
 
 
 
 
 
 
 
该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，22、中介者模式（Mediator）
中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：

User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现：
 
[java] view plaincopy
public interface Mediator {  
    public void createMediator();  
    public void workAll();  
}  
[java] view plaincopy
public class MyMediator implements Mediator {  
  
    private User user1;  
    private User user2;  
      
    public User getUser1() {  
        return user1;  
    }  
  
    public User getUser2() {  
        return user2;  
    }  
  
    @Override  
    public void createMediator() {  
        user1 = new User1(this);  
        user2 = new User2(this);  
    }  
  
    @Override  
    public void workAll() {  
        user1.work();  
        user2.work();  
    }  
}  
[java] view plaincopy
public abstract class User {  
      
    private Mediator mediator;  
      
    public Mediator getMediator(){  
        return mediator;  
    }  
      
    public User(Mediator mediator) {  
        this.mediator = mediator;  
    }  
  
    public abstract void work();  
}  
[java] view plaincopy
public class User1 extends User {  
  
    public User1(Mediator mediator){  
        super(mediator);  
    }  
      
    @Override  
    public void work() {  
        System.out.println("user1 exe!");  
    }  
}  
[java] view plaincopy
public class User2 extends User {  
  
    public User2(Mediator mediator){  
        super(mediator);  
    }  
      
    @Override  
    public void work() {  
        System.out.println("user2 exe!");  
    }  
}  
测试类：
 
 
 
 
 
 
 
 
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
        Mediator mediator = new MyMediator();  
        mediator.createMediator();  
        mediator.workAll();  
    }  
}  
输出：
 
 
 
 
 
 
 
user1 exe! user2 exe! 23、解释器模式（Interpreter） 解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。

Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下：
 
[java] view plaincopy
public interface Expression {  
    public int interpret(Context context);  
}  
[java] view plaincopy
public class Plus implements Expression {  
  
    @Override  
    public int interpret(Context context) {  
        return context.getNum1()+context.getNum2();  
    }  
}  
[java] view plaincopy
public class Minus implements Expression {  
  
    @Override  
    public int interpret(Context context) {  
        return context.getNum1()-context.getNum2();  
    }  
}  
[java] view plaincopy
public class Context {  
      
    private int num1;  
    private int num2;  
      
    public Context(int num1, int num2) {  
        this.num1 = num1;  
        this.num2 = num2;  
    }  
      
    public int getNum1() {  
        return num1;  
    }  
    public void setNum1(int num1) {  
        this.num1 = num1;  
    }  
    public int getNum2() {  
        return num2;  
    }  
    public void setNum2(int num2) {  
        this.num2 = num2;  
    }  
      
      
}  
[java] view plaincopy
public class Test {  
  
    public static void main(String[] args) {  
  
        // 计算9+2-8的值  
        int result = new Minus().interpret((new Context(new Plus()  
                .interpret(new Context(9, 2)), 8)));  
        System.out.println(result);  
    }  
}  
最后输出正确的结果：3。
 
 
 
 
 
 
 
基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！
设计模式基本就这么大概讲完了，总体感觉有点简略，的确，这么点儿篇幅，不足以对整个23种设计模式做全面的阐述，此处读者可将它作为一个理论基础去学习，通过这四篇博文，先基本有个概念，虽然我讲的有些简单，但基本都能说明问题及他们的特点，如果对哪一个感兴趣，可以继续深入研究！同时我也会不断更新，尽量补全遗漏、修正不足，欢迎广大读者及时提出好的建议，我们一起学习！项目中涉及到的代码，已经放到了我的资源里：http://download.csdn.net/detail/zhangerqing/4835830（因为我不喜欢不劳而获，所以没有免积分，只设置了5个，如果有人实在没积分又急要，那么联系我吧，我给你发过去）。 
50.谈谈你对框架的理解，设计框架的时候你是怎么考虑的，重构项目的时候你都遵循什么原则。


1.框架不要为应用做过多的假设
关于框架为应用做过多的假设，
一个非常具体的现象就是，
框架越俎代庖，
把本来是应
用要做的事情揽过来自己做。
这是一种典型的吃力不讨好的做法。
框架越俎代庖，
也许会使
得某一个具体应用的开发变得简单，
却会给其它更多想使用该框架的应用增加了本没有必要
的束缚和负担。
2.使用接口，保证框架提供的所有重要实现都是可以被替换的
 框架终究不是应用，
所以框架无法考虑所有应用的具体情况，
保证所有重要的组件的实
现都是可以被替换的，
这一点非常重要，
它使得应用可以根据当前的实际情况来替换掉框架
提供的部分组件的默认实现。
使用接口来定义框架中各个组件及组件间的联系，
将提高框架
的可复用性。
 3.框架应当简洁、一致、且目标集中
 框架应当简洁，
不要包含那些对框架目标来说无关紧要的东西，
保证框架中的每个组件
的存在都是为了支持框架目标的实现。包含过多无谓的元素（类、接口、枚举等）
，会使框
架变得难以理解，
尝试将这些对于框架核心目标不太重要的元素转移到类库中，
可以使得框
架更清晰、目标更集中。
 4.提供一个常用的骨架，但是不要固定骨架的结构，使骨架也是可以组装的
 比如说，
如果是针对某种业务处理的框架，
那么框架不应该只提供一套不可变更的业务
处理流程，而是应该将处理流程
“单步”
化，使得各个步骤是可以重新组装的，如此一来，应
用便可以根据实际情况来改变框架默认的处理流程。
这种框架的可定制化能力可以极大地提
高框架的可复用性。
 5.不断地重构框架
 如果说设计和实现一个高质量的框架有什么秘诀？答案只有一个，重构、不断地重构。
重构框架的实现代码、
甚至重构框架的设计。
重构的驱动力源于几个方面，
比如对要解决的
本质问题有了更清晰准备的认识，在使用框架的时候发现某些组件职责不明确、难以使用，
框架的层次结构不够清晰等。 
51.LRU算法


假设 序列为 4 3 4 2 3 1 4 2
物理块有3个 则
首轮 4调入内存 4
次轮 3调入内存 3 4
之后 4调入内存 4 3
之后 2调入内存 2 4 3
之后 3调入内存 3 2 4
之后 1调入内存 1 3 2（因为最少使用的是4，所以丢弃4）
之后 4调入内存 4 1 3（原理同上）
最后 2调入内存 2 4 1 
在指定内存中如果超过内存剔除最近最少用的。 

51.自定义控件的生命周期


onFinishInflate() 当View中所有的子控件均被映射成xml后触发 
onMeasure( int ,  int ) 确定所有子元素的大小 
onLayout( boolean ,  int ,  int ,  int ,  int ) 当View分配所有的子元素的大小和位置时触发     
onSizeChanged( int ,  int ,  int ,  int ) 当view的大小发生变化时触发  
onDraw(Canvas) view渲染内容的细节  
onKeyDown( int , KeyEvent) 有按键按下后触发  
onKeyUp( int , KeyEvent) 有按键按下后弹起时触发  
onTrackballEvent(MotionEvent) 轨迹球事件  
onTouchEvent(MotionEvent) 触屏事件  
onFocusChanged( boolean ,  int , Rect) 当View获取或失去焦点时触发   
onWindowFocusChanged( boolean ) 当窗口包含的view获取或失去焦点时触发  
onAttachedToWindow() 当view被附着到一个窗口时触发  
onDetachedFromWindow() 当view离开附着的窗口时触发，Android123提示该方法和  onAttachedToWindow() 是相反的。  
onWindowVisibilityChanged( int ) 当窗口中包含的可见的view发生变化时触发 
 
============================================================================

J2EE 部分：
1. Switch能否用string做参数？ 1.在 Java 7  之前, switch 只能支持byte,short,char,int 或者其对应的封装类以及 Enum 类型。在JAVA 7中,String 支持被加上了。   

2. equals与==的区别： 
1.==是判断两个变量或实例是不是指向同一个内存空间 
equals是判断两个变量或实例所指向的内存空间的值是不是相同 .


3. Object有哪些公用方法？ 1.方法equals测试的是两个对象是否相等
2.方法clone进行对象拷贝
3.方法getClass返回和当前对象相关的Class对象
4.方法notify,notifyall,wait都是用来对给定对象进行线程同步的

4. Java的四种引用，强弱软虚，用到的场景 1.强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象
2.软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。
3.弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象
4.虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。
5.使用场景： 1.利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题
2.通过软可及对象重获方法实现Java对象的高速缓存:比如我们创建了一Employee的类，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。我们可以通过软引用和 HashMap 的结合，先是保存引用方面：以软引用的方式对一个Employee对象的实例进行引用并保存该引用到HashMap 上，key 为此雇员的 id，value为这个对象的软引用，另一方面是取出引用，缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，并保存对这个新建实例的软引用


5. Hashcode的作用，与 equal 有什么区别 1.同样用于鉴定2个对象是否相等的，java集合中有 list 和 set 两类，其中 set不允许元素重复实现，那个这个不允许重复实现的方法，如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次 equal 去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上

6. String、StringBuffer与StringBuilder的区别 1.String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象
2.StringBuffer和StringBuilder底层是 char[]数组实现的
3.StringBuffer是线程安全的，而StringBuilder是线程不安全的
4.


7. Override和Overload的含义去区别 1.Overload顾名思义是重新加载，它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。
2.就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。

8. 抽象类和接口的区别 1.一个类只能继承单个类，但是可以实现多个接口
2.接口强调特定功能的实现，而抽象类强调所属关系
3.抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的

9. 解析XML的几种方式的原理与特点：DOM、SAX、PULL 1.DOM：消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机
2.SAX：解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。
3.SAX：与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。

10. wait()和sleep()的区别 1.sleep来自Thread类，和wait来自Object类
2.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁
3.sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU
4.sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒

11. JAVA 中堆和栈的区别，说下java 的内存机制 1.基本数据类型比变量和对象的引用都是在栈分配的
2.堆内存用来存放由new创建的对象和数组
3.类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中
4.实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的"物理位置”,实例变量的生命周期--当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存
5.局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放

12. JAVA多态的实现原理  1.抽象的来讲，多态的意思就是同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）
2.实现的原理是动态绑定，程序调用的方法在运行期才动态绑定，追溯源码可以发现，JVM 通过参数的自动转型来找到合适的办法。

13.JAVA 垃圾回收机制 1. 什么是垃圾回收机：释放那些不再持有引用的对象的内存
2.怎么判断一个对象是否需要收集？ 1.引用计数（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程
2. 对象引用遍历（现在大多数 jvm 使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集

3. 几种垃圾回收机制  1.标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片
2.标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率
3.复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。 
4.分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法


14. 讲讲 Java 中的集合有多少种，区别是什么？ 1.ArrayList、LinkedList、Vector的区别：ArrayList 和Vector底层是采用数组方式存储数据，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，随机存取比较慢
2.HashMap的底层源码实现：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。
3.Fail-Fast机制:在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast机制。这一机制在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map.
4.HashMap和 HashTable 的区别： 1.HashTable比较老，是基于Dictionary 类实现的，HashTable 则是基于 Map接口实现的
2.HashTable 是线程安全的， HashMap 则是线程不安全的
3.HashMap可以让你将空值作为一个表的条目的key或value









Android部分:
1.注册广播有哪几种方式,有什么区别
2.绘制 Activity 的生命流程图
3.注册Service需要注意什么
4.Service与Activity怎么实现通信
5.Handle通信具体到源码，是怎么实现的
6.Handle的机制
7.怎么实现ListView多种布局？
8.ListView与数据库绑定的实现
9.怎么实现一个部分更新的 ListView？
10.ListView卡顿的原因与性能优化，说的越多越好
11.Android中的动画有哪些，区别是什么
12.JNI怎么使用
13.说说内存泄露的情况有哪些
14.OOM是怎么引起的？怎么尽量避免 OOM 问题的出现
15.什么是 ANR 问题？为什么会引起 ANR 问题？
16.Socker编程的步骤
17.设计一个图片缓存加载机制
18.Fragment嵌套多个Fragment会出现bug吗
19.Activity中如何动态的添加Fragment
20.内存不足时，怎么保持Activity的一些状态，在哪个方法里面做具体操作？
21.Scrollview怎么判断是否滑倒底部
22.ViewPager 的怎么做性能优化
23.Asynctask具体用法？
24.Asynctask的Do in background方法是怎么通知UI线程刷新进度条的？
25.Asynctask的Do in background方法默认是返回 true ，表示任务完成，如果想返回具体的数据呢，怎么做。如果Activity被销毁了，还会执行到postexcutd方法吗？
26.View中onTouch，onTouchEvent，onClick的执行顺序
27.不使用动画，怎么实现一个动态的 View？
28.Postvalidata与Validata有什么区别？
29.Asset与raw都能存放资源，他们有什么区别？
30.如何自定义ViewGroup？
31.什么是 MVC 模式？MVC 模式的好处是什么？
32.JVM 和Dalvik虚拟机的区别
33.应用常驻后台，避免被第三方杀掉的方法，讲讲你用过的奇淫巧技？
34.数据持久化的四种方式有哪些？




数据结构与算法部分：
1.给最外层的rootview，把这个根视图下的全部button背景设置成红色，手写代码，不许用递归
2.给一串字符串比如abbbcccd，输出a1b3c3d1，手写代码（注意有个别字符可能会出现十次以上的情况）
3.一个序列，它的形式是12349678，9是最高峰，经历了一个上升又下降的过程，找出里面的最大值的位置，要求效率尽可能高
4.二叉查找树的删除操作，手写代码
5.反转链表，手写代码
6.二分查找，手写代码
7.有海量条 url，其中不重复的有300万条，现在希望挑选出重复出现次数最高的 url，要求效率尽可能的高
8.一篇英语文章，去掉字符只留下k个，如何去掉才能使这k个字符字典序最小
9.弗洛伊德算法和 Dijkstra算法的区别？复杂度是多少？讲讲 Dijkstra算法的具体过程
10.反转字符串，要求手写代码，优化速度、优化空间
11.给出两个无向图，找出这2个无向图中相同的环路。手写代码
12.单例模式，手写代码
13.生产者与消费者，手写代码
14.二叉树镜像，手写代码
15.最长不重复子串（最长重复子串），手写代码




操作系统部分：
1.分别从操作系统的内存角度与进程线程角度解释分析堆，栈二者的区别
2.什么是事务？
3.OSI七层模型有哪些，各层次的作用
4.TCP的三次握手过程，四次挥手过程，为什么需要三次？
5.说说操作系统中进程的通信方式
6.浏览器输入地址之后，之后的过程
7.谈谈 HTTP 中Get 和 Post 方法的区别？    

============================================================================

android面试题 不仅仅是面试是一个很好的学习 





下面的问题是在网上找到的总结，感谢您分享！希望，我们的共同进步，找到自己心仪的公司，：




1.android dvm 流程和Linux这个过程。无论是应用程序对同一概念：

答案：dvm是dalivk虚拟机。每个android应用程序都在自己的进程中执行，都拥有一个dalivk虚拟机实例。而每个dvm都是在linux的一个进程。所以说能够觉得是同一个概念。

2.android的动画有哪几种？他们的特点和差别是什么？

答：两种，一种是tween动画，一种是frame动画。

tween动画，这样的实现方式能够使视图组件移动，放大或缩小以及产生透明度的变化。frame动画。传统的动画方法，通过顺序的播放排列好的图片来实现。类似电影。

3.handler进制的原理：

答：android提供了handler和looper来满足线程间的通信。

Handler先进先出原则。

looper用来管理特定线程内对象之间的消息交换（message Exchange）.

    1)looper:一个线程能够产生一个looper对象，由它来管理此线程里的message queue(消息队列)

   2)handler:你能够构造一个handler对象来与looper沟通，以便push新消息到messagequeue里。或者接收looper（从messagequeue里取出）所送来的消息。

    3)messagequeue:用来存放线程放入的消息。

    4)线程：UI thread 通常就是main thread,而android启动程序时会为它建立一个message queue.

4.android view的刷新：

答：Android中对View的更新有非常多种方式。使用时要区分不同的应用场合。

我感觉最要紧的是分清：多线程和双缓冲的使用情况。

    1).不使用多线程和双缓冲

   这样的情况最简单了，一般仅仅是希望在View发生改变时对UI进行重绘。你仅仅需在Activity中显式地调用View对象中的invalidate()方法就可以。

系统会自己主动调用 View的onDraw()方法。



    2).使用多线程和不使用双缓冲

    这样的情况须要开启新的线程，新开的线程就不好L问View对象了。强行L问的话会报：android.view.ViewRoot$CalledFromWrongThreadException：Only the originalthread that created a view hierarchy can touch its views.

     这时候你须要创建一个继承了android.os.Handler的子类。并重写handleMessage(Messagemsg)方法。android.os.Handler是能发送和处理消息的，你须要在Activity中发出更新UI的消息，然后再你的Handler（能够使用匿名内部类）中处理消息（由于匿名内部类能够L问父类变量，你能够直接调用View对象中的invalidate()方法 ）。也就是说：在新线程创建并发送一个Message。然后再主线程中捕获、处理该消息。

    3).使用多线程和双缓冲

    Android中SurfaceView是View的子类，她同一时候也实现了双缓冲。

你能够定义一个她的子类并实现SurfaceHolder.Callback接口。

因为实现SurfaceHolder.Callback接口。新线程就不须要android.os.Handler帮忙了。SurfaceHolder中lockCanvas()方法能够锁定画布，绘制玩新的图像后调用unlockCanvasAndPost(canvas)解锁（显示），还是比^方便得。

 

5.说说mvc模式的原理，它在android中的运用:

答：android的官方建议应用程序的开发裼mvc模式。

何谓mvc？

 

　mvc是model,view,controller的缩写，mvc包括三个部分：

 

　　l模型（model）对象：是应用程序的主体部分，全部的业务逻辑都应该写在该层。

　　2视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一能够看到的一层。接收用户的输入，显示处理结果。

　　3控制器（control）对象：是依据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相关事件，交给m哦得了处理。


 

　android鼓舞弱耦合和组件的重用。在android中mvc的详细体现例如以下：

    1)视图层（view）：一般裼xml文件进行界面的描写叙述，使用的时候能够很方便的引入，当然，怎样你对android了解的比^的多了话，就一定 能够想到在android中也能够使用javascript+html等的方式作为view层。当然这里须要进行java和javascript之间的通 信，幸运的是，android提供了它们之间很方便的通信实现。

　2)控制层（controller）：android的控制层的重 任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理， 这样做的另外一个原因是android中的acitivity的响应时间是5s。假设耗时的操作放在这里，程序就非常easy被回收掉。

　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。

 

6.Activity的生命周期:

答：onCreate: 在这里创建界面，做一些数据 的初始化工作

 

　　onStart: 到这一步变成用户可见不可交互的

    onResume:变成和用户可交互 的。(在activity 栈系统通过栈的方式管理这些个Activity的最上面。执行完弹出栈，则回到上一个Activity)

　　onPause: 到这一步是可见但不可交互的，系统会停止动画 等消耗CPU 的事情从上文的描写叙述已经知道，应该在这里保存你的一些数据,由于这个时候你的程序的优先级减少，有可能被系统收回。在这里保存的数据。应该在

　　onstop: 变得不可见。被下一个activity覆盖了

onDestroy: 这是activity被干掉前最后一个被调用方法了。可能是外面类调用finish方法或者是系统为了节省空间将它临时性的干掉

 

7.让Activity变成一个窗体：

答：Activity属性设定：有时候会做个应用程序是漂浮在手机主界面的。

这个仅仅须要在设置下Activity的主题theme,即在Manifest.xml定义Activity的地方加一句：

android :theme="@android:style/Theme.Dialog"
假设是作半透明的效果：

android:theme="@android:style/Theme.Translucent"

8.Android中经常使用的五种布局:

答：LinearLayout线性布局；AbsoluteLayout绝对布局；TableLayout表格布局；RelativeLayout相对布局。FrameLayout帧布局。

9.Android的五种数据存储方式：

答：sharedPreferences。文件；SQLite；contentProvider。网络

10.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系：

答：Handler获取当前线程中的looper对象，looper用来从存有Message的Message Queue里取出message，再由Handler进行message的分发和处理。

11.AIDL的全称是什么?怎样工作?能处理哪些类型的数据?


答：AIDL(AndroidInterface Definition Language)android接口描写叙述语言

12.系统上安装了多种浏览器。是否能指定某浏览器L问指定页面？请说明原由：

答：通过直接发送Uri把⑹带过去。或者通过manifest里的intentfilter里的data属性。

代码例如以下：
    Intent intent = new Intent();

Intent.setAction(“android.intent.action.View”);

Uri uriBrowsers = Uri.parse(“http://www.sina.com.cn”);

Intent.setData(uriBrowsers);

//包名、要打开的activity
     intent.setClassName(“com.android.browser”,”com.android.browser.BrowserActivity”);

startActivity(intent);

13.什么是ANR,怎样避免？

答：ANR的定义：

在android上。假设你的应用程序有一段时间响应不移灵敏，系统会向用户提示“应用程序无响应”（ANR：application Not Responding）对话框。因此。在程序里对响应性能的设计非常重要。这样。系统不会显示ANR给用户。

怎样避免：

首先来研究下为什么它会在android的应用程序里发生和怎样最佳构建应用程序来避免ANR.
     android应用程序一般是执行在一个单独的线程（比如：main）里，这就意味你的应用程序所做的事情假设在主线程里占用了大长时间的话，就会引发ANR对话框，由于你的应用程序并没有给自己机会来处理输入事件或者Intent广播。

    因此，执行在主线程里的不论什么L求都尽可能少做事情。特别是。activity应该在它的关键生命周期方法（onCreate()和onResume()）里尽可能少的去作创建操作。

潜在的耗时操作。比如网络或数据库操作，或者高耗时的计算如改变位图尺寸。应该在子线程里（或者以数据库操作为例。通过异步请求的方式）来完毕。然而。不是说你的主线程堵塞在那里等待子线程的完毕---也不是调用Thread.wait()或者Thread.sleep()。替代的方法是：主线程应该为子线程提供一个Handler,以便完毕时可以提交给主线程。

以这样的方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由5秒输入事件的超时引发的ANR对话框。这样的做法应该在其他显示UI的线程里效仿，由于它们都受同样的超时影响。

    IntentReceiver运行时间的特殊限制意味着它应该做：在后台里做小的、琐碎的工作。如保存设定或注砸桓Notification。和在主线程里调用的其他方法一样，应用程序应该避免在BroadcastReceiver里做耗时的操作或计算，但也不是在子线程里做这些任务（由于BroadcastReceiver的生命周期短），替代的是，假设响应Intent广播须要运行一个耗时的动作的话，应用程序应该启动一个Service。顺便提及一句。你也应该避免在Intent Receiver里启动一个Activity，由于它会创建一个新的画面。并从当前用户正在运行的程序上抢夺焦点。假设你的应用程序在响应Intent广播时须要向用户展示什么，你应该使用Notification Manager来实现。


    一般来说，在应用程序里。100到200ms是用户能感知阻滞的时间阈值。以下总结了一些技巧来避免ANR,并有助于让你的应用程序看起来有响应性。

    假设你的应用程序为响应用户输入正在后台工作的话。能够显示工作的进度（ProgressBar和ProgressDialog对这样的情况来说非常实用）。特别是游戏，在子线程里做移动的计算。假设你的程序有一个耗时的初始化过程的话，考虑能够显示一个Splash Screen或者高速显示主画面并异步来填充这些信息。在这两种情况下。你都应该显示正在进行的进度，以免用户觉得程序被冻结了。

 

14.什么情况会导致Force Close？怎样避免？是否能捕获导致其的异常？

答：如空指针等能够导致ForceClose;能够看Logcat，然后找到相应的程序代码来解决错误。


15.横竖屏切换时候的activity的生命周期：

答：

1） 新建一个activity,并把各个生命周期打印出来

2） 执行activity，得到例如以下信息：

onCreate()à

onStart()à

onResume()à

    3)  按ctrl+F12切换成横屏时

        onSaveInstanceState()à

        onPause()à

        onStop()à

        onDestroy()à

        onCreate()à

        onStart()à

        onRestoreInstanceState()à

        onResume()à

    4)  再按ctrl+f12切换成竖屏时，发现打印了两次同样的Log

        onSaveInstanceState()à

        onPause()à

        onStop()à

        onDestroyà

        onCreate()à

        onStart()à

        onRestoreInstanceState()à

        onResume()à

 

        onSaveInstanceState()à

        onPause()à

        onStop()à

        onDestroyà

        onCreate()à

        onStart()à

        onRestoreInstanceState()à

        onResume()à

    5)  改动AndroidManifest.xml，把该Activity加入android:configChanges=“orientation”,运行步骤3

        onSaveInstanceState()à

        onPause()à

        onStop()à

        onDestroy()à

        onCreate()à

        onStart()à

        onRestoreInstanceState()à

        onResume()à

    6)  改动AndroidManifest.xml。把该Activity加入android:configChanges=“orientation”,运行步骤4,发现不会再打印同样信息，但多打印了一行onConfigChanged

        onSaveInstanceState()à

        onPause()à

        onStop()à

        onDestroy()à

        onCreate()à

        onStart()à

        onRestoreInstanceState()à

        onResume()à

        onConfigurationChanged()à

    7)  把步骤5的android:configChanges=“orientation”改成

android:configChanges=“orientation|keyboradHidden”,运行步骤3，就仅仅打印onConfigChanged

        onConfigurationChanged()à

    8)  把步骤5的android:configChanges=“orientation”改成

android:configChanges=“orientation|keyboradHidden”,运行步骤4

        onConfigurationChanged()à

        onConfigurationChanged()à

    总结：

1） 不设置activity的android:configChanges时,切屏会又一次调用各个生命周期，切横屏时会运行一次，切竖屏时会运行两次。

2） 设置activity的android:configChanges=“orientation”时, 切屏会又一次调用各个生命周期，切横屏、竖屏时都仅仅会运行一次。可是竖屏最后多打印一条onConfigurationChanged()

3） 设置activity的android:configChanges=“orientation|keyboardHidden”时,切屏不会又一次调用各个生命周期，仅仅会运行onConfigurationChanged(),横屏一次，竖屏两次

再总结下整个activity的生命周期：

1）  当前activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变

2）  Activity执行时按下HOME键（跟被全然覆盖一样的）

onSavaInstanceStateà

onPauseà

onStopà

 

onRestartà

onStartà

onResumeà

    3)  未被全然覆盖，仅仅是失去焦点：

        onPauseà

        onResumeà

16.怎样将SQLite数据库(.db文件)与apk文件一起公布?

答：能够将.db文件拷贝到Eclipse Androidproject中的res aw文件夹中。全部在res aw文件夹中的文件不会被压缩。这样能够直接提取该文件夹中的文件。

能够将.db文件拷贝到res aw文件夹中

17.怎样将打开res aw文件夹中的数据库文件?

答：在Android中不能直接打开res aw文件夹中的数据库文件，而须要在程序第一次启动时将该文件拷贝到手机内存或SD卡的某个文件夹中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res aw文件夹中资源的 InputStream对象，然后将该InputStream对象中的数据写入其它的文件夹中对应文件里。

在Android SDK中能够使用SQLiteDatabase.openOrCreateDatabase方法来打开随意文件夹中的SQLite数据库文件。

18.android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和差别：

答：XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要裼SAX方 式，SAX读取是单向的，长处:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是非常方便。而DOM方式会把整个XML文件载入到内存 中去，这里Android开发网提醒大家该方法在查找方面能够和XPath非常好的结合假设数据量不是非常大推荐使用。而PULL经常常使用在J2ME对于节点处 理比^好，类似SAX方式，相同非常节省内存。在J2ME中我们经常使用的KXML库来解析。


19.DDMS和TraceView的差别?

答：DDMS是一个程序运行查看器，在里面能够看见线程和堆栈等信息。TraceView是程序性能分析器

20.谈谈Android的IPC机制：

答：IPC是内部进程通信的简称，是共享"命名管道"的资源。Android中的IPC机制是为了让Activity和Service之间能够随时的进行交互，故在Android中该机制，仅仅适用于Activity和Service之间的通信。类似于远程方法调用。类似于C/S模式的L问。通过定义AIDL接口文件来定义IPC接口。

Servier端实现IPC接口。Client端调用IPC接口本地代理。

21.NDK是什么：

答：NDK是一系列工具的集合

    NDK提供了一系列的工具，帮助开发人员迅速的开发C/C++的动态库，并能自己主动将so和java应用打成apk包

    NDK集成了交叉编译器，并提供了对应的mk文件和隔离cpu，平台等的差异，开发者仅仅需简单的改动mk文件就能够创建出so

22.描写叙述一下android的系统架构：

答：android系统架构分从下往上为Linux内核层、执行库、应用程序框架层和应用程序层。

    Linux内核层：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。

执行库和androidruntion：执行库：即c/c++函数库部分，大多数都是开放源码的函数库，比如webkit，该函数库负责android网页浏览器的执行。比如标准的c函数库libc、openssl、sqlite等，当然也包含支持游戏开发的2dsgl和3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，如mpeg4、h.264、mp3、aac、amr、jpg和png等众多的多媒体文件格式。Androidruntion负责解释和执行生成的dalvik格式的字节码

应用软件架构：java应用程序开发者主要是使用该层封装好的api进行高速开发的。


应用程序层：该层是java的应用程序层。android内置的googlemaps、email、IM、浏览器等，都处于该层。java开发者工发的程序也处于该层。并且和内置的应用程序具有平等的地位。能够调用内置的应用程序。也能够替换内置的应用程序


23.Activity 与 Task的启动模式有哪些，它们含义详细是什么?


答：在一个activity中。有多次调用startActivity来启动还有一个activity，要想仅仅生成一个activity实例，能够设置启动模式。

    一个activity有四种启动模式：standed,signleTop,singleTask,singleInstance

    Standed:标准模式，一调用startActivity()方法就会产生一个新的实例。

    SingleTop:假设已经有一个实例位于activity栈顶，就不产生新的实例，而仅仅是调用activity中的newInstance()方法。假设不位于栈顶，会产生一个新的实例。


    singleTask:会在一个新的task中产生这个实例，以后每次调用都会使用这个，不会去产生新的实例了。

    SingleInstance:这个和singleTask基本一样。仅仅有一个差别：在这个模式下的activity实例所处的task中，仅仅能有这个activity实例，不能有其它实例

24.Application类的作用：

答：API里的第一句是：

Base class for those who need to maintain global application state 

假设想在整个应用中使用全局变量，在java中通常是使用静态变量，public类型；而在android中假设使用这种全局变量就不符合Android的框架架构，可是能够使用一种更优雅的方式就是使用Application context。

 
   首先须要重写Application。主要重写里面的onCreate方法，就是创建的时候，初始化变量的值。然后在整个应用中的各个文件里就能够对该变量进行操作了。 
   启动Application时，系统会创建一个PID，即进程ID，全部的Activity就会在此进程上执行。那么我们在Application创建的时候初始化全局变量。同一个应用的全部Activity都能够取到这些全局变量的值。换句话说。我们在某一个Activity中改变了这些全局变量的值，那么在同一个应用的其它Activity中值就会改变

25.说明onSaveInstanceState() 和 onRestoreInstanceState()在什么时候被调用：

答：Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并非生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法。它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity时，onSaveInstanceState()才会被调用。可是当用户主动去销毁一个Activity时。比如在应用中按返回键，onSaveInstanceState()就不会被调用。由于在这样的情况下，用户的行为决定了不须要保存Activity的状态。

通常onSaveInstanceState()仅仅适合用于保存一些暂时性的状态，而onPause()适合用于数据的持久化保存。

 另外。当屏幕的方向发生了改变， Activity会被摧毁而且被又一次创建，假设你想在Activity被摧毁前缓存一些数据，而且在Activity被又一次创建后恢复缓存的数据。

能够重写Activity的 onSaveInstanceState() 和 onRestoreInstanceState()方法。

26.android的service的生命周期？哪个方法能够多次被调用：

答：1)与裼Context.startService()方法启动服务有关的生命周期方法

onCreate() -> onStart() -> onDestroy()

 onCreate()该方法在服务被创建时调用，该方法仅仅会被调用一次，不管调用多少次startService()或bindService()方法。服务也仅仅被创建一次。
onStart() 仅仅有裼Context.startService()方法启动服务时才会回调该方法。

该方法在服务_始执行时被调用。多次调用startService()方法虽然不会多次创建服务，但onStart() 方法会被多次调用。
onDestroy()该方法在服务被终止时调用。


2)与裼Context.bindService()方法启动服务有关的生命周期方法
onCreate() -> onBind() -> onUnbind() -> onDestroy()

 onBind()仅仅有裼Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用。当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。


onUnbind()仅仅有裼Context.bindService()方法启动服务时才会回调该方法。

该方法在调用者与服务解除绑定时被调用。
 假设先裼startService()方法启动服务,然后调用bindService()方法绑定到服务，再调用unbindService()方法解除绑定，最后调用bindService()方法再次绑定到服务，触发的生命周期方法例如以下：
onCreate() ->onStart() ->onBind() ->onUnbind()[重载后的方法需返回true] ->onRebind()

27.android的broadcast的生命周期：

答：1)Broadcast receiver生命周期中仅有一个回调方法： 
void onReceive(Context curContext, Intent broadcastMsg) 
当接收器接收到一条broadcast消息，Android就会调用onReceiver(),并传递给它一个Intent对象，这个对象携带着那条broadcast消息。我们觉得仅当运行这个方式时，Broadcast receiver是活动的；这种方法返回时，它就终止了。这就是Broadcast receiver的生命周期。 


2)因为Broadcast receiver的生命周期非常短，一个带有活动的Broadcast receiver的进程是受保护的，以避免被干掉。可是别忘了有一点，Android会在随意时刻干掉那些携带不再活动的组件的进程，所以非常可能会造成这个问题。 


3)解决上述问题的方案裼靡桓Service来完毕这项工作，Android会觉得那个进程中（Service所在的进程）仍然有在活动的组件。 

28.android view，surfaceview，glsurfaceview的差别：

答：SurfaceView是从View基类中派生出来的显示类，直接子类有GLSurfaceView和VideoView。能够看出GL和视频播放以及Camera摄像头一般均使用SurfaceView
SurfaceView和View最本质的差别在于。surfaceView是在一个新起的单独线程中能够又一次绘制画面而View必须在UI的主线程中更新画面。

 
那么在UI的主线程中更新画面 可能会引发问题。比方你更新画面的时间过长。那么你的主UI线程会被你正在画的函数堵塞。那么将无法响应按键，触屏等消息。 
当使用surfaceView 由于是在新的线程中更新画面所以不会堵塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比方你触屏了一下，你须要surfaceView中thread处理，一般就须要有一个event queue的设计来保存touch event，这会稍稍复杂一点，由于涉及到线程同步。 

所以基于以上，依据游戏特点，一般分成两类。 

1)被动更新画面的。

比方棋类，这样的用view就好了。由于画面的更新是依赖于 onTouch 来更新，能够直接使用 invalidate。 由于这样的情况下，这一次Touch和下一次的Touch须要的时长之间的比较，无影响。 

2)自动更新。

例如，一个人一直运行。

这需要一个单独的thread人们不断地重绘状态，避免堵塞main UI thread。很显然view不当。必须surfaceView为了控制。



============================================================================
最近在忙着准备面试，所以从全网搜集了一下Java和Android相关的面试题目，应该能够包含80%以上的试题吧~如果大家还有一些比较全面优质的题目资源，欢迎告知，我会继续补充进来，以便于更多同学可以从中获益。

android性能优化系列 http://www.trinea.cn/android/performance/

2016JAVA与Android面试题整理 http://www.nowcoder.com/discuss/3244

百度的android面试总结分析 http://blog.csdn.net/lpjishu/article/details/46425281

android面试题总结从初级到进阶 http://blog.csdn.net/vfush/article/details/51508098

android最全面试题71道详解 http://blog.csdn.net/superjunjin/article/details/7772030

四大组件跟Handler相关的知识 http://www.iwfu.me/2016/07/17/安卓面试题：1-关于activity/

Java线程面试题Top50 http://www.jcodecraeer.com/a/chengxusheji/java/2015/0206/2421.html

国内一线互联网公司内部面试题库 http://blog.csdn.net/wdong_love_cl/article/details/51989028

囊括了所有你能想到的面试题目 https://github.com/GeniusVJR/LearningNotes/blob/master/README.md

40个Java集合面试问题和答案 http://www.jcodecraeer.com/a/chengxusheji/java/2015/0520/2896.html

Java开发中的23种设计模式详解 http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html

面试和算法心得 https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/Readme.md

