 jvm的内存分配总结
 https://www.cnblogs.com/lifescolor/p/5481588.html
最近看了周志明版本的《深入理解Java虚拟机》第一版和第二版，写的很好，收获很多，此处总结一下。
 
jvm中内存划分：
 
如上图，一共分为五块，其中：
线程共享区域为：
1、java堆
2、方法区
 
线程私有区域为：
3、JVM栈
4、本地方法栈
5、程序计数器
 
各区域作用：
1、java堆：
    java堆是jvm内存管理中最大的一块，线程共享。在jvm启动的时候创建。此区域唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT编译器（即时编译器）的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙变化（对象可能会分配到栈上），所以这种所有对象都分配在堆上也不是那么绝对的。
    java堆细分为新生代和老年代，新生代又分为Eden空间、From Survivor空间、To Survivor空间，新生代中垃圾回收算法为复制算法，复制算法是先将内存分为连个部分，一部分用来放入对象，而另一部分暂时不用，当使用的一部分内存要进行垃圾回收的时候会将不需要回收的对象复制保存在另一个空间中，然后再对使用过的那部分区域进行垃圾回收，这样虽然效率很高，但是很浪费空间，所以一般将新生代分为Eden空间和两个Survivor空间，其大小在HotSpot虚拟机中默认比例为8：1：1，这样在新生代中采用复制算法回收垃圾效率就很高了，具体回收过程是将Eden区域和From Survivor区域作为对象的存储空间，当要进行垃圾回收的时候先将这两个区域中不需要回收的对象复制保存在To Survivor区域中，然后再进行垃圾回收。另外有一点是当一个对象在Eden区域和From Survivor区域中存储的时候发现内存不足，这时会进行内存分配担保，就是将此对象直接存入在老年代中。
    老年代中采用的GC算法为标记-清除算法或者标记-整理算法。标记-清除算法为：首先标记出要进行GC的对象，标记完成后再进行GC。这种算法效率不高，并且会产生很多内存碎片。标记-整理算法：同样是先对要进行GC的对象进行标记，但是不同的是在标记完成后不是立刻执行GC，而是先将不需要GC的对象移动到一端，然后在边界外再对要回收的对象进行GC。
    关于对象的分配：对象优先在Eden区域分配，大对象会直接进入老年代，长期存活的对象会进入老年代，这里的长期存活是根据新生代中的对象年龄阈值来定义的，对象刚分配到新生代的时候年龄为1，每进行一次GC对象的年龄会加1，HotSpot中默认的阈值是15，也就是说对象年龄达到15岁的时候会被分配到老年区，这个值是可以通过参数配置的。
    在进行垃圾回收的时候新生代GC又叫minor GC，老年代GC可以设置内存容量达到百分比的多少的时候进行GC，老年代的GC又叫Full GC，minor GC时间短，频率高，而Full GC时间长，频率低。
 
2、方法区
    方法区又被称为永久区，线程共享，是用来存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区为堆的一个逻辑部分，但是在JDK1.7的HotSpot中已经将方法区中的字符串常量池移出，部分资料显示JDK1.8已经去除了方法区（不确定）。不过已经可以猜测此区域将会被本地内存逐步取代。
    这个区域很少进行垃圾回收，回收目标主要是针对常量池的回收和对类型的卸载。
 
3、JVM栈
    JVM栈是线程私有的，它的生命周期与线程相同。JVM栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
    局部变量表中存放了编译期可知的各种基本数据类型、对象的引用类型。局部变量表中需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
 
4、本地方法栈
    本地方法栈和JVM栈非常相似，它们之间的区别不过是jvm栈是为执行java方法服务，而本地方法栈是为jvm使用到对的本地方法服务。HotSpot虚拟机中直接把本地方法栈和JVM栈合二为一了。
 
5、程序计数器
    程序计数器是一块较小的内存空间，线程私有。它可以看作是当前线程所执行的字节码的行号指示器。在jvm的概念模型里，字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的jvm字节码指令的地址；如果正在执行的是本地方法，这个计数器值则为空。
 
总结：
    在jvm划分的内存区域中JVM栈和本地方法栈可能会抛出StackOverflowError异常和OutOfMemoryError异常。java堆和方法区可能会抛出OutOfMemoryError异常。程序计数器中没有地方规定会抛出这两个异常。
 
扩展：
    在jvm规范中，StackOverflowError异常为：如果线程请求的栈深度大于JVM允许的栈深度，将抛出StackOverflowError异常。OutOfMemoryError异常：如果jvm可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
    HotSpot虚拟机中标记要清除的对象方法不是使用引用计数器（有引用的时候计数器+1，引用失效-1，应用为0时回收），而使用的是可达性分析算法：以“GC Roots“的对象为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明这个对象不可达，即这个对象不可用，所以这个对象会被判定为是可回收对象。

=================================================================================================

 https://www.jianshu.com/p/5db05db4f5ab
GC那些事儿--Android内存优化第一弹
96
anly_jun
2016.10.14 12:01* 字数 1884
内容太晦涩，先乐一个
引言

接App优化之内存优化(序), 作为App优化系列中内存优化的一个小部分.

由于内存相关知识比较生涩, 内存优化中使用到的相关工具, 也有很多专有名词. 对Java内存管理, GC, Android内存管理, Dalvik/ART等知识有一个理论的认识, 可以让我们更好的使用这些工具, 分析内存问题.

据此, 我们就先从理论入手, 聊聊GC那些事儿.
1, 何为GC

GC 是 garbage collection 的缩写, 垃圾回收的意思. 也可以是 Garbage Collector, 也就是垃圾回收器.
1.1 垃圾回收器

我们先来解释下Garbage Collector(垃圾回收器).

内存管理, 一直是编程中的一个大的问题. 在较老的语言中, 例如C++语言中, 内存管理是显式的, 也就是说使用者自己申请内存使用, 自己释放内存. 这就是为什么C++语言中除了构造函数, 还有析构函数. 我们在创建对象的时候调用构造函数创建, 系统会在对象结束其作用域的时候调用析构函数, 我们需要做的就是在析构函数中释放掉我们申请的相关资源, 以便释放内存地址.

显然, 这种显式的由编程人员自己控制释放内存的方式很容易出问题, 忘了, 漏了, 都可能导致内存问题. 也不符合程序员要懒的特征.

故而, Java语言中引入了自动内存管理的机制, 也就是垃圾回收器. 大部分的现代面向对象语言, 也都是采用自动内存管理机制.

    内存自动管理回收机制可以解决大部分, 但不是所有的内存问题, 这也是为什么我们要讨论内存泄露.

垃圾回收器的职责

垃圾回收器有三大职责:

    分配内存;
    确保任何被引用的对象保留在内存中;
    回收不能通过引用关系找到的对象的内存.

垃圾回收的一般流程
gc process
1.2 相关概念
垃圾回收(GC)

垃圾回收器中有一个进程来做上面的这些事情, 这个进程查找我们的对象引用的关系并释放其内存, 这个进程就是garbage collection(垃圾回收), 也就是我们常说的GC.
Heap和Stack

简单说下:

    Heap内存是指java运行环境用来分配给对象和JRE类的内存. 是应用的内存空间.
    Stack内存是相对于线程Thread而言的, 它保存线程中方法中短期存在的变量值和对Heap中对象的引用等.
    Stack内存, 顾名思义, 是类Stack方式, 总是后进先出(LIFO)的.
    我们通常说的GC的针对Heap内存的. 因为Stack内存相当于是随用随销的.

heap&stack
GC Root

直译GC根, 我们姑且不译了吧.
所谓GC Root我们可以理解为是一个Heap内存之外的对象, 通常包括但不仅限于如下几种:

    System Class 系统Class Loader加载的类. 例如java运行环境中rt.jar中类, 比如java.util.* package中的类.
    Thread 运行中的线程
    JNI 中的本地/全局变量, 用户自定义的JNI代码或是JVM内部的.
    Busy Monitor 任何调用了wait()或notify()方法, 或是同步化的(synchronized)的东西. 可以理解为同步监控器.
    Java本地实例, 还在运行的Thread的stack中的方法创建的对象.

活对象/垃圾

如果这个对象是引用可达的, 则称之为活的(live), 反之, 如果这个对象引用不可达, 则称之为死的(dead), 也可以称之为垃圾(garbage).

这个引用可达与不可达就是相对于GC Root来说的:
gc-roots
2, Java的内存管理机制
2.1 关于JVM

我们平常在查看我们的java版本时, 你会发现:

$ java -version
java version "1.8.0_74"
Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)

其中有个HotSpot VM的东西, 那么这个是什么呢? 和JVM有什么关系呢?

在此简单说下, 以便行文:

    JVM, Java虚拟机, 可以简单理解为一种技术思想, 虚拟技术理念.
    HotSpot VM是JVM的一种实现, 包含了服务器版和桌面应用程序版, 现时由Oracle维护并发布.

    我们当前使用的sun(oracle)的java版本(应该是1.3以上)都是内置的HotSpot VM实现. 所以接下来的分析也都是基于HotSpot VM的, 但是还是简称JVM.

2.2 JVM内存区域

JVM使用分代式的内存管理方式, 将Heap分成三代 --- 新生代, 老一代, 持久代.
Hotspot heap structure

    Young Generation
        新生代.
        所有new的对象.
        该区域的内存管理使用minor garbage collection(小GC).
        更进一步分成Eden space, Survivor 0 和 Survivor 1 三个部分.

    Old Generation
        老年区.
        新生代中执行小粒度的GC幸存下来的"老"对象.
        该区域的内存管理使用major garbage collection(大GC).

    Permanent Generation
        持久代.
        包含应用的类/方法信息, 以及JRE库的类和方法信息.

    小GC执行非常频繁, 而且速度特别快.
    大GC一般会比小GC慢十倍以上.
    大小GC都会发出"Stop the World"事件, 也就是说中断程序运行, 直至GC完成. 这也是我们在App优化之消除卡顿中为什么说频繁GC会造成用户感知卡顿.

3, GC的流程

了解了内存Heap的几个区域, 我们再来看下垃圾收集器是怎么利用这几个区域来管理内存和回收垃圾的.

1. 创建新的对象

每当我们使用new创建一个对象时, 这个对象会被分配到新生代的Eden区域:
object allocation

2. 当Eden区域满时
当Eden区域内存被分配完时, 小GC程序被触发:
Eden filling

引用可达的对象会移到Survivor(幸存者)区域--S0, 然后清空Eden区域, 此时引用不可达的对象会直接删除, 内存回收, 如下:
aged

3. Eden再次满时
当Eden区域再次分配完后, 小GC执行, 引用可达的对象会移到Survivor(幸存者)区域, 而引用不可达的对象会跟随Eden的清空而删除回收.

需要注意的是, 这次引用可达的对象移动到的是S1的幸存者区.
而且, S0区域也会执行小GC, 将其中还引用可达的对象移动到S1区, 且年龄+1. 然后清空S0, 回收其中引用不可达的对象.

此时, 所有引用可达的对象都在S1区, 且S1区的对象存在不同的年龄. 如下:
next filling

当Eden第三次满时, S0和S1的角色互换了:
s0s1

依此循环.

4. 当Survivor区的对象年龄达到"老年线"时
上面1~3循环, Survivor区的对象年龄也会持续增长, 当其中某些对象年龄达到"老年线", 例如8岁时, 它们会"晋升"到老年区.
old aged

如此1~4步重复, 大体流程是这样的
gc flow

==================================================================================================
http://blog.csdn.net/qq_28750155/article/details/50579524
在堆中，新生代主要存放的是哪些很快就会被GC回收掉的或者不是特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）。新生代采用的复制算法，即将新生代分为3个区：较大的Eden和两个较小的Survivor（默认的Eden：Survivor = 8:1）。发生在新生代的GC为Minor GC 。在Minor GC时会将新生代中还存活着的对象复制进一个Survivor中，然后对Eden和另一个Survivor进行清理。所以，平常可用的新生代大小为Eden的大小+一个Survivor的大小。


老年代则是存放那些在程序中经历了好几次回收仍然还活着或者特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）。老年代采用的是标记-清除或者标记-整理算法，这两个算法主要看虚拟机采用的哪个收集器，两种算法的区别是：标记-清除可能会产生大量连续的内存碎片。在老年代中的GC则为Major GC。Major GC和Full GC会造成stop-the-world。


那么什么情况下，新生代的对象会进入老年代呢？

首先就是分配担保机制：当Minor GC时，新生代存活的对象大于Survivor的大小时，这时一个Survivor装不下它们，那么它们就会进入老年代。

还有其他的情况：如果设置了-XX：PretenureSizeThreshold3M 那么大于3M的对象就会直接就进入老年代。

还有，在新生代的每一次Minor GC 都会给在新生代中的对象+1岁，默认到15岁时就会从新生代进入老年代，可以通过-XX：MaxTenuringThreshold来设置这个临界点。

相比较而言，在老年代中的对象比新生代中的对象不易回收许多。


JVM的方法区，也被称为永久代。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收。

=====================================================================================================

http://blog.csdn.net/zhb123gggggg/article/details/40901003
JVM内存管理、JVM垃圾回收机制、新生代、老年代以及永久代
转载 2014年11月07日 22:18:34

    编辑
    删除


     如果大家想深入的了解JVM，可以读读周志明《深入理解Java虚拟机：JVM高级特性与最佳实践》

     需要掌握的东西，包括以下内容、判断对象存活还是死亡的算法（引用计数算法、可达性分析算法）、常见的垃圾收集算法（复制算法、分代收集算法等以及这些算法适用于什么代）以及常见的垃圾收集器的特点（这些收集器适用于什么年代的内存收集）。

     

     JVM运行时数据区由程序计数器、堆、虚拟机栈、本地方法栈、方法区部分组成，结构图如下所示。

     JVM内存结构由程序计数器、堆、栈、本地方法栈、方法区等部分组成，结构图如下所示：

                 


   1）程序计数器

   几乎不占有内存。用于取下一条执行的指令。

   2）堆

   所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。堆被划分为新生代和旧生

代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，结构图如下所示：

    新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代

大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过

多次垃圾回收仍然存活的对象。

                 

   3）栈

   每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方

法调用过程中的临时变量、参数和中间结果。

   4）本地方法栈

   用于支持native方法的执行，存储了每个native方法调用的状态

   5）方法区

   存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用永久代（PermanetGeneration）

来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代

的概念，有关信息可以看周志明的书）可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。


   JVM垃圾回收机制

   JVM分别对新生代和旧生代采用不同的垃圾回收机制

新生代的GC：

新生代通常存活时间较短，因此基于复制算法来进行回收，所谓复制算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和其中一个Survivor，复制到另一个之间Survivor空间中，然后清理掉原来就是在Eden和其中一个Survivor中的对象。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从eden到 survivor，最后到老年代。

用javavisualVM来查看，能明显观察到新生代满了后，会把对象转移到旧生代，然后清空继续装载，当旧生代也满了后，就会报outofmemory的异常，如下图所示：

JVM内存管理和JVM垃圾回收机制 - Gui Xun Long - Hello Java

 
     在执行机制上JVM提供了串行GC（SerialGC）、并行回收GC（ParallelScavenge）和并行GC（ParNew）

1）串行GC

在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定

2）并行回收GC

在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数

3）并行GC

与旧生代的并发GC配合使用

旧生代的GC：

旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上JVM提供了串行 GC（SerialMSC）、并行GC（parallelMSC）和并发GC（CMS），具体算法细节还有待进一步深入研究。

以上各种GC机制是需要组合使用的，指定方式由下表所示：
JVM内存管理和JVM垃圾回收机制 - Gui Xun Long - Hello Java

 

Java GC、新生代、老年代

   Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。

   在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为

三个区域：Eden、From Survivor、To Survivor。

   这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

   堆的内存模型大致为：

     

    从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 CXms、-Xmx 来指定。


   （本人使用的是 JDK1.6，以下涉及的 JVM 默认值均以该版本为准。）
   默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 CXX:NewRatio 来指定

 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young )

 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。


    默认的，Edem : from : to = 8 :1 : 1 ( 可以通过参数CXX:SurvivorRatio 来设定 )，即： Eden = 8/10 的

新生代空间大小，from = to = 1/10 的新生代空间大小。


    JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块Survivor

 区域是空闲着的。

    因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。

GC 堆                                                                                  

    Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、FullGC ( 或称为 Major GC )。

    Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。

    新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部

分对象通常不需长久存活，具有朝生夕灭的性质。

    当一个对象被判定为 "死亡" 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的

频繁区域。

   当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如

果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，

即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对

象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即

from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年

龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定

 )，这些对象就会成为老年代。

   但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。


   Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。

   现实的生活中，老年代的人通常会比新生代的人"早死"。堆内存中的老年代(Old)不同于这个，老年代里面的对象

几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 "死掉" 了的。因此，Full GC 发生的次数不

会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。


   另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象

分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。


GC 日志                                                                               

    publicstaticvoid main(String[] args) {    Object obj = new Object();   System.gc();   System.out.println();    obj = new Object();   obj = new Object();    System.gc();    System.out.println();}

   设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中

一次执行的结果。

   Full GC 信息与 Minor GC 的信息是相似的，这里就不一个一个的画出来了。

   从 Full GC 信息可知，新生代可用的内存大小约为 18M，则新生代实际分配得到的内存空间约为 20M(为什么是

 20M? 请继续看下面...)。老年代分得的内存大小约为 42M，堆的可用内存的大小约为 60M。可以计算出： 18432K

 ( 新生代可用空间 ) + 42112K ( 老年代空间 ) = 60544K ( 堆的可用空间 )


    新生代约占堆大小的 1/3，老年代约占堆大小的 2/3。也可以看出，GC 对新生代的回收比较乐观，而对老年代

以及方法区的回收并不明显或者说不及新生代。

    并且在这里 Full GC 耗时是 Minor GC 的 22.89 倍。

JVM 参数选项                                                                        


    jvm 可配置的参数选项可以参考 Oracle 官方网站给出的相关信息：          http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html


    下面只列举其中的几个常用和容易掌握的配置选项

-Xms
	

初始堆大小。如：-Xms256m

-Xmx
	

最大堆大小。如：-Xmx512m

-Xmn
	

新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90% 

-Xss
	

JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。

-XX:NewRatio
	

新生代与老年代的比例，如 CXX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3

-XX:SurvivorRatio
	

新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 

-XX:PermSize
	

永久代(方法区)的初始大小

-XX:MaxPermSize
	

永久代(方法区)的最大值

-XX:+PrintGCDetails
	

打印 GC 信息

-XX:+HeapDumpOnOutOfMemoryError
	

让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用

  1 /** 2  -Xms60m 3  -Xmx60m 4 -Xmn20m 5  -XX:NewRatio=2 ( 若 Xms = Xmx, 并且设定了 Xmn, 那么该项配置就不需要配置了 ) 6  -XX:SurvivorRatio=8 7  -XX:PermSize=30m 8  -XX:MaxPermSize=30m 9  -XX:+PrintGCDetails10  */11 publicstaticvoid main(String[] args) {12    new Test().doTest();13 }14 15 publicvoid doTest(){16     Integer M = newInteger(1024 * 1024 * 1);  //单位, 兆(M)17     byte[] bytes = newbyte[1 * M]; //申请1M 大小的内存空间18     bytes = null;  //断开引用链19    System.gc();   //通知 GC 收集垃圾20    System.out.println();21     bytes = newbyte[1 * M];  //重新申请1M 大小的内存空间22     bytes = newbyte[1 * M];  //再次申请1M 大小的内存空间23    System.gc();24    System.out.println();25 }

     按上面代码中注释的信息设定 jvm 相关的参数项，并执行程序，下面是一次执行完成控制台打印的结果：

[ GC [ PSYoungGen:  1351K -> 288K (18432K) ]  1351K -> 288K (59392K), 0.0012389 secs]  [ Times: user=0.00 sys=0.00, real=0.00 secs ] [ Full GC (System)  [ PSYoungGen: 288K -> 0K (18432K)]  [ PSOldGen:  0K -> 160K (40960K) ]  288K -> 160K (59392K)  [ PSPermGen: 2942K -> 2942K (30720K) ], 0.0057649 secs ] [ Times: user=0.00  sys=0.00,  real=0.01 secs ] [ GC [ PSYoungGen:  2703K -> 1056K (18432K) ] 2863K -> 1216K(59392K), 0.0008206 secs ]  [ Times:user=0.00 sys=0.00, real=0.00 secs] [ Full GC (System)  [ PSYoungGen:  1056K -> 0K (18432K) ] [ PSOldGen:  160K -> 1184K(40960K) ]  1216K -> 1184K(59392K)  [ PSPermGen:  2951K -> 2951K (30720K) ], 0.0052445 secs]  [ Times: user=0.02 sys=0.00, real=0.01 secs ] Heap PSYoungGen      total 18432K, used 327K [0x00000000fec00000, 0x0000000100000000,0x0000000100000000)  eden space 16384K, 2% used[0x00000000fec00000,0x00000000fec51f58,0x00000000ffc00000)  fromspace 2048K, 0% used[0x00000000ffe00000,0x00000000ffe00000,0x0000000100000000) to   space 2048K, 0% used[0x00000000ffc00000,0x00000000ffc00000,0x00000000ffe00000) PSOldGen        total 40960K, used 1184K [0x00000000fc400000, 0x00000000fec00000,0x00000000fec00000)  object space 40960K, 2% used[0x00000000fc400000,0x00000000fc5281f8,0x00000000fec00000) PSPermGen       total 30720K, used 2959K [0x00000000fa600000, 0x00000000fc400000,0x00000000fc400000)  object space 30720K, 9% used [0x00000000fa600000,0x00000000fa8e3ce0,0x00000000fc400000)

  从打印结果可以看出，堆中新生代的内存空间为18432K ( 约 18M )，eden 的内存空间为 16384K ( 约 16M)，

from/ to survivor 的内存空间为 2048K ( 约2M)。


    这里所配置的 Xmn 为 20M，也就是指定了新生代的内存空间为 20M，可是从打印的堆信息来看，新生代怎么就

只有 18M 呢? 另外的 2M 哪里去了? 别急，是这样的。新生代 = eden + from + to = 16 + 2 + 2 = 20M，可见新

生代的内存空间确实是按 Xmn 参数分配得到的。而且这里指定了 SurvivorRatio = 8，因此，eden = 8/10 的新生

代空间 = 8/10 * 20 = 16M。from = to = 1/10 的新生代空间 = 1/10 * 20 = 2M。


    堆信息中新生代的 total 18432K 是这样来的：eden + 1 个 survivor = 16384K + 2048K = 18432K，即约为 18M。

   因为 jvm 每次只是用新生代中的 eden 和 一个 survivor，因此新生代实际的可用内存空间大小为所指定的

 90%。

   因此可以知道，这里新生代的内存空间指的是新生代可用的总的内存空间，而不是指整个新生代的空间大小。

   另外，可以看出老年代的内存空间为 40960K ( 约 40M)，堆大小 = 新生代 + 老年代。因此在这里，老年代 =

 堆大小 - 新生代 = 60 -20 = 40M。

   最后，这里还指定了 PermSize = 30m，PermGen即永久代 ( 方法区 )，它还有一个名字，叫非堆，主要用来存储

由 jvm 加载的类文件信息、常量、静态变量等。

   回到 doTest() 方法中，可以看到代码在第 17、21、22 这三行中分别申请了一块 1M大小的内存空间，并在 19

 和 23 这两行中分别显式的调用了 System.gc()。从控制台打印的信息来看，每次调 System.gc()，是先进行

 Minor GC，然后再进行 Full GC。


第 19 行触发的 Minor GC 收集分析：


   从信息 PSYoungGen : 1351K -> 288K，可以知道，在第 17 行为bytes 分配的内存空间已经被回收完成。

引起 GC 回收这 1M 内存空间的因素是第 18 行的 bytes = null;   bytes 为 null 表明之前申请的那 1M 大小的

内存空间现在已经没有任何引用变量在使用它了，并且在内存中它处于一种不可到达状态 ( 即没有任何引用链与 GC

 Roots 相连 )。那么，当 Minor GC 发生的时候，GC 就会来回收掉这部分的内存空间。


第 行触发的 Full GC 收集分析：

   在 Minor GC 的时候，信息显示 PSYoungGen :  1351K -> 288K，再看看Full GC 中显示的 PSYoungGen :  288K

 -> 0K，可以看出，Full GC 后，新生代的内存使用变成0K 了，那么这 288K 到底哪去了 ? 难道都被GC 当成垃圾

回收掉了 ? 当然不是了。我还特意在 main 方法中 new 了一个 Test 类的实例，这里的 Test 类的实例属于小对

象，它应该被分配到新生代内存当中，现在还在调用这个实例的doTest 方法呢，GC 不可能在这个时候来回收它的。


   接着往下看 Full GC 的信息，会发现一个很有趣的现象，PSOldGen: 0K  -> 160K，可以看到，Full GC 后，老

年代的内存使用从 0K 变成了 160K，想必你已经猜到大概是怎么回事了。当 Full GC 进行的时候，默认的方式是尽

量清空新生代 ( YoungGen )，因此在调 System.gc() 时，新生代 ( YoungGen ) 中存活的对象会提前进入老年代。


第  行触发的 Minor GC 收集分析：

    从信息 PSYoungGen : 2703K -> 1056K，可以知道，在第 21 行创建的，大小为 1M 的数组被 GC 回收了。在第

22 行创建的，大小也为 1M 的数组由于 bytes 引用变量还在引用它，因此，它暂时未被 GC 回收。 


第23行触发的 Full GC 收集分析：

   在 Minor GC 的时候，信息显示 PSYoungGen :  2703K -> 1056K，FullGC 中显示的 PSYoungGen :  1056K ->

 0K，以及 PSOldGen:  160K -> 1184K，可以知道，新生代 (YoungGen ) 中存活的对象又提前进入老年代了。

====================================================================================================== 

https://www.cnblogs.com/nantang/p/5674793.html

Jvm 内存浅析 及 GC个人学习总结

从诞生至今，20多年过去，Java至今仍是使用最为广泛的语言。这仰赖于Java提供的各种技术和特性，让开发人员能优雅的编写高效的程序。今天我们就来说说Java的一项基本但非常重要的技术内存管理

了解C语言的同学都知道，在C语言中内存的开辟和释放都是由我们自己来管理的，每一个new操作都要对于一个delete操作，否则就会参数内存泄漏和溢出的问题，导致非常槽糕的后果。但在Java开发过程中，则完全不需要担心这个问题。因为jvm提供了自动内存管理的机制。内存管理的工作由jvm帮我们完成。这样我们就不用为了释放内存而头疼了。
Jvm内存浅析

虽然jvm帮我们做了内存管理的工作，但是我们仍需要了解jvm到底做了什么，下面我们就一起去看一看

jvm启动时进行一系列的工作，其中一项就是开辟一块运行时内存。而这一块内存中又分为了五大区域，分别用于不同的功能。

 

 

程序计数器

 记录程序运行的下一条指令的地址，这里的“地址”可以是一个本地指针，也可以是在方法字节码中相对于该方法起始指令的偏移量。如果该线程正在执行一个本地方法，那么此时程序计数器的值为”undefined”.在多线程环境下，每一个线程都有自己的程序计数器，在jvm调度线程时，会把当前的线程的程序计数器保存到快照，以便下次线程获取执行时间时获取

VM Stack

虚拟机栈是Java方法执行的内存模型，每个方法执行的时候，会在栈中创建一帧用于存储局部变量表、操作数栈、动态链接、方法出口。方法开始调用时，会创建栈帧并入栈，方法执行结束时会出栈。每个线程都有自己的栈。

动态链接：是一种在常量池中指向方法的符号引用，需要在运行期确定为直接引用

方法出口：当前执行方法的调用者的程序计数器，或异常处理表的地址

可以通过 -xxs 大小 来配置栈的大小，当嵌套调用使用不当，会导致方法不停的入栈，最终导致栈空间被占满产生 StackOverflowError

本地方法栈

Heap

堆是用于存放对象实例的地方，几乎所有对象实例在堆中分配。堆是线程共享的，这是多线程时同步机制的原因。

堆是GC管理的主要区域，GC在对堆进行回收前，首先要确定对象是否已死（不可能再被使用的对象）

判断对象是否存活的算法有两种：引用计数算法、可达性分析算法

引用计数算法是为每一个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加一，任何时刻计数器为0的对象就不可能再被使用。这种算法实现简单，但是它很难解决对象循环引用的问题(何为循环引用见下方备注)

可达性分析算法是Java语言正在使用的算法。它的基本思想是通过一系统被称为“GC Root”的对象为起点，从这个起点向下搜索，搜索走过的路径称为引用链，当一个对象不再任何引用链上时，则说明这个对象是不可能再被使用的。

在Java语言中，GC Root包括以下几种对象：

    虚拟机栈中引用的对象
    本地方法栈中JNI引用的对象
    方法区中类静态成员变量引用的对象
    方法区中常量引用的对象

可以看出分析对象是否存活，都与引用有关。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为 强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)

    强引用

强引用即为原来意义上的引用，只要强引用存在，被引用的对象就不会被回收

    软引用

SoftReference类表示软引用，对于被软引用关联的对象，在系统将要发生内存溢出时，会把这些对象列入回收范围后，进行二次回收

    弱引用

WeakReference类表示弱引用，对于被弱引用关联的对象，只能生存到下一次垃圾回收发生之前

    虚引用

PhantomReference类表示虚引用，虚引用不对关联的对象的生存时间构成影响，也无法取得对象实例，它唯一的作用是在对象被GC回收是收到一条系统通知

堆得大小可以通过-Xmx和-Xms来控制。对于主流的Jvm，GC基本都采用分代收集的算法。基于这个算法， Java堆又分为新生代(Young Generation)和老年代(Old Generation)，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。老生代用于存放新生代中经过多次垃圾回收(也即Minor GC)仍然存活的对象。

永生代(Permanent Space)为方法区

 

 

方法区

方法区也为所以线程所共享，用于存放已加载的类信息、静态变量、常量和即时编译器编译后的代码。-XX:MaxPermSize用于设置方法区大小

直接内存

直接内存不是虚拟机运行时数据区的一部分。通过Native函数库直接分配的堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作
内存分配和回收策略

目前为止，jvm已经发展处三种比较成熟的垃圾收集算法：1.标记-清除算法；2.复制算法；3.标记-整理算法；4.分代收集算法

1．        标记-清除算法

这种垃圾回收一次回收分为两个阶段：标记、清除。首先标记所有需要回收的对象，在标记完成后回收所有被标记的对象。这种回收算法会产生大量不连续的内存碎片，当要频繁分配一个大对象时，jvm在新生代中找不到足够大的连续的内存块，会导致jvm频繁进行内存回收(目前有机制，对大对象，直接分配到老年代中)

2．        复制算法

这种算法会将内存划分为两个相等的块，每次只使用其中一块。当这块内存不够使用时，就将还存活的对象复制到另一块内存中，然后把这块内存一次清理掉。这样做的效率比较高，也避免了内存碎片。但是这样内存的可使用空间减半，是个不小的损失。

3．        标记-整理算法

这是标记-清除算法的升级版。在完成标记阶段后，不是直接对可回收对象进行清理，而是让存活对象向着一端移动，然后清理掉边界以外的内存

4．        分代收集算法

当前商业虚拟机都采用这种算法。首先根据对象存活周期的不同将内存分为几块即新生代、老年代，然后根据不同年代的特点，采用不同的收集算法。在新生代中，每次垃圾收集时都有大量对象死去，只有少量存活，所以选择了复制算法。而老年代中因为对象存活率比较高，所以采用标记-整理算法(或者标记-清除算法)

GC的执行机制

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。

　　Minor GC

　　一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

　　Full GC

　　对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

　　1.年老代（Tenured）被写满

　　2.持久代（Perm）被写满

　　3.System.gc()被显示调用

     4.上一次GC之后Heap的各域分配策略动态变化

Java常见的内存泄漏

    数据库连接，网络连接，IO连接等没有显示调用close关闭，会导致内存泄露
    监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露
    
    
=================================================================================================

深入理解Java虚拟机笔记---原子性、可见性、有序性
https://blog.csdn.net/xtayfjpk/article/details/41969915

   Java内存模型是围绕着并发过程中如何处理原子性、可见性、有序性这三个特征来建立的，下面是这三个特性的实现原理：
1.原子性(Atomicity)
   由Java内存模型来直接保证的原子性变量操作包括read、load、use、assign、store和write六个，大致可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块---synchronized关键字，因此在synchronized块之间的操作也具备原子性。

2.可见性(Visibility)
   可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。
   除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的，而final关键字的可见性是指：被final修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传递出去，那么在其它线程中就能看见final字段的值。

3.有序性(Ordering)
   Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。
   Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则来获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

先行发生原则：
   如果Java内存模型中所有的有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很嗦，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”(Happen-Before)的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的主要依赖。
   先行发生原则是指Java内存模型中定义的两项操作之间的依序关系，如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。它意味着什么呢？如下例：
//线程A中执行
i = 1;
//线程B中执行
j = i;
//线程C中执行
i = 2;

假设线程A中的操作”i=1“先行发生于线程B的操作”j=i“，那么我们就可以确定在线程B的操作执行后，变量j的值一定是等于1，结出这个结论的依据有两个，一是根据先行发生原则，”i=1“的结果可以被观察到；二是线程C登场之前，线程A操作结束之后没有其它线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和B之间的先行发生关系，而线程C出现在线程A和B操作之间，但是C与B没有先行发生关系，那么j的值可能是1，也可能是2，因为线程C对应变量i的影响可能会被线程B观察到，也可能观察不到，这时线程B就存在读取到过期数据的风险，不具备多线程的安全性。
   下面是Java内存模型下一些”天然的“先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。
a.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。
b.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。
c.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。
d.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。
e.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。
f.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。
g.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。
g.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

  一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生“呢？也是不成立的，一个典型的例子就是指令重排序。所以时间上的先后顺序与先生发生原则之间基本没有什么关系，所以衡量并发安全问题一切必须以先行发生原则为准。
  
==============================================================================================================

5、并发编程的3个概念：原子性、可见性、有序性
https://blog.csdn.net/u010796790/article/details/52155664

并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

原子性：一个操作或多个操作要么全部执行完成且执行过程不被中断，要么就不执行。

可见性：当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

有序性：程序执行的顺序按照代码的先后顺序执行。

对于单线程，在执行代码时jvm会进行指令重排序，处理器为了提高效率，可以对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证保存最终执行结果和代码顺序执行的结果是一致的。
Java语言对原子性、可见性、有序性的保证

1、原子性

在java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断，要么执行，要么不执行。

X=10;  //原子性（简单的读取、将数字赋值给变量）
Y = x;  //变量之间的相互赋值，不是原子操作
X++;  //对变量进行计算操作
X = x+1;

语句2实际包括两个操作，它先要去读取x的值，再将y值写入，两个操作分开是原子性的。合在一起就不是原子性的。
语句3、4:x++  x=x+1包括3个操作：读取x的值，x+1，将x写入
注：可以通过 synchronized和Lock实现原子性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。

2、可见性

Java提供了volatile关键字保证可见性。
当一个共享变量被volatile修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。
Synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中，

3、有序性
在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述volatile关键字）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

Java内存模型：每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

指令重排序：java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。

指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。

下面就来具体介绍下happens-before原则（先行发生原则）：

程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作

volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。

传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。

线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作

线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行

对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
  
  
==========================================================================================================

 原子性与可见性
https://www.cnblogs.com/mengyan/archive/2012/08/22/2651575.html

一、定义

1.可见性

在多核处理器中，如果多个线程对一个变量（假设）进行操作，但是这多个线程有可能被分配到多个处理器中运行，那么编译器会对代码进行优化，当线程要处理该变量时，多个处理器会将变量从主存复制一份分别存储在自己的片上存储器中，等到进行完操作后，再赋值回主存。（这样做的好处是提高了运行的速度，因为在处理过程中多个处理器减少了同主存通信的次数）；同样在单核处理器中这样由于“备份”造成的问题同样存在！

这样的优化带来的问题之一是变量可见性――如果线程t1与线程t2分别被安排在了不同的处理器上面，那么t1与t2对于变量A的修改时相互不可见，如果t1给A赋值，然后t2又赋新值，那么t2的操作就将t1的操作覆盖掉了，这样会产生不可预料的结果。所以，即使有些操作时原子性的，但是如果不具有可见性，那么多个处理器中备份的存在就会使原子性失去意义。

2.原子性：

众所周知，原子是构成物质的基本单位（当然电子等暂且不论），所以原子的意思代表着――“不可分”；

由不可分性可知，原子性是拒绝多线程操作的（只有分解为多步操作，多个线程才能对其操作：就像一个盒子里有多个兵乓球，多个人能够从盒子里拿乒乓球；如果盒子只有一个兵乓球，一个人拿的话，其他人就拿不到了；这就是原子性，乒乓球就具有原子性，人就相当于原子）

 简而言之――不被线程调度器中断的操作，如：

赋值或者return。比如"a = 1;"和 "return a;"这样的操作都具有原子性

原子性不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作！

3.非原子性操作

类似"a += b"这样的操作不具有原子性，在某些JVM中"a += b"可能要经过这样三个步骤：

（1）取出a和b

（2）计算a+b

（3）将计算结果写入内存

如果有两个线程t1,t2在进行这样的操作。t1在第二步做完之后还没来得及把数据写回内存就被线程调度器中断了，于是t2开始执行，t2执行完毕后t1又把没有完成的第三步做完。这个时候就出现了错误，相当于t2的计算结果被无视掉了。所以上面的买碘片例子在同步add方法之前，实际结果总是小于预期结果的，因为很多操作都被无视掉了。

类似的，像"a++"这样的操作也都不具有原子性。所以在多线程的环境下一定要记得进行同步操作

4.原子性与可见性的关系

原子性与可见性并没有直接关联的关系。说道这里，不得不要讨论一下多线程带来的问题及其本质。

（1）先来点废话，有可能会将多核与单核处理器进行不同的区分，这里我搞混了，其实在代码级别来说它们是相同的！

单核机器的多线程其实是为每个线程分配一个时间片段，所以实际上这些线程在微观来说在一个时间段内只有一个在执行。这里产生的问题是如果一个线程操作一个内存空间然后突然被线程调度器终止掉（挂起），由另一个线程获取CPU时间来对这个空间进行操作，那么着之间会产生不可预知的问题。

多核机器的基本原理与此是相同的，不同的是在同一时间，可能会有多个线程同时在进行操作（因为每个核心都可运行一项操作）。前面讲到，多核机器由于多核的原因其多个线程对于相同内存的操作会产生可见性的问题。（可见性在单核和多核中同样都存在）

（2）多线程中可见性造成的问题：

多个线程对相同变量的修改相互不可见，导致某部分操作被覆盖，比如：

count++； t1与t2两个线程准备操作它，当t1在自己存储空间内修改完count值之后，并没有及时将count修改回去，而是执行了count其它的操作――这时候，t2开始执行该操作，但是它并没有发现count值进行了改变，这样就造成了count值没有被及时更新而产生的相关错误。

（3）其它问题：

同样是count++语句，产生问题的语句还可能是其它原因造成的：t1与t2执行该语句，t1只比t2稍慢一点，t2修改后count，t1又将自己的结果写入count，这样t1的结果会对t2的结果进行覆盖，这种覆盖会造成一项不到的错误。

（1.2）非原子性造成的问题，多个线程在执行动作时某一方的“动作”“覆盖”了另一方；

（5）讨论：

可见性的问题造成了多线程的问题的一部分，确定变量的可见性只能解决一部分多线程的问题；而操作原子性是解决多线程的总的方法，因为它拒绝多个线程在同一时刻操作相同的一段内存。

 

5.volatile与synchronized关键字

（1）volatile

volatile赋予了变量可见――禁止编译器对成员变量进行优化，它修饰的成员变量在每次被线程访问时，都强迫从内存中重读该成员变量的值；而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存，这样在任何时刻两个不同线程总是看到某一成员变量的同一个值，这就是保证了可见性。文摘：

Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量
的原始值对比。这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。而volatile关键字就是提示
VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。
使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。
由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。 就跟C中的一样 禁止编译器进行
优化~~~~

注意：

如果给一个变量加上volatile修饰符，就相当于：每一个线程中一旦这个值发生了变化就马上刷新回主存，使得各个线程取出的值相同。编译器不要对这个变量的读、写操作做优化。但是值得注意的是，除了对long和double的简单操作之外，volatile并不能提供原子性。所以，就算你将一个变量修饰为volatile，但是对这个变量的操作并不是原子的，在并发环境下，还是不能避免错误的发生！

参考链接： http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html

（2）synchronized

synchronized为一段操作或内存进行加锁，它具有互斥性。当线程要操作被synchronized修饰的内存或操作时，必须首先获得锁才能进行后续操作；但是在同一时刻只能有一个线程获得相同的一把锁（对象监视器），所以它只允许一个线程进行操作。

简单的理解方法：

synchronized（object） method（）；

这相当与为menthod（）加了一把锁，这把锁就是object对象；当线程要访问method方法时，需要获取钥匙：object的对象监视器，如果该钥匙没人拿走（之前没有线程操作该方法或操作完成），则当前线程拿走钥匙（获取对象监视器），并操作方法；当操作完方法后，将“钥匙”放回原处！

如果“钥匙”不在原处，则该线程需要等待别人把钥匙放回来（等待即进入阻塞状态）；如果多个线程要获取该钥匙，则它们需要进行“竞争”（一般是根据线程的优先级进行竞争）  